(function(window, angular) {
    'use strict';

    angular.module('app', [
        'ngRoute', 'ui.bootstrap',
        'app.core', 'app.wallet'
    ]).config(appConfig);

    appConfig.$inject = ['$compileProvider'];



    function appConfig ($compileProvider) {
        $compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|ftp|mailto|file|bitcoin):/);
    }

})(window, window.angular);

(function(window, angular) {
    'use strict';

    angular.module('bitcoin', ['app.util']);

})(window, window.angular);

(function(window, angular) {
    'use strict';

    angular.module('app.core', ['hid']);

})(window, window.angular);

(function(window, angular) {
    'use strict';

    angular.module('hid', ['app.util', 'bitcoin']);

})(window, window.angular);

(function(window, angular) {
    'use strict';

    angular.module('app.util', ['ngToast', 'ipCookie']);

})(window, window.angular);

(function(window, angular) {
    'use strict';

    angular.module('app.wallet', [
        'hid', 'bitcoin', 'app.util',
        'monospaced.qrcode' // https://github.com/monospaced/angular-qrcode
    ]);

})(window, window.angular);

(function(window, angular) {
    'use strict';

    angular.module('app')
        .config(config);

    config.$inject = ['$routeProvider', '$locationProvider'];

    function config($routeProvider, $locationProvider) {
        $locationProvider.html5Mode(true).hashPrefix('!');
        $routeProvider.otherwise('/bitlox_hardware_wallet');
        $routeProvider.when('/bitlox_hardware_wallet', {
            controller: 'WalletCtrl',
            controllerAs: 'vm',
            templateUrl: 'bitlox_hardware_wallet/wallet/wallets.html'
        });

//         $routeProvider.when('/', {
//             templateUrl: 'core/landing.html'
//         });
    }

})(window, window.angular);

(function(window, angular) {
    'use strict';

    angular.module('bitcoin')
        .factory('addressInfo', addressInfoFactory);

    addressInfoFactory.$inject = [
        '$q',
        '$http',
        'hexUtil',
    ];

    function addressInfoFactory($q, $http, hexUtil) {

        var baseUrl = 'https://bitlox.io/api';
//         var baseUrl = '/api';

        var addressInfo = {};

        addressInfo.getReceived = function(address) {
            return $http.get(baseUrl + '/addr/' + address).then(function(res) {
                return res.data;
            }, function(err) {
                if (err.status === 404) {
                    return {
                        received: 0,
                        balance: 0,
                        unconfirmed_sent: 0,
                        unconfirmed_received: 0,
                        unconfirmed_balance: 0
                    };
                } else {
                    return $q.reject(err.data);
                }
            });
        };

        addressInfo.getUnspent = function(address) {
//             return $http.get(baseUrl + '/' + address + '/unspent_outputs').then(function(res) {
            return $http.get(baseUrl + '/addr/' + address + '/utxo').then(function(res) {
                var outs = res.data;
                outs.forEach(function(out) {
                    // make this data just loke blockchain.info's
//                     var hash = out.tx_hash_big_endian = out.transaction_hash;
//                     out.tx_hash = hexUtil.makeStringSmallEndian(hash);
//                     out.value = out.amount;
//                     out.script = out.script_hex;
//                     out.tx_output_n = out.output_index;
//                     var hash = out.tx_hash_big_endian = out.txid;
                    var hash = out.tx_hash_big_endian = out.txid;
                    out.tx_hash = hexUtil.makeStringSmallEndian(hash);
                    out.value = out.amount * 100000000;
                    out.script = out.scriptPubKey;
                    out.tx_output_n = out.vout;
                });
                return outs;
            }, function(err) {
                if (err.status === 404) {
                    return [];
                }
                return $q.reject(err.data);
            });
        };

//         addressInfo.getTransactions = function(address) {
// //             return $http.get(baseUrl + '/' + address + '/transactions').then(function(res) {
//             return $http.get(baseUrl + '/txs/?address=' + address ).then(function(res) {
//                 var txs = res.data.transactions;
//                 txs = txs.concat(res.data.unconfirmed_transactions);
//                 return txs;
//             }, function(err) {
//                 if (err.status === 404) {
//                     return [];
//                 } else {
//                     return $q.reject(err.data);
//                 }
//             });
//         };
        addressInfo.getTransactions = function(address) {
//             return $http.get(baseUrl + '/' + address + '/transactions').then(function(res) {
            return $http.get(baseUrl + '/txs/?address=' + address ).then(function(res) {
                var txs = res.data.txs;
//                 txs = txs.concat(res.data.unconfirmed_transactions);
                return txs;
            }, function(err) {
                if (err.status === 404) {
                    return [];
                } else {
                    return $q.reject(err.data);
                }
            });
        };

        return addressInfo;
    }

})(window, window.angular);

(function(window, angular, BigNumber) {
    'use strict';

    angular.module('bitcoin')
        .factory('bcMath', bcMathFactory);

    bcMathFactory.$inject = ['COIN'];

    function bcMathFactory(COIN) {

        var bcMath = {
            satoshiToBTC: satoshiToBTC,
            toBTC: satoshiToBTC,
            btcToSatoshi: btcToSatoshi,
            toSatoshi: btcToSatoshi
        };

        var bitcoin = new BigNumber(COIN);

        return bcMath;

        function satoshiToBTC(satoshi) {
            return new BigNumber(satoshi).dividedBy(bitcoin).toNumber();
        }

        function btcToSatoshi(btc) {
            return new BigNumber(btc).times(bitcoin).toNumber();
        }
    }

})(window, window.angular, window.BigNumber);

(function(window, angular) {
    'use strict';

    angular.module('bitcoin')
        .filter('bcNumber', bcNumberFactory);

    bcNumberFactory.$inject = ['$filter'];

    function bcNumberFactory($filter) {
        var filter = $filter('number');
        var replace = /\.?0+$/;
        return function bcNumber(input) {
            var output = filter(input, 8);
            return output.replace(replace, '');
        };
    }

})(window, window.angular);

(function(window, angular, Bitcoin, BIP32) {
    'use strict';

    angular.module('bitcoin')
        .factory('BIP32', Bip32Factory);

    Bip32Factory.$inject = [
        'MAINNET_PUBLIC',
        'MAINNET_PRIVATE',
        'TESTNET_PUBLIC',
        'TESTNET_PRIVATE',
        'RECEIVE_CHAIN',
        'CHANGE_CHAIN',
        'GAP'
    ];

    function Bip32Factory(MAINNET_PUBLIC, MAINNET_PRIVATE,
                          TESTNET_PUBLIC, TESTNET_PRIVATE,
                          RECEIVE_CHAIN, CHANGE_CHAIN, GAP) {

        var Bip32 = function(xpub) {
            var bip32 = this;
            var key = bip32.key = new BIP32(xpub);
            switch (key.version) {
            case MAINNET_PUBLIC:
                bip32.keylabel = "Public key";
                bip32.network = 'prod';
                bip32.networklabel = "Bitcoin Mainnet";
                break;
            case MAINNET_PRIVATE:
                bip32.keylabel = "Private key";
                bip32.network = 'prod';
                bip32.networklabel = "Bitcoin Mainnet";
                break;
            case TESTNET_PUBLIC:
                bip32.keylabel = "Public key";
                bip32.network = 'test';
                bip32.networklabel = "Bitcoin Testnet";
                break;
            case TESTNET_PRIVATE:
                bip32.keylabel = "Private key";
                bip32.network = 'test';
                bip32.networklabel = "Bitcoin Testnet";
                break;
            default:
                throw new Error("Unknown key version");
            }
            Bitcoin.setNetwork(bip32.network);

            bip32.chains = {
                receive: key.derive_child(RECEIVE_CHAIN),
                change: key.derive_child(CHANGE_CHAIN)
            };

            bip32.keyCount = {
                receive: GAP,
                change: GAP
            };
        };

        Bip32.prototype.generateAddress = function(chain, index) {
            var bip32 = this;
            if (!bip32.chains[chain]) {
                throw new Error("Invalid chain");
            }
            var address = {};
            var childKey = bip32.chains[chain].derive_child(index);
            var childAddr = childKey.eckey.getBitcoinAddress().toString();
            address.pub = childAddr;
            address.key = childKey;
            return address;
        };

        Bip32.prototype.generateAddresses = function(chain) {
            var bip32 = this;
            if (!bip32.chains[chain]) {
                throw new Error("Invalid chain");
            }
            var addresses = {};
            for (var i = 0; i < bip32.keyCount[chain]; i++) {
                var address = bip32.generateAddress(chain, i);
                addresses[address.pub] = address;
            }
            return addresses;
        };

        return Bip32;

    }

})(window, window.angular, window.Bitcoin, window.BIP32);

(function(window, angular) {
    'use strict';

    angular.module('bitcoin')
        .constant('BIP39WordList', [
            "abandon", "ability", "able", "about", "above", "absent",
            "absorb", "abstract", "absurd", "abuse", "access", "accident",
            "account", "accuse", "achieve", "acid", "acoustic", "acquire",
            "across", "act", "action", "actor", "actress", "actual",
            "adapt", "add", "addict", "address", "adjust", "admit",
            "adult", "advance", "advice", "aerobic", "affair", "afford",
            "afraid", "again", "age", "agent", "agree", "ahead",
            "aim", "air", "airport", "aisle", "alarm", "album",
            "alcohol", "alert", "alien", "all", "alley", "allow",
            "almost", "alone", "alpha", "already", "also", "alter",
            "always", "amateur", "amazing", "among", "amount", "amused",
            "analyst", "anchor", "ancient", "anger", "angle", "angry",
            "animal", "ankle", "announce", "annual", "another", "answer",
            "antenna", "antique", "anxiety", "any", "apart", "apology",
            "appear", "apple", "approve", "april", "arch", "arctic",
            "area", "arena", "argue", "arm", "armed", "armor",
            "army", "around", "arrange", "arrest", "arrive", "arrow",
            "art", "artefact", "artist", "artwork", "ask", "aspect",
            "assault", "asset", "assist", "assume", "asthma", "athlete",
            "atom", "attack", "attend", "attitude", "attract", "auction",
            "audit", "august", "aunt", "author", "auto", "autumn",
            "average", "avocado", "avoid", "awake", "aware", "away",
            "awesome", "awful", "awkward", "axis", "baby", "bachelor",
            "bacon", "badge", "bag", "balance", "balcony", "ball",
            "bamboo", "banana", "banner", "bar", "barely", "bargain",
            "barrel", "base", "basic", "basket", "battle", "beach",
            "bean", "beauty", "because", "become", "beef", "before",
            "begin", "behave", "behind", "believe", "below", "belt",
            "bench", "benefit", "best", "betray", "better", "between",
            "beyond", "bicycle", "bid", "bike", "bind", "biology",
            "bird", "birth", "bitter", "black", "blade", "blame",
            "blanket", "blast", "bleak", "bless", "blind", "blood",
            "blossom", "blouse", "blue", "blur", "blush", "board",
            "boat", "body", "boil", "bomb", "bone", "bonus",
            "book", "boost", "border", "boring", "borrow", "boss",
            "bottom", "bounce", "box", "boy", "bracket", "brain",
            "brand", "brass", "brave", "bread", "breeze", "brick",
            "bridge", "brief", "bright", "bring", "brisk", "broccoli",
            "broken", "bronze", "broom", "brother", "brown", "brush",
            "bubble", "buddy", "budget", "buffalo", "build", "bulb",
            "bulk", "bullet", "bundle", "bunker", "burden", "burger",
            "burst", "bus", "business", "busy", "butter", "buyer",
            "buzz", "cabbage", "cabin", "cable", "cactus", "cage",
            "cake", "call", "calm", "camera", "camp", "can",
            "canal", "cancel", "candy", "cannon", "canoe", "canvas",
            "canyon", "capable", "capital", "captain", "car", "carbon",
            "card", "cargo", "carpet", "carry", "cart", "case",
            "cash", "casino", "castle", "casual", "cat", "catalog",
            "catch", "category", "cattle", "caught", "cause", "caution",
            "cave", "ceiling", "celery", "cement", "census", "century",
            "cereal", "certain", "chair", "chalk", "champion", "change",
            "chaos", "chapter", "charge", "chase", "chat", "cheap",
            "check", "cheese", "chef", "cherry", "chest", "chicken",
            "chief", "child", "chimney", "choice", "choose", "chronic",
            "chuckle", "chunk", "churn", "cigar", "cinnamon", "circle",
            "citizen", "city", "civil", "claim", "clap", "clarify",
            "claw", "clay", "clean", "clerk", "clever", "click",
            "client", "cliff", "climb", "clinic", "clip", "clock",
            "clog", "close", "cloth", "cloud", "clown", "club",
            "clump", "cluster", "clutch", "coach", "coast", "coconut",
            "code", "coffee", "coil", "coin", "collect", "color",
            "column", "combine", "come", "comfort", "comic", "common",
            "company", "concert", "conduct", "confirm", "congress", "connect",
            "consider", "control", "convince", "cook", "cool", "copper",
            "copy", "coral", "core", "corn", "correct", "cost",
            "cotton", "couch", "country", "couple", "course", "cousin",
            "cover", "coyote", "crack", "cradle", "craft", "cram",
            "crane", "crash", "crater", "crawl", "crazy", "cream",
            "credit", "creek", "crew", "cricket", "crime", "crisp",
            "critic", "crop", "cross", "crouch", "crowd", "crucial",
            "cruel", "cruise", "crumble", "crunch", "crush", "cry",
            "crystal", "cube", "culture", "cup", "cupboard", "curious",
            "current", "curtain", "curve", "cushion", "custom", "cute",
            "cycle", "dad", "damage", "damp", "dance", "danger",
            "daring", "dash", "daughter", "dawn", "day", "deal",
            "debate", "debris", "decade", "december", "decide", "decline",
            "decorate", "decrease", "deer", "defense", "define", "defy",
            "degree", "delay", "deliver", "demand", "demise", "denial",
            "dentist", "deny", "depart", "depend", "deposit", "depth",
            "deputy", "derive", "describe", "desert", "design", "desk",
            "despair", "destroy", "detail", "detect", "develop", "device",
            "devote", "diagram", "dial", "diamond", "diary", "dice",
            "diesel", "diet", "differ", "digital", "dignity", "dilemma",
            "dinner", "dinosaur", "direct", "dirt", "disagree", "discover",
            "disease", "dish", "dismiss", "disorder", "display", "distance",
            "divert", "divide", "divorce", "dizzy", "doctor", "document",
            "dog", "doll", "dolphin", "domain", "donate", "donkey",
            "donor", "door", "dose", "double", "dove", "draft",
            "dragon", "drama", "drastic", "draw", "dream", "dress",
            "drift", "drill", "drink", "drip", "drive", "drop",
            "drum", "dry", "duck", "dumb", "dune", "during",
            "dust", "dutch", "duty", "dwarf", "dynamic", "eager",
            "eagle", "early", "earn", "earth", "easily", "east",
            "easy", "echo", "ecology", "economy", "edge", "edit",
            "educate", "effort", "egg", "eight", "either", "elbow",
            "elder", "electric", "elegant", "element", "elephant", "elevator",
            "elite", "else", "embark", "embody", "embrace", "emerge",
            "emotion", "employ", "empower", "empty", "enable", "enact",
            "end", "endless", "endorse", "enemy", "energy", "enforce",
            "engage", "engine", "enhance", "enjoy", "enlist", "enough",
            "enrich", "enroll", "ensure", "enter", "entire", "entry",
            "envelope", "episode", "equal", "equip", "era", "erase",
            "erode", "erosion", "error", "erupt", "escape", "essay",
            "essence", "estate", "eternal", "ethics", "evidence", "evil",
            "evoke", "evolve", "exact", "example", "excess", "exchange",
            "excite", "exclude", "excuse", "execute", "exercise", "exhaust",
            "exhibit", "exile", "exist", "exit", "exotic", "expand",
            "expect", "expire", "explain", "expose", "express", "extend",
            "extra", "eye", "eyebrow", "fabric", "face", "faculty",
            "fade", "faint", "faith", "fall", "false", "fame",
            "family", "famous", "fan", "fancy", "fantasy", "farm",
            "fashion", "fat", "fatal", "father", "fatigue", "fault",
            "favorite", "feature", "february", "federal", "fee", "feed",
            "feel", "female", "fence", "festival", "fetch", "fever",
            "few", "fiber", "fiction", "field", "figure", "file",
            "film", "filter", "final", "find", "fine", "finger",
            "finish", "fire", "firm", "first", "fiscal", "fish",
            "fit", "fitness", "fix", "flag", "flame", "flash",
            "flat", "flavor", "flee", "flight", "flip", "float",
            "flock", "floor", "flower", "fluid", "flush", "fly",
            "foam", "focus", "fog", "foil", "fold", "follow",
            "food", "foot", "force", "forest", "forget", "fork",
            "fortune", "forum", "forward", "fossil", "foster", "found",
            "fox", "fragile", "frame", "frequent", "fresh", "friend",
            "fringe", "frog", "front", "frost", "frown", "frozen",
            "fruit", "fuel", "fun", "funny", "furnace", "fury",
            "future", "gadget", "gain", "galaxy", "gallery", "game",
            "gap", "garage", "garbage", "garden", "garlic", "garment",
            "gas", "gasp", "gate", "gather", "gauge", "gaze",
            "general", "genius", "genre", "gentle", "genuine", "gesture",
            "ghost", "giant", "gift", "giggle", "ginger", "giraffe",
            "girl", "give", "glad", "glance", "glare", "glass",
            "glide", "glimpse", "globe", "gloom", "glory", "glove",
            "glow", "glue", "goat", "goddess", "gold", "good",
            "goose", "gorilla", "gospel", "gossip", "govern", "gown",
            "grab", "grace", "grain", "grant", "grape", "grass",
            "gravity", "great", "green", "grid", "grief", "grit",
            "grocery", "group", "grow", "grunt", "guard", "guess",
            "guide", "guilt", "guitar", "gun", "gym", "habit",
            "hair", "half", "hammer", "hamster", "hand", "happy",
            "harbor", "hard", "harsh", "harvest", "hat", "have",
            "hawk", "hazard", "head", "health", "heart", "heavy",
            "hedgehog", "height", "hello", "helmet", "help", "hen",
            "hero", "hidden", "high", "hill", "hint", "hip",
            "hire", "history", "hobby", "hockey", "hold", "hole",
            "holiday", "hollow", "home", "honey", "hood", "hope",
            "horn", "horror", "horse", "hospital", "host", "hotel",
            "hour", "hover", "hub", "huge", "human", "humble",
            "humor", "hundred", "hungry", "hunt", "hurdle", "hurry",
            "hurt", "husband", "hybrid", "ice", "icon", "idea",
            "identify", "idle", "ignore", "ill", "illegal", "illness",
            "image", "imitate", "immense", "immune", "impact", "impose",
            "improve", "impulse", "inch", "include", "income", "increase",
            "index", "indicate", "indoor", "industry", "infant", "inflict",
            "inform", "inhale", "inherit", "initial", "inject", "injury",
            "inmate", "inner", "innocent", "input", "inquiry", "insane",
            "insect", "inside", "inspire", "install", "intact", "interest",
            "into", "invest", "invite", "involve", "iron", "island",
            "isolate", "issue", "item", "ivory", "jacket", "jaguar",
            "jar", "jazz", "jealous", "jeans", "jelly", "jewel",
            "job", "join", "joke", "journey", "joy", "judge",
            "juice", "jump", "jungle", "junior", "junk", "just",
            "kangaroo", "keen", "keep", "ketchup", "key", "kick",
            "kid", "kidney", "kind", "kingdom", "kiss", "kit",
            "kitchen", "kite", "kitten", "kiwi", "knee", "knife",
            "knock", "know", "lab", "label", "labor", "ladder",
            "lady", "lake", "lamp", "language", "laptop", "large",
            "later", "latin", "laugh", "laundry", "lava", "law",
            "lawn", "lawsuit", "layer", "lazy", "leader", "leaf",
            "learn", "leave", "lecture", "left", "leg", "legal",
            "legend", "leisure", "lemon", "lend", "length", "lens",
            "leopard", "lesson", "letter", "level", "liar", "liberty",
            "library", "license", "life", "lift", "light", "like",
            "limb", "limit", "link", "lion", "liquid", "list",
            "little", "live", "lizard", "load", "loan", "lobster",
            "local", "lock", "logic", "lonely", "long", "loop",
            "lottery", "loud", "lounge", "love", "loyal", "lucky",
            "luggage", "lumber", "lunar", "lunch", "luxury", "lyrics",
            "machine", "mad", "magic", "magnet", "maid", "mail",
            "main", "major", "make", "mammal", "man", "manage",
            "mandate", "mango", "mansion", "manual", "maple", "marble",
            "march", "margin", "marine", "market", "marriage", "mask",
            "mass", "master", "match", "material", "math", "matrix",
            "matter", "maximum", "maze", "meadow", "mean", "measure",
            "meat", "mechanic", "medal", "media", "melody", "melt",
            "member", "memory", "mention", "menu", "mercy", "merge",
            "merit", "merry", "mesh", "message", "metal", "method",
            "middle", "midnight", "milk", "million", "mimic", "mind",
            "minimum", "minor", "minute", "miracle", "mirror", "misery",
            "miss", "mistake", "mix", "mixed", "mixture", "mobile",
            "model", "modify", "mom", "moment", "monitor", "monkey",
            "monster", "month", "moon", "moral", "more", "morning",
            "mosquito", "mother", "motion", "motor", "mountain", "mouse",
            "move", "movie", "much", "muffin", "mule", "multiply",
            "muscle", "museum", "mushroom", "music", "must", "mutual",
            "myself", "mystery", "myth", "naive", "name", "napkin",
            "narrow", "nasty", "nation", "nature", "near", "neck",
            "need", "negative", "neglect", "neither", "nephew", "nerve",
            "nest", "net", "network", "neutral", "never", "news",
            "next", "nice", "night", "noble", "noise", "nominee",
            "noodle", "normal", "north", "nose", "notable", "note",
            "nothing", "notice", "novel", "now", "nuclear", "number",
            "nurse", "nut", "oak", "obey", "object", "oblige",
            "obscure", "observe", "obtain", "obvious", "occur", "ocean",
            "october", "odor", "off", "offer", "office", "often",
            "oil", "okay", "old", "olive", "olympic", "omit",
            "once", "one", "onion", "online", "only", "open",
            "opera", "opinion", "oppose", "option", "orange", "orbit",
            "orchard", "order", "ordinary", "organ", "orient", "original",
            "orphan", "ostrich", "other", "outdoor", "outer", "output",
            "outside", "oval", "oven", "over", "own", "owner",
            "oxygen", "oyster", "ozone", "pact", "paddle", "page",
            "pair", "palace", "palm", "panda", "panel", "panic",
            "panther", "paper", "parade", "parent", "park", "parrot",
            "party", "pass", "patch", "path", "patient", "patrol",
            "pattern", "pause", "pave", "payment", "peace", "peanut",
            "pear", "peasant", "pelican", "pen", "penalty", "pencil",
            "people", "pepper", "perfect", "permit", "person", "pet",
            "phone", "photo", "phrase", "physical", "piano", "picnic",
            "picture", "piece", "pig", "pigeon", "pill", "pilot",
            "pink", "pioneer", "pipe", "pistol", "pitch", "pizza",
            "place", "planet", "plastic", "plate", "play", "please",
            "pledge", "pluck", "plug", "plunge", "poem", "poet",
            "point", "polar", "pole", "police", "pond", "pony",
            "pool", "popular", "portion", "position", "possible", "post",
            "potato", "pottery", "poverty", "powder", "power", "practice",
            "praise", "predict", "prefer", "prepare", "present", "pretty",
            "prevent", "price", "pride", "primary", "print", "priority",
            "prison", "private", "prize", "problem", "process", "produce",
            "profit", "program", "project", "promote", "proof", "property",
            "prosper", "protect", "proud", "provide", "public", "pudding",
            "pull", "pulp", "pulse", "pumpkin", "punch", "pupil",
            "puppy", "purchase", "purity", "purpose", "purse", "push",
            "put", "puzzle", "pyramid", "quality", "quantum", "quarter",
            "question", "quick", "quit", "quiz", "quote", "rabbit",
            "raccoon", "race", "rack", "radar", "radio", "rail",
            "rain", "raise", "rally", "ramp", "ranch", "random",
            "range", "rapid", "rare", "rate", "rather", "raven",
            "raw", "razor", "ready", "real", "reason", "rebel",
            "rebuild", "recall", "receive", "recipe", "record", "recycle",
            "reduce", "reflect", "reform", "refuse", "region", "regret",
            "regular", "reject", "relax", "release", "relief", "rely",
            "remain", "remember", "remind", "remove", "render", "renew",
            "rent", "reopen", "repair", "repeat", "replace", "report",
            "require", "rescue", "resemble", "resist", "resource", "response",
            "result", "retire", "retreat", "return", "reunion", "reveal",
            "review", "reward", "rhythm", "rib", "ribbon", "rice",
            "rich", "ride", "ridge", "rifle", "right", "rigid",
            "ring", "riot", "ripple", "risk", "ritual", "rival",
            "river", "road", "roast", "robot", "robust", "rocket",
            "romance", "roof", "rookie", "room", "rose", "rotate",
            "rough", "round", "route", "royal", "rubber", "rude",
            "rug", "rule", "run", "runway", "rural", "sad",
            "saddle", "sadness", "safe", "sail", "salad", "salmon",
            "salon", "salt", "salute", "same", "sample", "sand",
            "satisfy", "satoshi", "sauce", "sausage", "save", "say",
            "scale", "scan", "scare", "scatter", "scene", "scheme",
            "school", "science", "scissors", "scorpion", "scout", "scrap",
            "screen", "script", "scrub", "sea", "search", "season",
            "seat", "second", "secret", "section", "security", "seed",
            "seek", "segment", "select", "sell", "seminar", "senior",
            "sense", "sentence", "series", "service", "session", "settle",
            "setup", "seven", "shadow", "shaft", "shallow", "share",
            "shed", "shell", "sheriff", "shield", "shift", "shine",
            "ship", "shiver", "shock", "shoe", "shoot", "shop",
            "short", "shoulder", "shove", "shrimp", "shrug", "shuffle",
            "shy", "sibling", "sick", "side", "siege", "sight",
            "sign", "silent", "silk", "silly", "silver", "similar",
            "simple", "since", "sing", "siren", "sister", "situate",
            "six", "size", "skate", "sketch", "ski", "skill",
            "skin", "skirt", "skull", "slab", "slam", "sleep",
            "slender", "slice", "slide", "slight", "slim", "slogan",
            "slot", "slow", "slush", "small", "smart", "smile",
            "smoke", "smooth", "snack", "snake", "snap", "sniff",
            "snow", "soap", "soccer", "social", "sock", "soda",
            "soft", "solar", "soldier", "solid", "solution", "solve",
            "someone", "song", "soon", "sorry", "sort", "soul",
            "sound", "soup", "source", "south", "space", "spare",
            "spatial", "spawn", "speak", "special", "speed", "spell",
            "spend", "sphere", "spice", "spider", "spike", "spin",
            "spirit", "split", "spoil", "sponsor", "spoon", "sport",
            "spot", "spray", "spread", "spring", "spy", "square",
            "squeeze", "squirrel", "stable", "stadium", "staff", "stage",
            "stairs", "stamp", "stand", "start", "state", "stay",
            "steak", "steel", "stem", "step", "stereo", "stick",
            "still", "sting", "stock", "stomach", "stone", "stool",
            "story", "stove", "strategy", "street", "strike", "strong",
            "struggle", "student", "stuff", "stumble", "style", "subject",
            "submit", "subway", "success", "such", "sudden", "suffer",
            "sugar", "suggest", "suit", "summer", "sun", "sunny",
            "sunset", "super", "supply", "supreme", "sure", "surface",
            "surge", "surprise", "surround", "survey", "suspect", "sustain",
            "swallow", "swamp", "swap", "swarm", "swear", "sweet",
            "swift", "swim", "swing", "switch", "sword", "symbol",
            "symptom", "syrup", "system", "table", "tackle", "tag",
            "tail", "talent", "talk", "tank", "tape", "target",
            "task", "taste", "tattoo", "taxi", "teach", "team",
            "tell", "ten", "tenant", "tennis", "tent", "term",
            "test", "text", "thank", "that", "theme", "then",
            "theory", "there", "they", "thing", "this", "thought",
            "three", "thrive", "throw", "thumb", "thunder", "ticket",
            "tide", "tiger", "tilt", "timber", "time", "tiny",
            "tip", "tired", "tissue", "title", "toast", "tobacco",
            "today", "toddler", "toe", "together", "toilet", "token",
            "tomato", "tomorrow", "tone", "tongue", "tonight", "tool",
            "tooth", "top", "topic", "topple", "torch", "tornado",
            "tortoise", "toss", "total", "tourist", "toward", "tower",
            "town", "toy", "track", "trade", "traffic", "tragic",
            "train", "transfer", "trap", "trash", "travel", "tray",
            "treat", "tree", "trend", "trial", "tribe", "trick",
            "trigger", "trim", "trip", "trophy", "trouble", "truck",
            "true", "truly", "trumpet", "trust", "truth", "try",
            "tube", "tuition", "tumble", "tuna", "tunnel", "turkey",
            "turn", "turtle", "twelve", "twenty", "twice", "twin",
            "twist", "two", "type", "typical", "ugly", "umbrella",
            "unable", "unaware", "uncle", "uncover", "under", "undo",
            "unfair", "unfold", "unhappy", "uniform", "unique", "unit",
            "universe", "unknown", "unlock", "until", "unusual", "unveil",
            "update", "upgrade", "uphold", "upon", "upper", "upset",
            "urban", "urge", "usage", "use", "used", "useful",
            "useless", "usual", "utility", "vacant", "vacuum", "vague",
            "valid", "valley", "valve", "van", "vanish", "vapor",
            "various", "vast", "vault", "vehicle", "velvet", "vendor",
            "venture", "venue", "verb", "verify", "version", "very",
            "vessel", "veteran", "viable", "vibrant", "vicious", "victory",
            "video", "view", "village", "vintage", "violin", "virtual",
            "virus", "visa", "visit", "visual", "vital", "vivid",
            "vocal", "voice", "void", "volcano", "volume", "vote",
            "voyage", "wage", "wagon", "wait", "walk", "wall",
            "walnut", "want", "warfare", "warm", "warrior", "wash",
            "wasp", "waste", "water", "wave", "way", "wealth",
            "weapon", "wear", "weasel", "weather", "web", "wedding",
            "weekend", "weird", "welcome", "west", "wet", "whale",
            "what", "wheat", "wheel", "when", "where", "whip",
            "whisper", "wide", "width", "wife", "wild", "will",
            "win", "window", "wine", "wing", "wink", "winner",
            "winter", "wire", "wisdom", "wise", "wish", "witness",
            "wolf", "woman", "wonder", "wood", "wool", "word",
            "work", "world", "worry", "worth", "wrap", "wreck",
            "wrestle", "wrist", "write", "wrong", "yard", "year",
            "yellow", "you", "young", "youth", "zebra", "zero",
            "zone", "zoo"
        ]);
})(window, window.angular);

(function(window, angular) {
    'use strict';

    angular.module('bitcoin')
        .constant('COIN', 100000000)
        .constant('DEFAULT_FEE', 10000) // 0.0001 BTC
        .constant('MIN_OUTPUT', 5460)   // 0.0000546 BTC
        .constant('MAINNET_PUBLIC', 0x0488b21e)
        .constant('MAINNET_PRIVATE', 0x0488ade4)
        .constant('TESTNET_PUBLIC', 0x043587cf)
        .constant('TESTNET_PRIVATE', 0x04358394)

        .constant('RECEIVE_CHAIN', 0)
        .constant('CHANGE_CHAIN', 1)
    // how many extra addresses to generate
        .constant('GAP', 1);

})(window, window.angular);

(function(window, angular, BigNumber) {
    'use strict';

    angular.module('bitcoin')
        .directive('bcInput', bcInput);

    bcInput.$inject = ['$rootScope'];

    function bcInput($rootScope) {
        return {
            template: '<input class="form-control crypto-input" ' +
                'type="text" ng-model="displayVal">' +
                '<span class="input-group-addon crypto-input-label">{{symbol}}</span>',
            restrict: 'E',
            scope: {
                intVal: '=model',
            },
            link: function(scope) {
                $rootScope.$watch('currency', function() {
                    scope.symbol = $rootScope.currency;
                    updateDisplay();
                });

                scope.$watch('intVal', function(newVal) {
                    if (newVal === undefined ||
                        scope.displayVal === undefined ||
                        !scope.displayVal.length) {
                        return;
                    }
                    var val = parseInt(newVal, 10);
                    if (scope.displayVal.toString().match(/^0+\.0+$/)) {
                        return;
                    } else if (!newVal.toString().length) {
                        scope.displayVal = 0;
                    } else if (isNaN(val)) {
                        scope.displayVal = "-";
                    } else {
                        updateDisplay();
                    }
                });

                scope.$watch('displayVal', function(newVal) {
                    if (newVal === undefined) {
                        return;
                    }
                    var val = new BigNumber(parseFloat(newVal));
                    if (!newVal.toString().length) {
                        scope.intVal = 0;
                    } else if (newVal.toString().match(/^0+\.0+$/)) {
                        scope.intVal = 0;
                    } else if (isNaN(val)) {
                        scope.intVal = NaN;
                    } else {
                        scope.intVal = Math.floor(val.times($rootScope.denomination).toNumber());
                    }
                });

                function updateDisplay() {
                    var val = new BigNumber(parseInt(scope.intVal, 10));
                    var numStr = val.dividedBy($rootScope.denomination).toString();
                    scope.displayVal = numStr;
                }
            }
        };
    }

})(window, window.angular, window.BigNumber);

(function(window, angular, BigInteger, Crypto, Bitcoin, ECPointFp, getSECCurveByName) {
    'use strict';

    angular.module('bitcoin')
        .factory('messageUtil', messageUtilFactory);

    messageUtilFactory.$inject = [];

    function messageUtilFactory() {

        var trimRegexp = /(^[\s\n]+|[\s\n]+$)/g;
        var MESSAGE_HEADER = "Bitcoin Signed Message:\n";

        var messageUtil = {
            trim: trim,
            makeMessageBytes: makeMessageBytes,
            getBytes: getBytes,
            processSignature: processSignature,
            MESSAGE_HEADER: MESSAGE_HEADER,
        };

        return messageUtil;

        function makeMessageBytes(message) {
            message = trim(message);
            return getBytes(MESSAGE_HEADER).concat(getBytes(message));
        }

        function trim(message) {
            return message.replace(trimRegexp, '');
        }

        function getBytes(str) {
            var bytes = Crypto.charenc.UTF8.stringToBytes(str);
            var len = bytes.length;
            if (len < 0xfd) { // 253
                bytes = [len].concat(bytes);
            } else if (len < 0xffff) { // 65535
                // ignore this line in jshint, it does not like
                // bitwise operations
                bytes = [0xfd, len & 0xff, len >>> 0x8].concat(bytes); // jshint ignore:line
            } else {
                throw new Error("Message to large");
            }
            return bytes;
        }

        function processSignature(message, address, sigBytes, compressed, addrType) {
            addrType = addrType || 0;
            if (compressed === undefined) {
                compressed = true;
            }
            var parsed = Bitcoin.ECDSA.parseSig(sigBytes);
            var sequence = [0];
            sequence = sequence.concat(parsed.r.toByteArrayUnsigned());
            sequence = sequence.concat(parsed.s.toByteArrayUnsigned());
            for (var i = 0; i < 4; i++) {
                var nV = 27 + i;
                if (compressed) {
                    console.debug("processSignature: is compressed");
                    nV += 4;
                }
                sequence[0] = nV;
                var sig = Crypto.util.bytesToBase64(sequence);
                var sigAddress = verifyMessage(sig, message, addrType);
                console.debug("processSignature: got sigAddress", sigAddress, "address=", address);
                if (sigAddress === address) {
                    console.debug("processSignature: found match");
                    return sig;
                }
            }
            console.debug("processSignature: no match found");
            return false;
        }

        function msgDigest(message) {
            var bytes = makeMessageBytes(message);
            return Crypto.SHA256(Crypto.SHA256(bytes, {asBytes:true}), {asBytes:true});
        }

        function verifyMessage(signature, message, addrtype) {
            var sig;
            try {
                sig = Crypto.util.base64ToBytes(signature);
            } catch(err) {
                console.error(err, signature);
                return false;
            }

            if (sig.length !== 65){
                console.error("Invalid sig length", sig.length, sig);
                return false;
	        }
            // extract r,s from signature
            var r = BigInteger.fromByteArrayUnsigned(sig.slice(1,1+32));
            var s = BigInteger.fromByteArrayUnsigned(sig.slice(33,33+32));

            // get recid
            var compressed = false;
            var nV = sig[0];
            if (nV < 27 || nV >= 35){
    	        console.error("nV error");
                return false;
            }
            if (nV >= 31) {
                compressed = true;
                nV -= 4;
            }
            var recid = BigInteger.valueOf(nV - 27);

            var ecparams = getSECCurveByName("secp256k1");
            var curve = ecparams.getCurve();
            var a = curve.getA().toBigInteger();
            var b = curve.getB().toBigInteger();
            var p = curve.getQ();
            var G = ecparams.getG();
            var order = ecparams.getN();

            var x = r.add(order.multiply(recid.divide(BigInteger.valueOf(2))));
            var alpha = x.multiply(x).multiply(x).add(a.multiply(x)).add(b).mod(p);
            var beta = alpha.modPow(p.add(BigInteger.ONE).divide(BigInteger.valueOf(4)), p);
            var y = beta.subtract(recid).isEven() ? beta : p.subtract(beta);

            var R = new ECPointFp(curve, curve.fromBigInteger(x), curve.fromBigInteger(y));
            var e = BigInteger.fromByteArrayUnsigned(msgDigest(message));
            var minus_e = e.negate().mod(order);
            var inv_r = r.modInverse(order);
            var Q = (R.multiply(s).add(G.multiply(minus_e))).multiply(inv_r);

            var public_key = Q.getEncoded(compressed);
            var addr = new Bitcoin.Address(Bitcoin.Util.sha256ripe160(public_key));
            addr.version = addrtype ? addrtype : 0;
            return addr.toString();
        }

    }

})(window, window.angular, window.BigInteger, window.Crypto, window.Bitcoin, window.ECPointFp, window.getSECCurveByName);

(function(window, angular, Bitcoin) {
    'use strict';

    angular.module('bitcoin')
        .factory('Transaction', TransactionFactory);

    TransactionFactory.$inject = ['hexUtil', 'DEFAULT_FEE', 'MIN_OUTPUT'];

    function TransactionFactory(hexUtil, DEFAULT_FEE, MIN_OUTPUT) {

        var ERR_INVALID_FEE          = Transaction.ERR_INVALID_FEE         = "Invalid fee";
        var ERR_NO_OUTPUTS           = Transaction.ERR_NO_OUTPUTS          = "No outputs";
        var ERR_INVALID_AMOUNT       = Transaction.ERR_INVALID_AMOUNT      = "Invalid amount";
        var ERR_AMOUNT_TOO_LOW       = Transaction.ERR_AMOUNT_TOO_LOW      = "Amount must be greater than " + MIN_OUTPUT;
        var ERR_NO_INPUTS            = Transaction.ERR_NO_INPUTS           = "Missing input array";
        var ERR_NO_CHANGE_ADDRESS    = Transaction.ERR_NO_CHANGE_ADDRESS   = "Missing change address";
        var ERR_INSUFFICIENT_INPUTS  = Transaction.ERR_INSUFFICIENT_INPUTS = "Not enough inputs";
        var ERR_BAD_SIGNED_SCRIPTS   = Transaction.ERR_BAD_SIGNED_SCRIPTS  = "Invalid signed scripts";

        function Transaction(options) {
            var fee = this.fee = options.fee === undefined ? DEFAULT_FEE : parseInt(options.fee, 10);
            if (isNaN(fee) || fee < 0) {
                throw ERR_INVALID_FEE;
            }
            var outputs = this.outputs = options.outputs;
            if (!outputs) {
                // if no outputs in the options, look for "to" and
                // "amount" and make an output object
                var to = options.to;
                if (!to) {
                    throw ERR_NO_OUTPUTS;
                }
                var amount = parseInt(options.amount, 10);
                if (isNaN(amount)) {
                    throw ERR_INVALID_AMOUNT;
                }
                outputs = this.outputs = [{
                    address: to,
                    amount: amount
                }];
            }
            if (!Array.isArray(outputs)) {
                outputs = [outputs];
            }
            var inputs = options.inputs;
            if (!inputs || !Array.isArray(inputs)) {
                throw ERR_NO_INPUTS;
            }
            // sort inputs by most to least confirmations
            inputs.sort(function(a, b) {
                return a.confirmations > b.confirmations ? -1 : 1;
            });
            var changeAddress = this.changeAddress = options.change || options.changeAddress;
            if (!changeAddress) {
                throw ERR_NO_CHANGE_ADDRESS;
            }

            // make a new transaction
            this.tx = new Bitcoin.Transaction();
            // initialize total out and in
            this.totalOut = 0;
            this.totalIn = 0;
            // set up empty input array on 'this', it gets filled with
            // the inputs we actually use on calling addInputs
            this.inputs = [];
            // now add the outputs
            this.addOutputs(outputs);
            // set the target amount
            this.target = this.totalOut + this.fee;
            // then add inputs
            var change = this.changeAmount = this.addInputs(inputs);
            if (change < 0) {
                // if change is less than 0, out inputs were not enough to
                // cover the outputs
                throw ERR_INSUFFICIENT_INPUTS;
            } else if (change > 0 && change < MIN_OUTPUT) {
                if (options.forceSmallChange) {
                    this.addOutput({
                        address: changeAddress,
                        amount: change
                    }, 'force it');
                } else {
                    throw {
                        change: change
                    };
                }
            } else if (change > 0) {
                // if greater than 0, then we have change left over,
                // send it to the change address provided
                this.addOutput({
                    address: changeAddress,
                    amount: change
                });
            }
            // set the unsigned tx to this instance
            this.unsignedHex = Bitcoin.Util.bytesToHex(this.tx.serialize());
            console.debug("transaction assembled", this);
        }

        // add outputs will take the outputs for our API and convert
        // them to the bitcoinjs API and add them to the transaction.
        // return the total of the output values we encountered this
        // run

        Transaction.prototype.addOutputs = function(outputs) {
            outputs.forEach(this.addOutput, this);
        };

        Transaction.prototype.addOutput = function(output, forceSmall) {
            var amount = parseInt(output.amount, 10);
            if (isNaN(amount)) {
                throw ERR_INVALID_AMOUNT;
            }
            if (amount < MIN_OUTPUT && !forceSmall) {
                throw ERR_AMOUNT_TOO_LOW;
            }
            this.totalOut += amount;
            var address = output.address;
            var bcAddr = new Bitcoin.Address(address);
            var bcOut = new Bitcoin.TransactionOut({
                value: hexUtil.intToBigEndianValue(amount, 8),
                script: Bitcoin.Script.createOutputScript(bcAddr)
            });
            this.tx.addOutput(bcOut);
        };

        // add inputs will take the inputs for our API and convert
        // them to the bitcoinjs API and add them to the transaction.
        // add all inputs we use to the 'inputs' array on our
        // Transaction instance

        // return the remainder to send to change
        Transaction.prototype.addInputs = function(inputs) {
            inputs.forEach(this.addInput, this);
            return this.totalIn - this.target;
        };

        Transaction.prototype.addInput = function(input) {
            // if we have all the inputs we need to cover the
            // output and the fee, just move on
            if (this.totalIn >= this.target) {
                return;
            }
            if (input.confirmations < 1) {
                return;
            }
//             var amount = parseInt(input.value, 10);
			console.debug("adding inputs");
            var amount = parseInt(input.value, 10);
            if (isNaN(amount)) {
                throw ERR_INVALID_AMOUNT;
            }
//             var hash = Bitcoin.Util.bytesToBase64(Bitcoin.Util.hexToBytes(input.txid));
            var hash = Bitcoin.Util.bytesToBase64(Bitcoin.Util.hexToBytes(hexUtil.makeStringSmallEndian(input.txid)));
            var script = Bitcoin.Util.hexToBytes(input.script);
            var bcIn = new Bitcoin.TransactionIn({
                outpoint: {
                    hash: hash,
                    index: input.vout
                },
                script: script,
                sequence: 4294967295
            });
            this.tx.addInput(bcIn);
            // add some more info to the input object here
            this.inputs.push(input);
            this.totalIn += amount;
        };

        Transaction.prototype.replaceScripts = function(signedScripts) {
            if (!Array.isArray(signedScripts)) {
                throw ERR_BAD_SIGNED_SCRIPTS;
            }
            if (signedScripts.length !== this.inputs.length) {
                throw ERR_BAD_SIGNED_SCRIPTS;
            }
            var hex = this.unsignedHex;
            this.inputs.forEach(function(input, index) {
                hex = hex.replace('19' + input.script, signedScripts[index]);
            });
            this.signedHex = hex;
            return hex;
        };

        return Transaction;
    }

})(window, window.angular, window.Bitcoin);

(function(window, angular) {
    'use strict';

    angular.module('bitcoin')
        .factory('txUtil', txUtilFactory);

    txUtilFactory.$inject = [
        '$q',
        '$http',
    ];

    function txUtilFactory($q, $http) {


        var baseUrl = 'https://bitlox.io/api';

//         var baseUrl = '/api';

        var txUtil = {
            getHex: getHex,
            submit: submit,
        };

        function getHex(bigEndianTxid) {
        	console.debug("raw source txid " + bigEndianTxid);
            return $http.get(baseUrl + '/rawtx/' + bigEndianTxid ).then(function(res) {
            	console.debug("raw source tx " + res.data.rawtx);
                return res.data.rawtx;
            });
        }


// this shit has to be completely different.
//         function submit(signedHex) {
//             return $http.post(baseUrl, {
//                 hex: signedHex
//             }).then(function(res) {
//                 if (res.data.error) {
//                     if (res.data.error.indexOf("already spent") >= 0) {
//                         return $q.reject(new Error("Some inputs already spent, please try transaction again in a few minutes"));
//                     } else {
//                         return $q.reject(new Error(res.data.error));
//                     }
//                 }
//                 return res.data;
//             });
//         }

// this shit has to be completely different.
        function submit(signedHex) {
        	console.debug("raw signed tx " + signedHex);
            return $http.post(baseUrl + '/tx/send', {
                rawtx: signedHex
            }).then(function(res) {
                if (res.data.error) {
                	console.debug("tx error " + res.data.error);
                    if (res.data.error.indexOf("already spent") >= 0) {
                        return $q.reject(new Error("Some inputs already spent, please try transaction again in a few minutes"));
                    } else {
                        return $q.reject(new Error(res.data.error));
                    }
                }
                console.debug("tx good " + res.data);
                return res.data;
            });
        }

        return txUtil;
    }

})(window, window.angular);

(function(window, angular, BigNumber) {
    'use strict';

    angular.module('bitcoin')
        .directive('bcUnitSelector', bcUnitSelector);

    bcUnitSelector.$inject = ['$rootScope', 'COIN', 'Cookie'];

    var COOKIE_NAME = 'bitlox-denom';

    function bcUnitSelector($rootScope, COIN, Cookie) {
        return {
            scope: true,
            restrict: 'E',
            templateUrl: 'bitcoin/unit-selector.html',
            replace: true,
            link: function(scope) {
                var bitcoin = new BigNumber(COIN);
                var milly = bitcoin.dividedBy(1000);
                var bit = bitcoin.dividedBy(1000000);

                scope.options = {
                    BTC: bitcoin,
                    mBTC: milly,
                    bits: bit
                };

                scope.changeCurrency = function(denom, value) {
                    scope.current = value;
                };


                scope.$watch('current', function() {
                    if (scope.current) {
                        $rootScope.denomination = scope.current;
                        if (scope.current.equals(scope.options.BTC)) {
                            $rootScope.currency = 'BTC';
                        } else if (scope.current.equals(scope.options.mBTC)) {
                            $rootScope.currency = 'mBTC';
                        } else if (scope.current.equals(scope.options.bits)) {
                            $rootScope.currency = 'bits';
                        }
                        scope.currentDisplay = $rootScope.currency;
                        Cookie.set(COOKIE_NAME, $rootScope.currency);
                    }
                });

                var cookieVal = Cookie.get(COOKIE_NAME);
                if (cookieVal) {
                    scope.current = scope.options[cookieVal];
                } else {
                    scope.current = bitcoin;
                }

            }
        };
    }

})(window, window.angular, window.BigNumber);

(function(window, angular, BigNumber) {
    'use strict';

    angular.module('bitcoin')
        .directive('bcVal', bcVal);

    bcVal.$inject = ['$rootScope', '$filter'];

    function bcVal($rootScope, $filter) {
        return {
            restrict: 'A',
            scope: {
                bcVal: '=',
            },
            link: function(scope, elem) {
                var val = new BigNumber(parseInt(scope.bcVal, 10));

                scope.$watch('bcVal', function(v) {
                    if (v !== undefined) {
                        val = new BigNumber(parseInt(v, 10));
                        update();
                    }
                });

                $rootScope.$watch('denomination', function(d) {
                    if (d) {
                        update();
                    }
                });

                var filter = $filter('bcNumber');
                function update() {
                    var numStr = val.dividedBy($rootScope.denomination).toString();
                    numStr = filter(numStr);
                    elem.text(numStr + " " + $rootScope.currency);
                }
            }
        };
    }

})(window, window.angular, window.BigNumber);

(function(window, angular) {
    'use strict';

    angular.module('app.core')
        .config(config);

    config.$inject = ['$routeProvider'];

    function config() {
    }

})(window, window.angular);

(function(window, angular) {
    'use strict';

    angular.module('app.core')
        .directive('expertMode', expertMode);

    expertMode.$inject = ['$rootScope', 'Cookie'];

    var COOKIE_NAME = 'bitlox-expert';

    function expertMode($rootScope, Cookie) {
        return {
            scope: true,
            restrict: 'E',
            templateUrl: 'core/expert-mode.html',
            replace: true,
            link: function(scope) {

                scope.status = "Activate Expert Mode";
                scope.$watch('current', function() {
                    $rootScope.expertMode = scope.current;
                    scope.status = scope.current ? "Expert Mode Active" : "Activate Expert Mode";
                    Cookie.set(COOKIE_NAME, $rootScope.expertMode);
                });

                var cookieVal = Cookie.get(COOKIE_NAME);
                if (cookieVal) {
                    scope.current = cookieVal ? true : false;
                } else {
                    scope.current = false;
                }

            }
        };
    }

})(window, window.angular);

(function(window, angular) {
    'use strict';

    angular.module('app.core')
        .controller('HomeCtrl', HomeCtrl);

    HomeCtrl.$inject = ['$timeout', 'hidapi', 'Toast'];



    function HomeCtrl($timeout, hidapi, Toast) {
        var vm = this;

        var checkDevice = vm.checkDevice = function() {
            vm.openingDevice = true;
            hidapi.ping().then(function() {
                hidapi.uuid().then(function(uuid) {
                    vm.uuid = uuid;
                    vm.openingDevice = false;
                }, Toast.errorHandler);
            }, Toast.errorHandler);
        };

        checkDevice();

    }

})(window, window.angular);

(function(window, angular) {
    'use strict';

    angular.module('app.core')
        .controller('NavCtrl', NavCtrl);

    NavCtrl.$inject = [];

    function NavCtrl() {
    }

})(window, window.angular);

(function(window, angular) {
    'use strict';

    angular.module('app.core')
        .config(['$provide', function($provide) {
            // Fix sourcemaps
            // @url https://github.com/angular/angular.js/issues/5217#issuecomment-50993513
            $provide.decorator('$exceptionHandler', ['$delegate', function($delegate) {
                return function(exception, cause) {
                    $delegate(exception, cause);
                    setTimeout(function() {
                        throw exception;
                    });
                };
            }]);
       }]);

})(window, window.angular);

(function(window, angular) {
    'use strict';

    angular.module('app.core')
        .controller('StatusCtrl', StatusCtrl);

    StatusCtrl.$inject = ['hidapi', 'WalletStatus'];

    function StatusCtrl(hidapi, WalletStatus) {
        var vm = this;

        vm.bitlox = {
            connectAttempted: false,
            connected: true,
            status: "No Bitlox",
            alertClass: "danger"
        };

        vm.wallet = {
            status: "No Wallet",
            alertClass: "warning"
        };

        vm.refreshBitlox = function() {
            hidapi.ping();
        };

        hidapi.$scope.$watch('status', function(hidstatus) {
            switch(hidstatus) {
            case hidapi.STATUS_CONNECTED:
                vm.bitlox.connectAttempted = true;
                vm.bitlox.connected = true;
                vm.bitlox.status = "Bitlox connected";
                vm.bitlox.alertClass = "success";
                vm.bitlox.glyph = "glyphicon-ok";
                break;
            case hidapi.STATUS_DISCONNECTED:
                console.warn("DISCONNECTED");
                vm.bitlox.connected = false;
                vm.bitlox.status = "Bitlox disconnected!";
                vm.bitlox.alertClass = "danger";
                vm.bitlox.glyph = "glyphicon-remove";
                break;
            case hidapi.STATUS_WRITING:
                vm.bitlox.connectAttempted = true;
                vm.bitlox.connected = true;
                vm.bitlox.status = "Bitlox writing";
                vm.bitlox.alertClass = "info";
                vm.bitlox.glyph = "glyphicon-upload";
                break;
            case hidapi.STATUS_READING:
                vm.bitlox.connectAttempted = true;
                vm.bitlox.connected = true;
                vm.bitlox.status = "Bitlox reading";
                vm.bitlox.alertClass = "info";
                vm.bitlox.glyph = "glyphicon-download";
                break;
            default:
                vm.bitlox.connected = false;
                vm.bitlox.status = null;
            }
        });

        WalletStatus.$watch('status', function(walletstatus) {
            switch(walletstatus) {
            case WalletStatus.STATUS_LOADING:
                vm.wallet.status = "Loading wallet";
                vm.wallet.alertClass = "info";
                vm.wallet.glyph = "glyphicon-download";
                break;
            case WalletStatus.STATUS_LOADING_UNSPENT:
                vm.wallet.status = "Finding unspent outputs";
                vm.wallet.alertClass = "info";
                vm.wallet.glyph = "glyphicon-cloud-download";
                break;
            case WalletStatus.STATUS_LOADING_TRANSACTIONS:
                vm.wallet.status = "Finding transactions";
                vm.wallet.alertClass = "info";
                vm.wallet.glyph = "glyphicon-cloud-download";
                break;
            case WalletStatus.STATUS_SENDING:
                vm.wallet.status = "Wallet sending";
                vm.wallet.alertClass = "info";
                vm.wallet.glyph = "glyphicon-log-out";
                break;
            case WalletStatus.STATUS_SIGNING:
                vm.wallet.status = "Wallet signing";
                vm.wallet.alertClass = "info";
                vm.wallet.glyph = "glyphicon-pencil";
                break;
            default:
                vm.wallet.status = null;
            }
        });


    }

})(window, window.angular);

(function(window, angular) {
    'use strict';

    angular.module('hid')
        .constant('VENDOR_ID', 0x03EB)
        .constant('PRODUCT_ID', 0x204F);

})(window, window.angular);

(function(window, angular) {
    'use strict';

    angular.module('hid')
        .constant('hidCommands', {
            button_ack: '2323005100000000',
            format_storage: '2323000D000000220A204242424242424242424242424242424242424242424242424242424242424242',

            list_wallets:  '2323001000000000',

            scan_wallet:   '2323006100000000',

            // prefixes for commands that take in a variable amount of
            // data, a content size and the payload data is appended
            newWalletPrefix: '23230004',
            restoreWalletPrefix: '23230018',
            renameWalletPrefix: '2323000F',
            signTxPrefix:    '23230065',
            signMessagePrefix: '23230070',
            otpPrefix: '23230057',
            qrPrefix: '23230080',
            setChangePrefix: '23230066',

            // these just get one byte of hex for the wallet number
            // added to them
            deleteWalletPrefix: '232300160000000208',
            loadWalletPrefix: '2323000B0000000208',

            // just a ping
            ping: '23230000000000070A0548656C6C6F',

        });

})(window, window.angular);

(function(window, angular, async, ProtoBuf, ByteBuffer) {
    'use strict';

    angular.module('hid')
        .service('hidapi', HidAPI);

    HidAPI.$inject = [
        '$q', '$timeout', '$interval', '$rootScope',
        'Toast', 'hexUtil', 'txUtil', 'messageUtil',
        'VENDOR_ID', 'PRODUCT_ID', 'RECEIVE_CHAIN', 'CHANGE_CHAIN',
        'hidCommands'
    ];

    var PULSE_INTERVAL = (30 * 1000);

    function HidAPI($q, $timeout, $interval, $rootScope,
                    Toast, hexUtil, txUtil, messageUtil,
                    VENDOR_ID, PRODUCT_ID, RECEIVE_CHAIN, CHANGE_CHAIN,
                    hidCommands) {
        this.VENDOR_ID = VENDOR_ID;
        this.PRODUCT_ID = PRODUCT_ID;
        this.RECEIVE_CHAIN = RECEIVE_CHAIN;
        this.CHANGE_CHAIN = CHANGE_CHAIN;
        this.Toast = Toast;
        this._plugin = null;
        this.version = null;
        this.path = null;
        this._device = null;
        this._builder = null;

        this.$q = $q;
        this.$timeout = $timeout;
        this.$interval = $interval;

        this.commands = hidCommands;

        this.hexUtil = hexUtil;
        this.messageUtil = messageUtil;
        this.getTxHex = txUtil.getHex;

        this.$scope = $rootScope.$new();
        this.$scope.status = HidAPI.STATUS_DISCONNECTED;
    }

    HidAPI.TYPE_INITIALIZE         = HidAPI.prototype.TYPE_INITIALIZE = 'initialize';
    HidAPI.TYPE_PUBLIC_ADDRESS     = HidAPI.prototype.TYPE_PUBLIC_ADDRESS = 'public address';
    HidAPI.TYPE_ADDRESS_COUNT      = HidAPI.prototype.TYPE_ADDRESS_COUNT = 'address count';
    HidAPI.TYPE_WALLET_LIST        = HidAPI.prototype.TYPE_WALLET_LIST = 'wallet list';
    HidAPI.TYPE_PONG               = HidAPI.prototype.TYPE_PONG = 'pong';
    HidAPI.TYPE_SUCCESS            = HidAPI.prototype.TYPE_SUCCESS = 'success';
    HidAPI.TYPE_ERROR              = HidAPI.prototype.TYPE_ERROR = 'error';
    HidAPI.TYPE_UUID               = HidAPI.prototype.TYPE_UUID = 'uuid';
    HidAPI.TYPE_SIGNATURE          = HidAPI.prototype.TYPE_SIGNATURE = 'signature';
    HidAPI.TYPE_PLEASE_ACK         = HidAPI.prototype.TYPE_PLEASE_ACK = 'please ack';
    HidAPI.TYPE_PLEASE_OTP         = HidAPI.prototype.TYPE_PLEASE_OTP = 'please otp';
    HidAPI.TYPE_XPUB               = HidAPI.prototype.TYPE_XPUB = 'xpub';
    HidAPI.TYPE_SIGNATURE_RETURN   = HidAPI.prototype.TYPE_SIGNATURE_RETURN = 'signature return';
    HidAPI.TYPE_MESSAGE_SIGNATURE  = HidAPI.prototype.TYPE_MESSAGE_SIGNATURE = 'message signature';

    HidAPI.STATUS_DISCONNECTED     = HidAPI.prototype.STATUS_DISCONNECTED = "disconnected";
    HidAPI.STATUS_CONNECTED        = HidAPI.prototype.STATUS_CONNECTED = "connected";
    HidAPI.STATUS_READING          = HidAPI.prototype.STATUS_READING = "reading";
    HidAPI.STATUS_WRITING          = HidAPI.prototype.STATUS_WRITING = "writing";


    // function to get the plugin from the document element
    HidAPI.prototype.plugin = function() {
        if (this._plugin === null) {
            console.debug("plugin: device is null, finding on document");
            this._plugin = document.getElementById('hidapiPlugin');
        }
        console.debug("plugin: found", this._plugin);
        return this._plugin;
    };

    // Get the device. If we alreay have it, just return it.
    // Otherwise, do a hidraw scan and find, then open, the device
    HidAPI.prototype.device = function() {
        var hidapi = this;
        if (hidapi._device !== null) {
            return hidapi._device;
        }
        if (hidapi.pulse) {
            hidapi.$interval.cancel(hidapi.pulse);
        }
        // get the hid plugin
        console.debug("device: looking for plugin");
        var plugin = hidapi.plugin();
        if (plugin === null) {
            hidapi.close();
            return hidapi._device; // it's still null
        }
        console.debug("device: found plugin", plugin);
        // and list all of the hidraw devices that match our
        // vendor and product ids
        console.debug("device: looking for devices");
        var devices = plugin.hid_enumerate(hidapi.VENDOR_ID, hidapi.PRODUCT_ID);
        console.debug("device: found devices", devices);
        // if we do not find it, return null
        if (!devices.length) {
            hidapi.close();
            hidapi.Toast.error("No devices connected");
            return null;
        }
        // otherwise, get the path
        var path = hidapi.path = devices[0].path;
        // and open it
        console.debug("device: opening path", path);
        hidapi._device = hidapi.plugin().hid_open_path(path);
        console.debug("device: path opened", hidapi._device);
        // if the device is null still, there was an error opening the
        // path
        if (hidapi._device === null) {
            hidapi.close();
            hidapi.Toast.error("Error opening device");
            return null;
        }
        hidapi.$scope.status = hidapi.STATUS_CONNECTED;
        // set up the heartbeat interval if it does now exist
        if (!hidapi.pulse) {
            hidapi.pulse = hidapi.$interval(function() {
                // only do this if we are not already doing something
                if (!hidapi.doingCommand &&
                    hidapi.$scope.status !== hidapi.STATUS_READING &&
                    hidapi.$scope.status !== hidapi.STATUS_WRITING) {
                    console.debug("heartbeat");
                    hidapi.ping().catch(function() {
                        hidapi.close();
                    });
                }
            }, PULSE_INTERVAL);
        }
        // return the newly found device
        return hidapi._device;
    };

    HidAPI.prototype.protoBuilder = function() {
        if (this._builder === null) {
            var builder = ProtoBuf.loadProtoFile("proto/messages.proto");
            this._builder = builder.build();
        }
        return this._builder;
    };

    HidAPI.prototype.pluginDetect = function() {
        var plugin = navigator.plugins[name];
        if (typeof(plugin) !== "undefined") {
            var re = /([0-9.]+)\.dll/; // look for the version at the end of the filename, before dll
            // Get the filename
            var filename = plugin.filename;
            // Search for the version
            var fnd;
            fnd = re.exec(filename);
            if (fnd === null) { // no version found
                if (plugin.version) {
                    this.version = plugin.version;
                    return this.version;
                } else {
                    return true; // plugin installed, unknown version
                }
            } else {
                this.version = fnd[1];
                return this.version; // plugin installed, returning version
            }

        } else {
            console.error("Plugin missing");
            return null;
        }
    };

    HidAPI.prototype.chunkData = function(data, chunkSize) {
        if (chunkSize === undefined) {
            chunkSize = 2;
        }
        return data.match(new RegExp('.{1,' + chunkSize + '}', 'g'));
    };

    function pausecomp(milliseconds) {
        var start = new Date().getTime();
        for (var i = 0; i < 1e7; i++) {
            if ((new Date().getTime() - start) > milliseconds) {
                break;
            }
        }
    }

    HidAPI.prototype.write = function(data) {
        var hidapi = this;
        hidapi.$scope.status = hidapi.STATUS_WRITING;
        var deferred = this.$q.defer();
        this.$timeout(function() {
            // get the device
            var dev = hidapi.device();
            if (dev === null) {
                hidapi.close();
                return deferred.reject(new Error("No device to write to"));
            }
            // check remainder against 8 bytes and add 4 null bytes if we
            // have 0, 6, or 7 bytes of space left over
            var remainder = data.length % 16;
            if (remainder === 0 || remainder === 12 || remainder === 14) {
                data = '00000000' + data;
            }
            // split into 16 byte chunks
            var chunks = hidapi.chunkData(data, 32);
            // keep track of the total sent
            var totalSent = 0;
            for(var i = 0; i < chunks.length; i++) {
                var thisData = chunks[i];
                if (thisData.length) {
                    thisData = '00' + thisData;
                    // if this is the final chunk, append the terminator
                    if (i + 1 === chunks.length) {
                        thisData += '7E7E';
                    }
                    // write to the device
                    var txResult = dev.hid_write(thisData);
                    pausecomp(50);
                    // if we did not write anything, return 0 to fail the
                    // send
                    if (txResult <= 0) {
                        hidapi.close();
                        return deferred.reject(new Error("Write error"));
                    }
                    // add to the total sent
                    totalSent += txResult;
                }
            }
            return deferred.resolve(totalSent);
        });
        return deferred.promise.finally(function() {
            hidapi.$scope.status = hidapi.STATUS_CONNECTED;
        });
    };

    var trimBeef = new RegExp('^(DEAD|BEEF|ADBEEF|EFDEAD)(DEAD|BEEF)+(2323)');
    HidAPI.prototype.hidRead = function(size, timeout) {
        if (timeout === undefined) {
            timeout = 3000;
        }
        if (size === undefined) {
            size = 64;
        }
        var hidapi = this;
        var deferred = this.$q.defer();
        this.$timeout(function() {
            var result;
            try {
                result = hidapi.device().hid_read(size, timeout).replace(trimBeef, '$3');
                deferred.resolve(result);
            } catch (ex) {
                console.error(ex);
                return deferred.reject(ex);
            }
        });
        return deferred.promise;
    };

    var magic = '2323';
    var magicRegexp = new RegExp(magic);
    var magicRegexpEdge = new RegExp('BEEF(23){1,2}$');
    HidAPI.prototype.read = function(serialData, wait) {
        if (serialData === undefined) {
            serialData = '';
        }
        var hidapi = this;
        return this.hidRead().then(function(newData) {
            hidapi.$scope.status = hidapi.STATUS_READING;
            serialData = serialData + newData;
            if (magicRegexpEdge.test(serialData)) {
                return hidapi.read(serialData, wait);
            }
            if (magicRegexp.test(serialData)) {
                // find the position of the magic string
                var headerPosition = serialData.search(magic);
                // if the header is close enough to the end that the
                // command and content length could be cut off, go ahead
                // and get more data
                if (headerPosition >= (serialData.length - (64 - 48))) {
                    return hidapi.read(serialData, wait);
                }
                // command is the 2 bytes after the magic
                var command = serialData.substring(headerPosition + 4, headerPosition + 8);
                // payload size is 4 bytes after command
                var payloadSize = serialData.substring(headerPosition + 8, headerPosition + 16);
                // parse the hex number to decimal
                var decPayloadSize = parseInt(payloadSize, 16);
                // if the content length is longer than the rest of the
                // data, go get some more
                if ((headerPosition + 16 + (2 * decPayloadSize)) > serialData.length) {
                    return hidapi.read(serialData, wait);
                }
                // the payload will start after 8 bytes
                var payload = serialData.substring(headerPosition + 16, headerPosition + 16 + (2 * (decPayloadSize)));
                return hidapi.processResults(command, payloadSize, payload);
            } else if (!wait && serialData === "") { //If nothing is detected, close down port
                console.warn("Device unplugged");
                hidapi.close();
                return null;
            } else {
                return null;
            }
        }).finally(function() {
            hidapi.$scope.status = hidapi.STATUS_CONNECTED;
        });
    };

    HidAPI.prototype.processResults = function(command, length, payload) {
        var Device = this.protoBuilder();
        command = command.substring(2, 4);
        var data = {
            type: null,
            payload: {}
        };

        switch (command) {
        case "3A": // initialize
            data.type = HidAPI.TYPE_INITIALIZE;
            break;
        case "30": // public address
            data.type = HidAPI.TYPE_PUBLIC_ADDRESS;
            data.payload.ecdsa = payload.substring(8, 74);
            data.payload.ripe160of2 = payload.substring(78, 118);
            break;
        case "31": // number of addresses in loaded wallet
            data.type = HidAPI.TYPE_ADDRESS_COUNT;
            data.payload.count = payload.substring(2, 4);
            break;
        case "32": // Wallet list
            data.type = HidAPI.TYPE_WALLET_LIST;
            data.payload.wallets = Device.Wallets.decodeHex(payload).wallet_info;
            break;
        case "33": // Ping response
            data.type = HidAPI.TYPE_PONG;
            data.payload = Device.PingResponse.decodeHex(payload);
            break;
        case "34": // success
            data.type = HidAPI.TYPE_SUCCESS;
            break;
        case "35": // general purpose error/cancel
            data.type = HidAPI.TYPE_ERROR;
            var hidErr = Device.Failure.decodeHex(payload);
            data.payload = new Error(hidErr.error_message.toString('utf8'));
            data.payload.code = parseInt(hidErr.error_code, 10);
            break;
        case "36": // device uuid return
            data.type = HidAPI.TYPE_UUID;
            data.payload = Device.DeviceUUID.decodeHex(payload);
            break;
        case "39": // signature return [original]
            data.type = HidAPI.TYPE_SIGNATURE;
            data.payload = Device.Signature.decodeHex(payload);
            break;
        case "50": // please ack
            data.type = HidAPI.TYPE_PLEASE_ACK;
            break;
        case "56": // please otp
            data.type = HidAPI.TYPE_PLEASE_OTP;
            break;
        case "62": // parse & insert xpub from current wallet //RETURN from scan wallet
            data.type = HidAPI.TYPE_XPUB;
            data.payload = Device.CurrentWalletXPUB.decodeHex(payload);
            break;
        case "64": // signature return
            data.type = HidAPI.TYPE_SIGNATURE_RETURN;
            var signedScripts = [];
            var sigs = Device.SignatureComplete.decodeHex(payload).signature_complete_data;
            sigs.forEach(function(sig) {
                var sigHex = sig.signature_data_complete.toString('hex');
                var sigSize = parseInt(sigHex.slice(0, 2), 16);
                var sigChars = 2 + (sigSize * 2);
                sigHex = sigHex.slice(0, sigChars);
                signedScripts.push(sigHex);
            });
            data.payload = {
                signedScripts: signedScripts
            };
            break;
        case "71": // message signing return
            data.type = HidAPI.TYPE_MESSAGE_SIGNATURE;
            var protoSig = Device.SignatureMessage.decodeHex(payload).signature_data_complete;
            data.payload = this.hexUtil.hexToBytes(protoSig.toString('hex'));
            break;
        default:
            data.type = HidAPI.TYPE_ERROR;
            data.payload = new Error("Unknown command received: 00" + command);
            data.payload.code = 1;
            break;
        }
        return data;
    };

    HidAPI.prototype.close = function() {
        var hidapi = this;
        hidapi.$scope.status = null;
        hidapi._device = null;
        hidapi._plugin = null;
        console.debug("closed");
        return hidapi.$timeout(function() {
            console.debug("settng to disconnected");
            hidapi.$scope.status = hidapi.STATUS_DISCONNECTED;
        });
    };

    var readTimeout = 10;
    var counterMax = (120 * 1000) / readTimeout; // appx 2 minutes timeout

    HidAPI.prototype._doCommand = function(command, expectedType) {
        var hidapi = this;
        hidapi.doingCommand = true;
        return hidapi.write(command).then(function(written) {
            if (written === 0) {
                return hidapi.close().then(function() {
                    return hidapi.$q.reject(new Error("No data written"));
                });
            } else if (written === -1) {
                return hidapi.close().then(function() {
                    return hidapi.$q.reject(new Error("Write error"));
                });
            }
            var counter = 0;
            var doRead = function() {
                return hidapi.read('', 'wait please').then(function(data) {
                    counter += 1;
                    if (data === null) {
                        if (counter === counterMax) { // two minutes... ish
                            return hidapi.close().then(function() {
                                return hidapi.$q.reject(new Error("Command response timeout"));
                            });
                        }
                        return hidapi.$timeout(doRead, readTimeout);
                    } else if (data.type === HidAPI.TYPE_ERROR) {
                        hidapi.doingCommand = false;
                        return hidapi.$q.reject(data.payload);
                    } else if (data.type === HidAPI.TYPE_PLEASE_ACK) {
                        return hidapi._doCommand(hidapi.commands.button_ack, expectedType);
                    } else if (expectedType) {
                        if (data.type === expectedType) {
                            // we got what we wanted, return it
                            hidapi.doingCommand = false;
                            return data;
                        }
                        return hidapi.$timeout(doRead, readTimeout);
                    } else {
                        hidapi.doingCommand = false;
                        return data;
                    }
                });
            };
            return hidapi.$timeout(function(){})
                .then(doRead);
        }, function(err) {
            return hidapi.close().then(function() {
                return hidapi.$q.reject(err);
            });
        });
    };

    HidAPI.prototype.makeCommand = function(prefix, protoBuf) {
        var tmpBuf = protoBuf.encode();
        var messageHex = tmpBuf.toString('hex');
        var txSizeHex = (messageHex.length / 2).toString(16);
        while (txSizeHex.length < 8) {
            txSizeHex = "0" + txSizeHex;
        }
        return prefix + txSizeHex + messageHex;
    };

    // commands to be called from outside this file

    HidAPI.prototype.ping = function() {
        return this._doCommand(this.commands.ping, this.TYPE_PONG);
    };

    HidAPI.prototype.listWallets = function() {
        return this._doCommand(this.commands.list_wallets, this.TYPE_WALLET_LIST);
    };

    HidAPI.prototype.getWalletCommand = function(type, walletNumber) {
        var cmd = this.commands[type + 'WalletPrefix'];
        var numHex = parseInt(walletNumber, 10).toString(16);
        if (numHex.length === 1) {
            numHex = '0' + numHex;
        }
        return cmd + numHex;
    };

    HidAPI.prototype.loadWallet = function(walletNumber) {
        var cmd = this.getWalletCommand('load', walletNumber);
        return this._doCommand(cmd, this.TYPE_SUCCESS);
    };

    HidAPI.prototype.deleteWallet = function(walletNumber) {
        var cmd = this.getWalletCommand('delete', walletNumber);
        return this._doCommand(cmd, this.TYPE_PLEASE_OTP);
    };

    HidAPI.prototype.format = function() {
        return this._doCommand(this.commands.format_storage, this.TYPE_PLEASE_OTP);
    };

    HidAPI.prototype.scanWallet = function() {
        return this._doCommand(this.commands.scan_wallet, this.TYPE_XPUB);
    };

    HidAPI.prototype.newWallet = function(walletNumber, options) {
        var Device = this.protoBuilder();
        // look through the options and fill in the data for the proto
        // buffer
        var protoData = {};
        if (options.isSecure) {
            var pass = new ByteBuffer();
            pass.writeUint8(0x74);
            pass.flip();
            protoData.password = pass;
        } else {
            protoData.password = null;
        }
        protoData.is_hidden = options.isHidden ? true : false;
        // get the name and put it in a byte buffer
        var name =  "Wallet " + walletNumber;
        if (options.name && 'string' === typeof name) {
            name = options.name;
        }
        var nameHex = this.hexUtil.toPaddedHex(name, 39) + '00';
        var nameBuf = this.hexUtil.hexToByteBuffer(nameHex);
        nameBuf.flip();
        protoData.wallet_name = nameBuf;
        // make a proto buffer for the data, generate a command and
        // send it off
        var newWalletMessage = new Device.NewWallet(protoData);
        // if isRestore === true in the option, use the restor command
        // instead (everything else is the same)
        var cmdPrefix = (options.isRestore === true) ?
            this.commands.restoreWalletPrefix : this.commands.newWalletPrefix;
        // now make a full command using the proto buffer
        var cmd = this.makeCommand(cmdPrefix, newWalletMessage);
        return this._doCommand(cmd);
    };

    // tx is from bitcoin/transaction.factory.js
    HidAPI.prototype.signTransaction = function(tx) {
        var hidapi = this;
        var deferred = this.$q.defer();
        var Device = this.protoBuilder();
        var addrHandlers = [];
        var inputData = [];
        async.eachSeries(tx.inputs, function(input, next) {
            // make a handler
            var handler = hidapi.makeAddressHandler(input.chain, input.chainIndex);
            // add to the handler array
            addrHandlers.push(handler);
            // get the hex of the full input transaction
            hidapi.getTxHex(input.tx_hash_big_endian).then(function(hex) {
                var thisInputData = '01';
                thisInputData += hidapi.hexUtil.intToBigEndianString(input.tx_output_n, 4);
                thisInputData += hex;
                inputData.push(thisInputData);
                return next();
            }, next);
        }, function(err) {
            if (err) {
                return deferred.reject(err);
            }
            var dataString = '00';
            dataString += tx.unsignedHex;
            // hash type
            dataString += '01000000';
            dataString = inputData.join('') + dataString;

            var dataBuf = hidapi.hexUtil.hexToByteBuffer(dataString);
            dataBuf.flip();
            var txMessage = new Device.SignTransactionExtended({
                address_handle_extended: addrHandlers,
                transaction_data: dataBuf
            });
            var cmd = hidapi.makeCommand(hidapi.commands.signTxPrefix, txMessage);
            hidapi._doCommand(cmd, hidapi.TYPE_SIGNATURE_RETURN).then(deferred.resolve, deferred.reject);
        });
        return deferred.promise;
    };

    var sigHeaders = [
        "-----BEGIN BITCOIN SIGNED MESSAGE-----",
        "-----BEGIN SIGNATURE-----",
        "-----END BITCOIN SIGNED MESSAGE-----"
    ];

    HidAPI.prototype.signMessage = function(address, chain, chainIndex, message) {
        var hidapi = this;
        var Device = hidapi.protoBuilder();
        var messageBytes = hidapi.messageUtil.makeMessageBytes(message);
        var messageHex = hidapi.hexUtil.bytesToHex(messageBytes);
        var msgBuf = hidapi.hexUtil.hexToByteBuffer(messageHex);
        msgBuf.flip();
        console.debug("signMessage: ", message, "->", messageBytes, "->", messageHex);
        var protoMsg = new Device.SignMessage({
            address_handle_extended: hidapi.makeAddressHandler(chain, chainIndex),
            message_data: msgBuf
        });
        var cmd = hidapi.makeCommand(hidapi.commands.signMessagePrefix, protoMsg);
        return hidapi._doCommand(cmd, hidapi.TYPE_MESSAGE_SIGNATURE).then(function(data) {
            var sig = hidapi.messageUtil.processSignature(message, address, data.payload);
            if (!sig) {
                return hidapi.$q.reject(new Error("Invalid signature returned"));
            }
            return ([
                sigHeaders[0],
                message,
                sigHeaders[1],
                address,
                sig,
                sigHeaders[2]
            ]).join('\n');
        });
    };

    HidAPI.prototype.makeAddressHandler = function(chain, chainIndex) {
        var handler = {
            address_handle_root: 0,
            address_handle_chain: chain,
            address_handle_index: chainIndex
        };

        if (chain === 'receive') {
            handler.address_handle_chain = this.RECEIVE_CHAIN;
        } else if (chain === 'change') {
            handler.address_handle_chain = this.CHANGE_CHAIN;
        } else {
            throw new Error("Invalid chain on input: " + chain);
        }

        return handler;
    };

    HidAPI.prototype.renameWallet = function(name) {
        var Device = this.protoBuilder();
        var nameHex = this.hexUtil.toPaddedHex(name, 39) + '00';
        console.debug(name, "->", nameHex);
        var nameBuf = this.hexUtil.hexToByteBuffer(nameHex);
        nameBuf.flip();
        // make a proto buffer for the data, generate a command and
        // send it off
        var newWalletMessage = new Device.ChangeWalletName({
            wallet_name: nameBuf
        });
        var cmd = this.makeCommand(this.commands.renameWalletPrefix, newWalletMessage);
        return this._doCommand(cmd);
    };

    HidAPI.prototype.sendOTP = function(otp) {
        var Device = this.protoBuilder();
        var otpMessage = new Device.OtpAck({
            otp: otp,
        });
        var cmd = this.makeCommand(this.commands.otpPrefix, otpMessage);
        return this._doCommand(cmd);
    };

    HidAPI.prototype.showQr = function(chainIndex) {
        var Device = this.protoBuilder();
        var otpMessage = new Device.DisplayAddressAsQR({
            address_handle_index: chainIndex,
        });
        var cmd = this.makeCommand(this.commands.qrPrefix, otpMessage);
        var hidapi = this;
        return hidapi.write(cmd).then(function(written) {
            if (written === 0) {
                return hidapi.$q.reject(new Error("No data written"));
            } else if (written === -1) {
                return hidapi.$q.reject(new Error("Write error"));
            }
        });
    };

    HidAPI.prototype.setChangeAddress = function(chainIndex) {   
//     	console.debug("in setChangeAddress");
        var Device = this.protoBuilder();
        var otpMessage = new Device.SetChangeAddressIndex({
            address_handle_index: chainIndex,
        });
        var cmd = this.makeCommand(this.commands.setChangePrefix, otpMessage);
        var hidapi = this;
        return hidapi.write(cmd).then(function(written) {
            if (written === 0) {
                return hidapi.$q.reject(new Error("No data written"));
            } else if (written === -1) {
                return hidapi.$q.reject(new Error("Write error"));
            }
        });
    };



    HidAPI.prototype.flash = function() {
        var hidapi = this;
        var deferred = hidapi.$q.defer();
        hidapi.$timeout(function() {
            hidapi.device().hid_send_feature_report('01');
            deferred.resolve();
        });
        return deferred.promise;
    };

})(window, window.angular, window.async, window.dcodeIO.ProtoBuf, window.dcodeIO.ByteBuffer);

(function(window, angular) {
    'use strict';

    angular.module('hid')
        .directive('hidPlugin', plugin);

    plugin.$inject = ['$compile'];

    function plugin($compile) {
        return {
            restrict: 'E',
            link: function(scope, elm) {
                var plugintmpl = '<object height="1" id="hidapiPlugin" ' +
                    'type="application/x-hidapibrowserplugin" width="1">' +
                    '<param name="onload" value="pluginLoaded">' +
                    '</object>';
                var b = $compile(plugintmpl)(scope);
                elm.replaceWith(b);
            }
        };

    }

})(window, window.angular);

(function(window, angular) {
    'use strict';

    angular.module('app.util')
        .factory('Cookie', CookieFactory);

    CookieFactory.$inject = ['ipCookie'];

    var DEFAULT_COOKIE_OPTIONS = {path: '/'};

    function CookieFactory(ipCookie) {
        var Cookie = {};

        Cookie.set = function(key, value, options) {
            options = makeOptions(options);
            return ipCookie(key, value, options);
        };

        Cookie.get = function(key) {
            return ipCookie(key);
        };

        Cookie.remove = function(key, options) {
            options = makeOptions(options);
            return ipCookie.remove(key, options);
        };

        function makeOptions(options) {
            if (!options || 'object' !== typeof options) {
                options = {};
            }
            return angular.extend(DEFAULT_COOKIE_OPTIONS, options);
        }

        return Cookie;
    }

})(window, window.angular);

(function(window, angular, Crypto, ByteBuffer, BigInteger) {
    'use strict';

    angular.module('app.util')
        .factory('hexUtil', HexFactory);

    HexFactory.$inject = [];

    function HexFactory() {
        return {
            // string to hex methods
            utf8ToHex: utf8ToHex,
            // alias this
            toHex: utf8ToHex,
            toPaddedHex: strToPaddedHex,
            // hex manipulation/conversion methods
            padBytes: padBytes,
            hexToByteBuffer: hexToByteBuffer,
            // hex values
            intToBigEndianValue: intToBigEndianValue,
            intToBigEndianString: intToBigEndianString,
            // byte to hex methods
            bytesToHex: bytesToHex,
            hexToBytes: hexToBytes,
            // make a big endian string small endian
            makeStringSmallEndian: makeStringSmallEndian
        };

        function strToPaddedHex(str, targetBytes, padByte) {
            return padBytes(utf8ToHex(str), targetBytes, padByte);
        }

        function utf8ToHex(str) {
		    return bytesToHex(Crypto.charenc.UTF8.stringToBytes(str));
        }

        function bytesToHex(bytes) {
		    return Crypto.util.bytesToHex(bytes);
        }

        function hexToBytes(hex) {
            return Crypto.util.hexToBytes(hex);
        }

        function padBytes(hex, targetBytes, padByte) {
            if (padByte === undefined) {
                padByte = '20';
            }
            if (padByte.length !== 2) {
                throw new Error("Invalid padding byte " + padByte);
            }
            if (isNaN(targetBytes)) {
                throw new Error("Invalid target bytes " + padByte);
            }
            while (hex.length < (targetBytes * 2)) {
                hex += padByte;
            }
            return hex;
        }

        function hexToByteBuffer(hex) {
            console.debug("converting", hex, "to byte buffer");
            var buf = new ByteBuffer();
            var hexLen = hex.length;
            for(var i = 0; i < hexLen; i+=2) {
                var value = hex.substring(i, i + 2);
                var result = parseInt(value, 16);
                buf.writeUint8(result);
            }
            return buf;
        }

        function intToBigEndianValue(n, minBytes) {
            n = BigInteger.valueOf(n);
            var value = n.toByteArrayUnsigned().reverse();
            while (value.length < minBytes) {
                value.push(0);
            }
            return value;
        }

        function intToBigEndianString(n, minBytes) {
            return bytesToHex(intToBigEndianValue(n, minBytes));
        }

        function makeStringSmallEndian(str) {
            var smallEndian = '';
            for (var i = (str.length - 2); i >= 0; i -= 2) {
                var byteChars = str.slice(i, i + 2);
                smallEndian += byteChars;
            }
            return smallEndian;
        }
    }

})(window, window.angular, window.Crypto, window.dcodeIO.ByteBuffer, window.BigInteger);

(function(window, angular) {
    'use strict';

    angular.module('app.util')
        .config(ToastConfig)
        .factory('Toast', ToastFactory);

    ToastConfig.$inject = ['ngToastProvider'];

    function ToastConfig(ngToast) {
        ngToast.configure({
            verticalPosition: 'bottom',
            horizontalPosition: 'center',
            animation: 'fade'
        });
    }

    ToastFactory.$inject = ['ngToast'];

    function ToastFactory(ngToast) {

        var Toast = function(){};

        var show = Toast.prototype.show = function(params) {
            ngToast.create(params);
        };

        Toast.prototype.clear = function(toast) {
            ngToast.dismiss(toast);
        };

        Toast.prototype.info = function(message) {
            this.show({
                content: message,
                className: 'info'
            });
        };

        Toast.prototype.error = function(message) {
            this.show({
                content: message,
                className: 'danger'
            });
        };

        Toast.prototype.errorHandler = function(err) {
            // this function is unbound, do not use 'this'
            show({
                content: err.message || err,
                className: 'danger'
            });
        };

        Toast.prototype.success = function(message) {
            this.show({
                content: message,
                className: 'success'
            });
        };

        Toast.prototype.warning = function(message) {
            this.show({
                content: message,
                className: 'warning'
            });
        };

        return new Toast();
    }

})(window, window.angular);

(function(window, angular) {
    'use strict';

    angular.module('app.wallet')
        .directive('walletCreate', walletCreate);

    walletCreate.$inject = ['Wallet', 'Toast', 'BIP39WordList'];

    function walletCreate(Wallet, Toast, wordlist) {
        return {
            scope: {
                availableNumbers: '=',
                onFinish: '&',
            },
            templateUrl: 'wallet/create.html',
            link: function(scope) {

                reset();

                scope.createWallet = function() {
                    scope.creatingWallet = true;
                    Wallet.create(scope.newWallet.number, scope.newWallet).then(function() {
                        reset();
                        return scope.onFinish();
                    }, Toast.errorHandler).finally(function() {
                        scope.creatingWallet = false;
                    });
                };

                // wallets is on the parent scope, which this inherits
                scope.$watchCollection('availableNumbers', function(available) {
                    if (available && available.length) {
                        // also set some default values for that form
                        scope.newWallet.name = "Wallet " + available[0];
                        scope.newWallet.number = available[0];
                    }
                });

                scope.updateWordNumbers = function() {
                    if (!scope.userWords) {
                        return;
                    }
                    var words = scope.userWords.split(/\s+/);
                    var numbers = [];
                    for (var i = 0; i < words.length; i++) {
                        var word = words[i];
                        var wordIndex = wordlist.indexOf(word);
                        if (wordIndex < 0) {
                            numbers[i] = "INVALID WORD";
                        } else {
                            numbers[i] = wordIndex;
                        }
                    }
                    scope.wordIndexes = numbers;
                };

                function reset() {
                    scope.newWallet = {
                        name: "Wallet",
                        number: 0,
                        isSecure: true,
                        isHidden: false,
                        isRestore: false,
                    };
                }


            }
        };
    }

})(window, window.angular);

(function(window, angular) {
    'use strict';

    angular.module('app.wallet')
        .directive('walletInfo', walletInfo);

    walletInfo.$inject = ['Toast'];

    function walletInfo(Toast) {
        return {
            scope: {
                wallet: '=',
                onDelete: '&',
                expertMode: '=',
            },
            templateUrl: 'wallet/info.html',
            link: function(scope) {
                scope.refreshBalance = function() {
                    scope.refreshingBalance = true;
                    scope.wallet.updateBalance().catch(Toast.errorHandler)
                        .finally(function() {
                            scope.refreshingBalance = false;
                        });
                };

                scope.refreshTransactions = function() {
                    scope.refreshingTransactions = true;
                    scope.wallet.loadTransactions().catch(Toast.errorHandler)
                        .finally(function() {
                            scope.refreshingTransactions = false;
                        });
                };

                scope.$watchCollection('wallet', function(v) {
                    if (v && v.balance !== undefined) {
                        scope.wallet.balance = v.balance;
                    }
                });
            }
        };
    }

})(window, window.angular);

(function(window, angular) {
    'use strict';

    angular.module('app.wallet')
        .factory('WalletStatus', WalletStatusFactory);

    WalletStatusFactory.$inject = ['$rootScope'];

    function WalletStatusFactory($rootScope) {

        var $scope = $rootScope.$new();

        $scope.STATUS_LOADING_UNSPENT = "loading unspent";
        $scope.STATUS_LOADING_TRANSACTIONS = "loading transactions";
        $scope.STATUS_LOADING = "loading";
        $scope.STATUS_SENDING = "sending";
        $scope.STATUS_SIGNING = "signing";

        return $scope;

    }

})(window, window.angular);

(function(window, angular) {
    'use strict';

    angular.module('app.wallet')
        .directive('txInfoLink', txInfoLink);

    txInfoLink.$inject = [];

	var baseUrlroot = 'https://bitlox.io';

    function txInfoLink() {
        return {
            restrict: 'E',
//             template: '<a ng-href="https://blockchain.info/search/{{txid}}" target="_blank">{{display}}</a>',
            template: '<a ng-href="'+ baseUrlroot +'/tx/{{txid}}" target="_blank">{{display}}</a>',
            link: function(scope, elem, attrs) {
                var txid = scope.txid = attrs.txid;
                scope.display = txid.slice(0, 8) + '...' + txid.slice(txid.length - 9, txid.length - 1);
            }
        };
    }

})(window, window.angular);

(function(window, angular) {
    'use strict';

    angular.module('app.wallet')
        .constant('MAX_WALLETS', 50);

})(window, window.angular);

(function(window, angular) {
    'use strict';

    angular.module('app.wallet')
        .controller('WalletCtrl', WalletCtrl);

    WalletCtrl.$inject = ['$timeout', 'MAX_WALLETS', 'Wallet', 'Toast', 'hidapi'];

    function WalletCtrl($timeout, MAX_WALLETS, Wallet, Toast, hidapi) {
        var vm = this;

        vm.readWallets = function() {
            vm.readingWallets = true;
            return Wallet.list()
                .then(function(wallets) {
                    vm.wallets = wallets;
                    vm.openWallet = null;
                    refreshAvailableNumbers(wallets);
                }, Toast.errorHandler)
                .finally(function() {
                    vm.readingWallets = false;
                });
        };

        vm.loadWallet = function(wallet) {
            vm.openWallet = null;
            vm.loadingXpub = true;
            console.debug("loading wallet", wallet.number);
            vm.openingWallet = wallet.number;
            wallet.open()
                .then(function() {
                    vm.openWallet = wallet;
                }, Toast.errorHandler, function(status) {
                    console.debug("open notify", status);
                    if (status === Wallet.NOTIFY_XPUB_LOADED) {
                        vm.loadingXpub = false;
                    }
                })
                .finally(function() {
                    console.debug("done loading wallet", wallet.number);
                    vm.openingWallet = -99;
                });
        };

        vm.refreshBalance = function() {
            vm.refreshingBalance = true;
            vm.openWallet.updateBalance().catch(Toast.errorHandler)
                .finally(function() {
                    vm.refreshingBalance = false;
                });
        };

        vm.directOpenNumber = 0;
        vm.directLoad = function() {
            var wallet;
            vm.wallets.forEach(function(w) {
                if (w.number === vm.directOpenNumber) {
                    wallet = w;
                }
            });
            if (!wallet) {
                wallet = new Wallet({
                    wallet_number: vm.directOpenNumber,
                    version: 4,
                    wallet_name: "HIDDEN",
                    wallet_uuid: "HIDDEN",
                });
            }
            vm.loadWallet(wallet);
        };

        vm.prepForFlash = function() {
            vm.flashing = true;
            hidapi.flash().catch(Toast.errorHandler)
                .finally(function() {
                    vm.flashing = false;
                });
        };



        reset();

        function refreshAvailableNumbers(wallets) {
            if (!wallets) {
                return;
            }
            // assemble array of wallet numbers
            var available = [];
            for(var i = 0; i < (MAX_WALLETS + 1); i++) {
                available.push(i);
            }
            // now loop through the wallets and remove existing
            // numbers
            wallets.forEach(function(wallet) {
                available.splice(available.indexOf(wallet.number), 1);
            });
            // set to the vm for the new wallet form
            vm.availableWalletNumbers = available;
        }

        function reset() {
            // status variables
            vm.readingWallets = true;
            vm.openingWallet = -99;
            vm.scanningWallet = false;
            vm.creatingWallet = false;
            vm.refreshingBalance = false;
            vm.openWallet = null;
            // read after a timeout, so angular does not hang and show
            // garbage while the browser is locked form readin the device
            $timeout(vm.readWallets.bind(vm), 100);
        }

    }

})(window, window.angular);

(function(window, angular, async) {
    'use strict';

    angular.module('app.wallet')
        .factory('Wallet', WalletFactory);

    WalletFactory.$inject = [
        '$q', '$timeout',
        'WalletStatus',
        'hidapi', 'BIP32', 'Transaction', 'addressInfo', 'MIN_OUTPUT', 'bcMath'];

    function WalletFactory(
        $q, $timeout,
        WalletStatus,
        hidapi, BIP32, Transaction, addressInfo, MIN_OUTPUT, bcMath) {

        var Wallet = function(data) {
            this.number = data.wallet_number;
            this.version = data.version;
            this._name = data.wallet_name;
            this._uuid = data.wallet_uuid;
            this.addresses = {
                receive: {},
                change: {}
            };
            this.balance = 0;
            this.unspent = [];
            this.transactions = [];
        };

        Wallet.NOTIFY_XPUB_LOADED = 'xpub loaded';

        Object.defineProperty(Wallet.prototype, 'name', {
            get: function() {
                if (!this._name || !this._name.toString) {
                    return "";
                }
                return this._name.toString("utf8");
            }
        });

        Object.defineProperty(Wallet.prototype, 'uuid', {
            get: function() {
                if (!this._uuid || !this._uuid.toString) {
                    return "";
                }
                return this._uuid.toString("utf8");
            }
        });

        Object.defineProperty(Wallet.prototype, 'isSecure', {
            get: function() {
                return this.version === 3;
            }
        });

        Object.defineProperty(Wallet.prototype, 'isHidden', {
            get: function() {
                return this.version === 4;
            }
        });

        Wallet.list = function() {
            return hidapi.listWallets().then(function(res) {
                var wallets = [];
                res.payload.wallets.forEach(function(data) {
                    wallets.push(new Wallet(data));
                });
                return wallets;
            });
        };

        Wallet.create = function(walletNumber, options) {
            return hidapi.newWallet(walletNumber, options);
        };

        // scan the currently open wallet and get the bip32 source key
        // from the data
        Wallet.getBip32 = function(wallet) {
            return hidapi.scanWallet().then(function(data) {
                var bip32;
                try {
                    bip32 = new BIP32(data.payload.xpub);
                } catch(ex) {
                    console.error(ex);
                    return $q.reject(ex);
                }
                wallet.xpub = data.payload.xpub;
                wallet.bip32 = bip32;
                // now that we have addresses, update the balance for
                // the wallet
                return wallet.updateBalance();
            });
        };

        Wallet.prototype.clearSpent = function(inputs) {
            var wallet = this;
            wallet.balance = 0;
            wallet.unspent = [];
            inputs.forEach(function(input) {
                var addrType = input.chain;
                var txid = input.tx_hash_big_endian;
                var addresses = wallet.addresses[addrType];
                Object.keys(addresses).forEach(function(address) {
                    var addrData = addresses[address];
                    var newUnspent = [];
                    addrData.unspent.forEach(function(output) {
                        if (txid !== output.tx_hash_big_endian) {
                            newUnspent.push(output);
                        }
                    });
                    addrData.unspent = newUnspent;
                });
                wallet.recalculateBalance(addrType);
            });
            // then also do a balance update after a timeout,
            // so we get the data we actually need for the
            // unspent outputs we have
            $timeout(function() {
                wallet.updatingBalance = true;
                wallet.updateBalance();
                wallet.loadTransactions();
            }, 5000);
        };

        // add up the unspent outputs on each input
        Wallet.prototype.recalculateBalance = function(addrType) {
            var wallet = this;
            var addresses = wallet.addresses[addrType];
            Object.keys(addresses).forEach(function(address) {
                var addrData = addresses[address];
                wallet.unconfirmedBalance += addrData.unconfirmedBalance;
                wallet.balance += addrData.balance;
            });
        };

        Wallet.prototype.getAllAddresses = function() {
            var wallet = this;
            var deferred = $q.defer();
            WalletStatus.status = WalletStatus.STATUS_LOADING_UNSPENT;
            async.each([
                "receive",
                "change"
            ], function(addrType, done) {
                var hasAll = false;
                var index = 0;
                console.debug("getting", addrType, "addresses");
                async.until(function() {
                    return hasAll;
                }, function(next) {
                    // generate the address for this index
                    var address = wallet.bip32.generateAddress(addrType, index);
                    address.chain = addrType;
                    address.chainIndex = index;
                    address.balance = 0;
                    address.unconfirmedBalance = 0;
                    // get the received amount for this address
                    addressInfo.getReceived(address.pub).then(function(received) {
                        address.received = received;
//                         address.balance = received.balance - (received.unconfirmed_sent || 0);
                        address.balance = received.balanceSat - (received.unconfirmedBalanceSat || 0);
                        if (address.balance < 0) {
                            address.balance = 0;
                        }
                        address.unconfirmedBalance = received.unconfirmedBalanceSat || 0;
                        if (address.unconfirmedBalance < 0) {
                            address.unconfirmedBalance = 0;
                        }
//                         if (received.received > 0 || received.unconfirmed_received > 0) {
                        if (received.totalReceivedSat > 0 || received.unconfirmedBalanceSat > 0) {
                            // increment the index for the next run
                            index += 1;
                            // and increment the bip key's address count
                            wallet.bip32.keyCount[addrType] += 1;
                            // add the address to the wallet
                            wallet.addresses[addrType][address.pub] = address;
                            // then continue, generating a new address
                            return next();
                            // if we have received anything, look for unspent outputs
                        } else {
                            // otherwise just set unspent to an empty
                            // array and move on.
                            address.unspent = [];
                            // set to true, to indicate that we do not
                            // need to generate any more addresses
                            hasAll = true;
                            // add the address to the wallet
                            wallet.addresses[addrType][address.pub] = address;
                            // then continue
                            if (addrType === 'receive') {
                                wallet.nextAddress = address;
                                hidapi.showQr(index);
                            }
                            if (addrType === 'change') {
//                                 wallet.nextAddress = address;
                                hidapi.setChangeAddress(index);
                            }
                            return next();
                        }
                    }, next); // pass in callback as promise failure function
                }, done);
            }, function(err) {
                if (err) {
                    return deferred.reject(err);
                }
                return deferred.resolve(wallet);
            });
            return deferred.promise;
        };

        Wallet.prototype.getUnspent = function() {
            var wallet = this;
            var deferred = $q.defer();
            wallet.unspent = [];
            async.each([
                "receive",
                "change"
            ], function(addrType, done) {
                async.forEachOf(wallet.addresses[addrType], function(address, _, next) {
//                     if (!address.received.received && !address.received.unconfirmed_received) {
                    if (!address.received.totalReceivedSat && !address.received.unconfirmedBalance) {
                        wallet.addresses[addrType][address.pub].unspent = [];
                        return next();
                    }
//                     var thisUnconfirmedSpent = (address.received.unconfirmed_balance + address.received.sent);
                    var thisUnconfirmedSpent = (address.received.unconfirmedBalance + address.received.totalSentSat);
                    if (thisUnconfirmedSpent < 0) {
                        wallet.addresses[addrType][address.pub].unspent = [];
                        return next();
                    }
                    addressInfo.getUnspent(address.pub).then(function(unspent) {
                        // assign the chain and chain index
                        // for each output for when we go to
                        // send
                        unspent.forEach(function(output) {
                            output.chain = addrType;
                            output.chainIndex = address.chainIndex;
                            wallet.unspent.push(output);
                        });
                        wallet.addresses[addrType][address.pub].unspent = unspent;
                        return next();
                    }, next); // pass in callback as promise failure function
                }, done);
            }, function(err) {
                if (err) {
                    return deferred.reject(err);
                }
                return deferred.resolve(wallet);
            });
            return deferred.promise;
        };

        Wallet.prototype.updateBalance = function() {
            var wallet = this;
            wallet.updatingBalance = true;
            wallet.balance = 0;
            wallet.unconfirmedBalance = 0;
            wallet.unspent = [];
            return wallet.getAllAddresses().then(function() {
                ["receive", "change"].forEach(wallet.recalculateBalance, wallet);
                return wallet;
            }).finally(function() {
                wallet.updatingBalance = false;
                WalletStatus.status = null;
            });
        };

        Wallet.prototype.open = function() {
            var wallet = this;
            WalletStatus.status = WalletStatus.STATUS_LOADING;
            var deferred = $q.defer();
            hidapi.loadWallet(this.number).then(function(data) {
                if (data.type !== hidapi.TYPE_SUCCESS) {
                    wallet.unlocked = false;
                    return deferred.reject("Error opening wallet");
                }
                deferred.notify(Wallet.NOTIFY_XPUB_LOADED);
                wallet.unlocked = true;
                // now that is is open, get the bip32 key for the
                // current wallet
                return Wallet.getBip32(wallet).then(function() {
                    wallet.loadTransactions();
                    return deferred.resolve(wallet);
                }, deferred.reject);
            }, deferred.reject);
            return deferred.promise;
        };


        Wallet.prototype.getChangeAddress = function() {
            var chAddr;
            var addresses = this.addresses.change;
            console.debug("Choosing change address");
            for (var address in addresses) {
                if (addresses.hasOwnProperty(address)) {
                    var received = addresses[address].received;
                    if (received.totalReceivedSat === 0 && received.unconfirmedBalance === 0) {
                        chAddr = address;
                    }
                }
            }
            return chAddr;
        };

        Wallet.prototype.showQr = function(chainIndex) {
        	return hidapi.showQr(chainIndex);
        };

        Wallet.prototype.setChangeAddress = function(chainIndex) {
        	return hidapi.setChangeAddress(chainIndex);
        };


        Wallet.prototype.send = function(outputs, fee, forceSmallChange) {
            WalletStatus.status = WalletStatus.STATUS_SENDING;
            var wallet = this;
            var deferred = $q.defer();
            try {
                console.debug("making transaction");
                var tx = new Transaction({
                    outputs: outputs,
                    fee: fee,
                    inputs: wallet.unspent,
                    changeAddress: wallet.getChangeAddress(),
                    forceSmallChange: forceSmallChange,
                });
                // do the send
                doSend(tx).then(deferred.resolve, deferred.reject);
                return deferred.promise.finally(function() {
                    WalletStatus.status = null;
                });
            } catch (ex) {
            	console.debug("caught exception in making transaction");
                if (ex === Transaction.ERR_AMOUNT_TOO_LOW) {
                    $timeout(function() {
                        deferred.reject("You cannot send less than " + bcMath.toBTC(MIN_OUTPUT) + " BTC");
                    });
                } else if (ex.change !== undefined && 'number' === typeof ex.change) {
                    $timeout(function() {
                        deferred.reject(ex);
                    });
                } else {
                    $timeout(function() {
                        deferred.reject(ex);
                    });
                }
                return deferred.promise;
            }
        };

        function doSend(tx) {
            console.debug("send: signing with device");
            // sign the transaction on the device
            return hidapi.signTransaction(tx)
                .then(function(res) {
                    // after signing, re4place the input scripts
                    // with the signed versions
                    console.debug("send: signed, replacing scripts");
                    tx.replaceScripts(res.payload.signedScripts);
                    // then submit it to the network
                    return tx;
                });
        }

        Wallet.prototype.signMessage = function(address, chain, chainIndex, message) {
            WalletStatus.status = WalletStatus.STATUS_SIGNING;
            return hidapi.signMessage(address, chain, chainIndex, message)
                .finally(function() {
                    WalletStatus.status = null;
                });
        };

        // renames the currently loaded wallet
        Wallet.prototype.rename = function(newName) {
            var wallet = this;
            return hidapi.renameWallet(newName).then(function() {
                console.debug(arguments);
                wallet._name = newName;
            });
        };

        Wallet.prototype.remove = function() {
            return hidapi.deleteWallet(this.number);
        };

        Wallet.prototype.removeConfirm = function(otp) {
            return hidapi.sendOTP(otp);
        };

//         Wallet.prototype.loadTransactions = function() {
//             WalletStatus.status = WalletStatus.STATUS_LOADING_TRANSACTIONS;
//             var transactions = [];
//             var foundHashes = [];
//             var wallet = this;
//             var deferred = $q.defer();
//             wallet.loadingTransactions = true;
//             async.each([
//                 "receive",
//                 "change"
//             ], function(addrType, done) {
//                 async.forEachOf(wallet.addresses[addrType], function(address, _, next) {
//                     if (!address.received.totalReceivedSat && !address.received.unconfirmedBalance) {
//                         return next();
//                     }
//                     addressInfo.getTransactions(address.pub).then(function(txs) {
//                         txs.forEach(function(tx) {
//                             if (foundHashes.indexOf(tx.hash) === -1) {
//                                 foundHashes.push(tx.hash);
//                                 transactions.push(tx);
//                             }
//                         });
//                         return next();
//                     }, next);
//                 }, done);
//             }, function(err) {
//                 if (err) {
//                     return deferred.reject(err);
//                 }
//                 transactions = transactions.sort(txSort).map(wallet.txMap.bind(wallet));
//                 wallet.transactions = transactions;
//                 WalletStatus.status = null;
//                 return deferred.resolve(transactions);
//             });
//             return deferred.promise.finally(function() {
//                 wallet.loadingTransactions = false;
//             });
//         };

        Wallet.prototype.loadTransactions = function() {
            WalletStatus.status = WalletStatus.STATUS_LOADING_TRANSACTIONS;
            var transactions = [];
            var foundHashes = [];
            var wallet = this;
            var deferred = $q.defer();
            wallet.loadingTransactions = true;
            async.each([
                "receive",
                "change"
            ], function(addrType, done) {
                async.forEachOf(wallet.addresses[addrType], function(address, _, next) {
                    if (!address.received.totalReceivedSat && !address.received.unconfirmedBalance) {
                        return next();
                    }
                    addressInfo.getTransactions(address.pub).then(function(txs) {
                        txs.forEach(function(tx) {
                            if (foundHashes.indexOf(tx.txid) === -1) {
                                foundHashes.push(tx.txid);
                                console.debug("foundHashes.push(tx.txid) " + tx.txid);
                                transactions.push(tx);
                            }
                        });
                        return next();
                    }, next);
                }, done);
            }, function(err) {
                if (err) {
                    return deferred.reject(err);
                }
                transactions = transactions.sort(txSort).map(wallet.txMap.bind(wallet));
                wallet.transactions = transactions;
                WalletStatus.status = null;
                return deferred.resolve(transactions);
            });
            return deferred.promise.finally(function() {
                wallet.loadingTransactions = false;
            });
        };


        function txSort(a, b) {
            return a.confirmations < b.confirmations ? -1 : 1;
        }

	// Assumes the amount is displayed as an eight-digit after the comma float (string)	
		function stringToSatoshis(amountAsString) {
			amountAsString = amountAsString.replace(/\./g,'');
			var amountAsInteger = 0;
			var i;
			var amountArray = amountAsString.split("");
			amountArray.reverse();
			for(i = 0; i < amountArray.length; i++)
			{
				amountAsInteger = amountAsInteger + ((parseInt(amountArray[i]))*(Math.pow(10,i)));
			}
			return amountAsInteger;
		}



//         Wallet.prototype.txMap = function(tx) {
//             tx.type = 'send';
//             var wallet = this;
//             tx.totalAmount = tx.amount;
//             var ownAddresses = 0;
//             var addrCount = 0;
//             tx.outputs.forEach(function(out) {
//                 out.addresses.forEach(function(addr) {
//                     addrCount += 1;
//                     if (wallet.addresses.receive.hasOwnProperty(addr)) {
//                         tx.type = 'receive';
//                         ownAddresses += 1;
//                     } else if (wallet.addresses.change.hasOwnProperty(addr)) {
//                         ownAddresses += 1;
//                         tx.amount -= out.amount;
//                     }
//                 });
//             });
//             if (ownAddresses === addrCount) {
//                 tx.type = 'transfer';
//             }
//             if (tx.type === 'receive') {
//                 tx.outputs.forEach(function(out) {
//                     out.addresses.forEach(function(addr) {
//                         if (!wallet.addresses.receive.hasOwnProperty(addr) &&
//                             !wallet.addresses.change.hasOwnProperty(addr)) {
//                             tx.amount -= out.amount;
//                         }
//                     });
//                 });
//             }
//             return tx;
//         };

        Wallet.prototype.txMap = function(tx) {
            tx.type = 'send';
            var wallet = this;
            tx.totalAmount = tx.valueOut * 100000000;
            var ownAddresses = 0;
            var addrCount = 0;
            tx.vout.forEach(function(out) {
                out.scriptPubKey.addresses.forEach(function(addr) {
                    addrCount += 1;
                    if (wallet.addresses.receive.hasOwnProperty(addr)) {
                        tx.type = 'receive';
                        ownAddresses += 1;
                    } else if (wallet.addresses.change.hasOwnProperty(addr)) {
                        ownAddresses += 1;
                        console.debug("S out.value " + out.value);
                        console.debug("S stringToSatoshis(out.value) " + stringToSatoshis(out.value));
                        var stsS = stringToSatoshis(out.value);
						var epochDate = 0;
						if (tx.confirmations > 0) {
							epochDate = tx.blocktime*1000;
						}else{
							epochDate = tx.time*1000;
						}
						tx.blocktime = moment(epochDate).format("YYYY-MM-DD HH:mm");
                        tx.amount = stsS;
                        tx.fees = tx.fees * 100000000;
                        console.debug("S tx.fees " + tx.fees);
                    }
                });
            });
            if (ownAddresses === addrCount) {
                tx.type = 'transfer';
                console.debug("T tx.fees " + tx.fees);
            }
            if (tx.type === 'receive') {
                tx.vout.forEach(function(out) {
                    out.scriptPubKey.addresses.forEach(function(addr) {
                    	console.debug("R addr " + addr);
                        if (wallet.addresses.receive.hasOwnProperty(addr)) {
							console.debug("R out.value " + out.value);
							console.debug("R stringToSatoshis(out.value) " + stringToSatoshis(out.value));
                        	var stsR = 0;
                        	stsR = stringToSatoshis(out.value);
                        	var epochDate2 = 0;
							if (tx.confirmations > 0) {
								epochDate2 = tx.blocktime*1000;
							}else{
								epochDate2 = tx.time*1000;
							}
							tx.blocktime = moment(epochDate2).format("YYYY-MM-DD HH:mm");
                            tx.amount = stsR;
                            console.debug("R tx.amount " + tx.amount);
                        }
                    });
                });
            }
            return tx;
        };

        return Wallet;

    }

})(window, window.angular, window.async);

(function(window, angular) {
    'use strict';

    angular.module('app.wallet')
        .config(config);

    config.$inject = ['$routeProvider'];

    function config($routeProvider) {
        $routeProvider.when('/', {
            controller: 'WalletCtrl',
            controllerAs: 'vm',
            templateUrl: 'wallet/wallets.html'
        });
    }

})(window, window.angular);

(function(window, angular) {
    'use strict';

    angular.module('app.wallet')
        .directive('walletAddresses', walletAddresses);

    walletAddresses.$inject = ['Toast'];

    function walletAddresses(Toast) {
        return {
            templateUrl: 'wallet/info/addresses.html',
            link: function(scope) {
                // size of address QR codes
                scope.qrsize = 120;
                // will hold truthy values to show individual QR codes
                // for the addresses
                scope.showqr = {};

                scope.showQr = function(address, chainIndex, addrType) {
                    scope.showqr[address] = !scope.showqr[address];
                    if (addrType === 'receive') {
                        scope.wallet.showQr(chainIndex).catch(Toast.errorHandler);
                    }
                };
            }
        };
    }

})(window, window.angular);

(function(window, angular) {
    'use strict';

    angular.module('app.wallet')
        .directive('walletDelete', walletDelete);

    walletDelete.$inject = ['Wallet', 'Toast', 'hidapi'];

    function walletDelete(Wallet, Toast, hidapi) {
        return {
            scope: {
                wallet: '=',
                onDelete: '&',
            },
            templateUrl: 'wallet/info/delete.html',
            link: function(scope) {
                scope.deleteWallet = function() {
                    scope.deletingWallet = true;
                    scope.wallet.remove().then(function() {
                        scope.otpRequested = true;
                    }, Toast.errorHandler).finally(function() {
                        scope.deleteingWallet = false;
                    });
                };

                scope.formatDevice = function() {
                    scope.formatting = true;
                    hidapi.format().then(function() {
                        scope.otpRequested = true;
                    }, Toast.errorHandler).finally(function() {
                        scope.formatting = false;
                    });
                };

                scope.sendOtp = function() {
                    scope.sendingOtp = true;
                    scope.wallet.removeConfirm(scope.otp).then(function() {
                        scope.onDelete();
                    }, Toast.errorHandler).finally(function() {
                        scope.otpRequested = false;
                        scope.sendingOtp = false;
                    });
                };
            }
        };
    }

})(window, window.angular);

(function(window, angular) {
    'use strict';

    angular.module('app.wallet')
        .directive('walletRename', walletRename);

    walletRename.$inject = ['Wallet', 'Toast'];

    function walletRename(Wallet, Toast) {
        return {
            templateUrl: 'wallet/info/rename.html',
            link: function(scope) {
                reset();

                scope.renameWallet = function() {
                    scope.renamingWallet = true;
                    scope.wallet.rename(scope.newName).then(function() {
                        reset();
                    }, Toast.errorHandler).finally(function() {
                        scope.renamingWallet = false;
                    });
                };

                function reset() {
                    scope.newName = "";
                }
            }
        };
    }

})(window, window.angular);

(function(window, angular) {
    'use strict';

    angular.module('app.wallet')
        .directive('walletSend', walletSend);

    walletSend.$inject = ['DEFAULT_FEE', 'MIN_OUTPUT', 'Toast', 'txUtil'];

    function walletSend(DEFAULT_FEE, MIN_OUTPUT, Toast, txUtil) {
        return {
            templateUrl: 'wallet/info/send.html',
            link: function(scope) {

                scope.DEFAULT_FEE = DEFAULT_FEE;
                scope.MIN_OUTPUT = MIN_OUTPUT;

                scope.reset = function() {
                    scope.outputs = [{
                        address: "",
                        amount: 0
                    }];
                    scope.fee = DEFAULT_FEE;
                    scope.signedHex = null;
                };

                scope.addOutput = function(index) {
                    if (index === undefined) {
                        index = scope.outputs.length - 1;
                    }
                    scope.outputs.splice(index + 1, 0, {
                        address: "",
                        amount: 0
                    });
                };

                scope.removeOutput = function(index) {
                    scope.outputs.splice(index, 1);
                };

                scope.send = function() {
                    scope.dust = 0;
                    scope.updatingBalance = true;
                    scope.wallet.getUnspent().then(function() {
                        scope.doSend();
                    }, Toast.errorHandler).finally(function() {
                        scope.updatingBalance = false;
                    });
                };

                scope.amountChanged = function() {
                    var total = 0;
                    scope.outputs.forEach(function(output) {
                        total += output.amount;
                    });
                    if ((total + scope.fee) > (scope.wallet.balance + scope.wallet.unconfirmedBalance)) {
                        scope.totalTooHigh = true;
                    } else {
                        scope.totalTooHigh = false;
                    }
                    if (scope.totalTooHigh) {
                        scope.totalExceedsConfirmed = false;
                    } else if ((total + scope.fee) > scope.wallet.balance) {
                        scope.totalExceedsConfirmed = true;
                    } else {
                        scope.totalExceedsConfirmed = false;
                    }
                };

                scope.doSend = function(forceSmallChange) {
                    scope.sending = true;
                    return scope.wallet.send(scope.outputs, scope.fee, forceSmallChange)

                        .then(function(tx) {
                            scope.tx = tx;
                            scope.signedHex = tx.signedHex;
                            if (scope.expertMode) {
                                Toast.success("Transaction signed. Review and confirm.");
                            } else {
                                scope.submit();
                            }
                        }, function(err) {
                            if ('number' === typeof err.change) {
                                scope.dust = err.change;
                            } else {
                                Toast.errorHandler(err);
                            }
                        })

                        .finally(function() {
                            scope.sending = false;
                        });
                };

                scope.smallChangeToFee = function() {
                    var dust = scope.dust;
                    scope.fee += dust;
                    scope.doSend().finally(function() {
                        scope.dust = 0;
                    });
                };

                scope.smallChangeLowerFee = function() {
                    var dust = scope.dust;
                    scope.fee -= (MIN_OUTPUT - dust);
                    scope.doSend().finally(function() {
                        scope.dust = 0;
                    });
                };

                scope.smallChangeForce = function() {
                    scope.doSend('force it').finally(function() {
                        scope.dust = 0;
                    });
                };

                scope.submit = function() {
                    scope.submitting = true;
                    console.debug("scope.signedHex to submit: " + scope.signedHex);
                    txUtil.submit(scope.signedHex)

                        .then(function() {
                            scope.wallet.clearSpent(scope.tx.inputs);
                            scope.signedHex = null;
                            scope.tx = null;
                            scope.reset();
                            if (scope.expertMode) {
                                Toast.success("Transaction submitted to network");
                            } else {
                                Toast.success("Transaction success");
                            }
                        }, Toast.errorHandler)

                        .finally(function() {
                            scope.submitting = false;
                        });
                };

                scope.reset();
            }
        };
    }

})(window, window.angular);

(function(window, angular) {
    'use strict';

    angular.module('app.wallet')
        .directive('walletSign', walletSign);

    walletSign.$inject = ['Toast'];

    function walletSign(Toast) {
        return {
            templateUrl: 'wallet/info/sign.html',
            link: function(scope) {

                scope.message = "";
                scope.address = null;
                scope.signed = null;

                scope.sign = function() {
                    scope.signed = null;
                    scope.signing = true;
                    scope.wallet.signMessage(scope.address.pub,
                                             scope.address.chain,
                                             scope.address.chainIndex,
                                             scope.message)
                        .then(function(signed) {
                            scope.signed = signed;
                        }, Toast.errorHandler)
                        .finally(function() {
                            scope.signing = false;
                        });
                };

                scope.$watchCollection('wallet', function(wallet) {
                    if (!wallet) {
                        return;
                    }
                    var addressList = [];
                    var addresses = wallet.addresses.receive;
                    Object.keys(addresses).forEach(function(address) {
                        address = addresses[address];
                        // make a new object, because the BIP32
                        // object causes errors.. something
                        // something circular object
                        addressList.push({
                            chain: address.chain,
                            chainIndex: address.chainIndex,
                            pub: address.pub
                        });
                    });
                    scope.addresses = addressList;
                    if (!scope.address) {
                        scope.address = addressList[0];
                    }
                });


            }
        };
    }

})(window, window.angular);

(function(window, angular) {
    'use strict';

    angular.module('app.wallet')
        .directive('walletTransactions', walletTransactions);

    walletTransactions.$inject = [];

    function walletTransactions() {
        return {
            restrict: 'E',
            templateUrl: 'wallet/info/transactions.html',
            link: function(scope) {
                var pageSize = scope.pageSize = 10;

                scope.$watchCollection('wallet.transactions', function(txs) {
                    if (txs && Array.isArray(txs) && txs.length) {
                        var page = scope.page = 1;
                        scope.transactions = makeTxSlice(page, txs);
                    }
                });

                scope.pageChange = function() {
                    scope.transactions = makeTxSlice(scope.page, scope.wallet.transactions);
                };

                function makeTxSlice(page, txs) {
                    var startIndex = pageSize * (page - 1);
                    var endIndex = startIndex + pageSize;
                    return txs.slice(startIndex, endIndex);
                }

            }
        };
    }

})(window, window.angular);

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwcC5tb2R1bGUuanMiLCJiaXRjb2luL2JpdGNvaW4ubW9kdWxlLmpzIiwiY29yZS9jb3JlLm1vZHVsZS5qcyIsImhpZC9oaWQubW9kdWxlLmpzIiwidXRpbC91dGlsLm1vZHVsZS5qcyIsIndhbGxldC93YWxsZXQubW9kdWxlLmpzIiwiYXBwLnJvdXRlcy5qcyIsImJpdGNvaW4vYWRkcmVzcy1pbmZvLmZhY3RvcnkuanMiLCJiaXRjb2luL2JjbWF0aC5mYWN0b3J5LmpzIiwiYml0Y29pbi9iY251bWJlci5maWx0ZXIuanMiLCJiaXRjb2luL2JpcDMyLmZhY3RvcnkuanMiLCJiaXRjb2luL2JpcDM5LXdvcmRsaXN0LmNvbnN0YW50LmpzIiwiYml0Y29pbi9iaXRjb2luLmNvbnN0YW50cy5qcyIsImJpdGNvaW4vZm9ybS1pbnB1dC5kaXJlY3RpdmUuanMiLCJiaXRjb2luL21lc3NhZ2UtdXRpbC5mYWN0b3J5LmpzIiwiYml0Y29pbi90cmFuc2FjdGlvbi5mYWN0b3J5LmpzIiwiYml0Y29pbi90eC11dGlsLmZhY3RvcnkuanMiLCJiaXRjb2luL3VuaXQtc2VsZWN0b3IuZGlyZWN0aXZlLmpzIiwiYml0Y29pbi92YWx1ZS5kaXJlY3RpdmUuanMiLCJjb3JlL2NvcmUucm91dGVzLmpzIiwiY29yZS9leHBlcnQtbW9kZS5kaXJlY3RpdmUuanMiLCJjb3JlL2hvbWUuY3RybC5qcyIsImNvcmUvbmF2LmN0cmwuanMiLCJjb3JlL3NyY21hcC5jb25maWcuanMiLCJjb3JlL3N0YXR1cy5jdHJsLmpzIiwiaGlkL2hpZC5jb25zdGFudHMuanMiLCJoaWQvaGlkYXBpLmNvbW1hbmRzLmpzIiwiaGlkL2hpZGFwaS5qcyIsImhpZC9oaWRwbHVnaW4uZGlyZWN0aXZlLmpzIiwidXRpbC9jb29raWUuZmFjdG9yeS5qcyIsInV0aWwvaGV4LmZhY3RvcnkuanMiLCJ1dGlsL3RvYXN0LmZhY3RvcnkuanMiLCJ3YWxsZXQvY3JlYXRlLmRpcmVjdGl2ZS5qcyIsIndhbGxldC9pbmZvLmRpcmVjdGl2ZS5qcyIsIndhbGxldC9zdGF0dXMuZmFjdG9yeS5qcyIsIndhbGxldC90eC1pbmZvLWxpbmsuZGlyZWN0aXZlLmpzIiwid2FsbGV0L3dhbGxldC5jb25zdGFudHMuanMiLCJ3YWxsZXQvd2FsbGV0LmN0cmwuanMiLCJ3YWxsZXQvd2FsbGV0LmZhY3RvcnkuanMiLCJ3YWxsZXQvd2FsbGV0LnJvdXRlcy5qcyIsIndhbGxldC9pbmZvL2FkZHJlc3Nlcy5kaXJlY3RpdmUuanMiLCJ3YWxsZXQvaW5mby9kZWxldGUuZGlyZWN0aXZlLmpzIiwid2FsbGV0L2luZm8vcmVuYW1lLmRpcmVjdGl2ZS5qcyIsIndhbGxldC9pbmZvL3NlbmQuZGlyZWN0aXZlLmpzIiwid2FsbGV0L2luZm8vc2lnbi5kaXJlY3RpdmUuanMiLCJ3YWxsZXQvaW5mby90cmFuc2FjdGlvbnMuZGlyZWN0aXZlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM3VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM1TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNsc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMza0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImFwcC5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24od2luZG93LCBhbmd1bGFyKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFtcbiAgICAgICAgJ25nUm91dGUnLCAndWkuYm9vdHN0cmFwJyxcbiAgICAgICAgJ2FwcC5jb3JlJywgJ2FwcC53YWxsZXQnXG4gICAgXSkuY29uZmlnKGFwcENvbmZpZyk7XG5cbiAgICBhcHBDb25maWcuJGluamVjdCA9IFsnJGNvbXBpbGVQcm92aWRlciddO1xuXG5cblxuICAgIGZ1bmN0aW9uIGFwcENvbmZpZyAoJGNvbXBpbGVQcm92aWRlcikge1xuICAgICAgICAkY29tcGlsZVByb3ZpZGVyLmFIcmVmU2FuaXRpemF0aW9uV2hpdGVsaXN0KC9eXFxzKihodHRwcz98ZnRwfG1haWx0b3xmaWxlfGJpdGNvaW4pOi8pO1xuICAgIH1cblxufSkod2luZG93LCB3aW5kb3cuYW5ndWxhcik7XG4iLCIoZnVuY3Rpb24od2luZG93LCBhbmd1bGFyKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgYW5ndWxhci5tb2R1bGUoJ2JpdGNvaW4nLCBbJ2FwcC51dGlsJ10pO1xuXG59KSh3aW5kb3csIHdpbmRvdy5hbmd1bGFyKTtcbiIsIihmdW5jdGlvbih3aW5kb3csIGFuZ3VsYXIpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBhbmd1bGFyLm1vZHVsZSgnYXBwLmNvcmUnLCBbJ2hpZCddKTtcblxufSkod2luZG93LCB3aW5kb3cuYW5ndWxhcik7XG4iLCIoZnVuY3Rpb24od2luZG93LCBhbmd1bGFyKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgYW5ndWxhci5tb2R1bGUoJ2hpZCcsIFsnYXBwLnV0aWwnLCAnYml0Y29pbiddKTtcblxufSkod2luZG93LCB3aW5kb3cuYW5ndWxhcik7XG4iLCIoZnVuY3Rpb24od2luZG93LCBhbmd1bGFyKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgYW5ndWxhci5tb2R1bGUoJ2FwcC51dGlsJywgWyduZ1RvYXN0JywgJ2lwQ29va2llJ10pO1xuXG59KSh3aW5kb3csIHdpbmRvdy5hbmd1bGFyKTtcbiIsIihmdW5jdGlvbih3aW5kb3csIGFuZ3VsYXIpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBhbmd1bGFyLm1vZHVsZSgnYXBwLndhbGxldCcsIFtcbiAgICAgICAgJ2hpZCcsICdiaXRjb2luJywgJ2FwcC51dGlsJyxcbiAgICAgICAgJ21vbm9zcGFjZWQucXJjb2RlJyAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9ub3NwYWNlZC9hbmd1bGFyLXFyY29kZVxuICAgIF0pO1xuXG59KSh3aW5kb3csIHdpbmRvdy5hbmd1bGFyKTtcbiIsIihmdW5jdGlvbih3aW5kb3csIGFuZ3VsYXIpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBhbmd1bGFyLm1vZHVsZSgnYXBwJylcbiAgICAgICAgLmNvbmZpZyhjb25maWcpO1xuXG4gICAgY29uZmlnLiRpbmplY3QgPSBbJyRyb3V0ZVByb3ZpZGVyJywgJyRsb2NhdGlvblByb3ZpZGVyJ107XG5cbiAgICBmdW5jdGlvbiBjb25maWcoJHJvdXRlUHJvdmlkZXIsICRsb2NhdGlvblByb3ZpZGVyKSB7XG4gICAgICAgICRsb2NhdGlvblByb3ZpZGVyLmh0bWw1TW9kZSh0cnVlKS5oYXNoUHJlZml4KCchJyk7XG4gICAgICAgICRyb3V0ZVByb3ZpZGVyLm90aGVyd2lzZSgnL2JpdGxveF9oYXJkd2FyZV93YWxsZXQnKTtcbiAgICAgICAgJHJvdXRlUHJvdmlkZXIud2hlbignL2JpdGxveF9oYXJkd2FyZV93YWxsZXQnLCB7XG4gICAgICAgICAgICBjb250cm9sbGVyOiAnV2FsbGV0Q3RybCcsXG4gICAgICAgICAgICBjb250cm9sbGVyQXM6ICd2bScsXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ2JpdGxveF9oYXJkd2FyZV93YWxsZXQvd2FsbGV0L3dhbGxldHMuaHRtbCdcbiAgICAgICAgfSk7XG5cbi8vICAgICAgICAgJHJvdXRlUHJvdmlkZXIud2hlbignLycsIHtcbi8vICAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnY29yZS9sYW5kaW5nLmh0bWwnXG4vLyAgICAgICAgIH0pO1xuICAgIH1cblxufSkod2luZG93LCB3aW5kb3cuYW5ndWxhcik7XG4iLCIoZnVuY3Rpb24od2luZG93LCBhbmd1bGFyKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgYW5ndWxhci5tb2R1bGUoJ2JpdGNvaW4nKVxuICAgICAgICAuZmFjdG9yeSgnYWRkcmVzc0luZm8nLCBhZGRyZXNzSW5mb0ZhY3RvcnkpO1xuXG4gICAgYWRkcmVzc0luZm9GYWN0b3J5LiRpbmplY3QgPSBbXG4gICAgICAgICckcScsXG4gICAgICAgICckaHR0cCcsXG4gICAgICAgICdoZXhVdGlsJyxcbiAgICBdO1xuXG4gICAgZnVuY3Rpb24gYWRkcmVzc0luZm9GYWN0b3J5KCRxLCAkaHR0cCwgaGV4VXRpbCkge1xuXG4gICAgICAgIHZhciBiYXNlVXJsID0gJ2h0dHBzOi8vYml0bG94LmlvL2FwaSc7XG4vLyAgICAgICAgIHZhciBiYXNlVXJsID0gJy9hcGknO1xuXG4gICAgICAgIHZhciBhZGRyZXNzSW5mbyA9IHt9O1xuXG4gICAgICAgIGFkZHJlc3NJbmZvLmdldFJlY2VpdmVkID0gZnVuY3Rpb24oYWRkcmVzcykge1xuICAgICAgICAgICAgcmV0dXJuICRodHRwLmdldChiYXNlVXJsICsgJy9hZGRyLycgKyBhZGRyZXNzKS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXMuZGF0YTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFsYW5jZTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuY29uZmlybWVkX3NlbnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmNvbmZpcm1lZF9yZWNlaXZlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuY29uZmlybWVkX2JhbGFuY2U6IDBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KGVyci5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBhZGRyZXNzSW5mby5nZXRVbnNwZW50ID0gZnVuY3Rpb24oYWRkcmVzcykge1xuLy8gICAgICAgICAgICAgcmV0dXJuICRodHRwLmdldChiYXNlVXJsICsgJy8nICsgYWRkcmVzcyArICcvdW5zcGVudF9vdXRwdXRzJykudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAkaHR0cC5nZXQoYmFzZVVybCArICcvYWRkci8nICsgYWRkcmVzcyArICcvdXR4bycpLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG91dHMgPSByZXMuZGF0YTtcbiAgICAgICAgICAgICAgICBvdXRzLmZvckVhY2goZnVuY3Rpb24ob3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1ha2UgdGhpcyBkYXRhIGp1c3QgbG9rZSBibG9ja2NoYWluLmluZm8nc1xuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgaGFzaCA9IG91dC50eF9oYXNoX2JpZ19lbmRpYW4gPSBvdXQudHJhbnNhY3Rpb25faGFzaDtcbi8vICAgICAgICAgICAgICAgICAgICAgb3V0LnR4X2hhc2ggPSBoZXhVdGlsLm1ha2VTdHJpbmdTbWFsbEVuZGlhbihoYXNoKTtcbi8vICAgICAgICAgICAgICAgICAgICAgb3V0LnZhbHVlID0gb3V0LmFtb3VudDtcbi8vICAgICAgICAgICAgICAgICAgICAgb3V0LnNjcmlwdCA9IG91dC5zY3JpcHRfaGV4O1xuLy8gICAgICAgICAgICAgICAgICAgICBvdXQudHhfb3V0cHV0X24gPSBvdXQub3V0cHV0X2luZGV4O1xuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgaGFzaCA9IG91dC50eF9oYXNoX2JpZ19lbmRpYW4gPSBvdXQudHhpZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc2ggPSBvdXQudHhfaGFzaF9iaWdfZW5kaWFuID0gb3V0LnR4aWQ7XG4gICAgICAgICAgICAgICAgICAgIG91dC50eF9oYXNoID0gaGV4VXRpbC5tYWtlU3RyaW5nU21hbGxFbmRpYW4oaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIG91dC52YWx1ZSA9IG91dC5hbW91bnQgKiAxMDAwMDAwMDA7XG4gICAgICAgICAgICAgICAgICAgIG91dC5zY3JpcHQgPSBvdXQuc2NyaXB0UHViS2V5O1xuICAgICAgICAgICAgICAgICAgICBvdXQudHhfb3V0cHV0X24gPSBvdXQudm91dDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cztcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KGVyci5kYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4vLyAgICAgICAgIGFkZHJlc3NJbmZvLmdldFRyYW5zYWN0aW9ucyA9IGZ1bmN0aW9uKGFkZHJlc3MpIHtcbi8vIC8vICAgICAgICAgICAgIHJldHVybiAkaHR0cC5nZXQoYmFzZVVybCArICcvJyArIGFkZHJlc3MgKyAnL3RyYW5zYWN0aW9ucycpLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4vLyAgICAgICAgICAgICByZXR1cm4gJGh0dHAuZ2V0KGJhc2VVcmwgKyAnL3R4cy8/YWRkcmVzcz0nICsgYWRkcmVzcyApLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4vLyAgICAgICAgICAgICAgICAgdmFyIHR4cyA9IHJlcy5kYXRhLnRyYW5zYWN0aW9ucztcbi8vICAgICAgICAgICAgICAgICB0eHMgPSB0eHMuY29uY2F0KHJlcy5kYXRhLnVuY29uZmlybWVkX3RyYW5zYWN0aW9ucyk7XG4vLyAgICAgICAgICAgICAgICAgcmV0dXJuIHR4cztcbi8vICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuLy8gICAgICAgICAgICAgICAgIGlmIChlcnIuc3RhdHVzID09PSA0MDQpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuLy8gICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoZXJyLmRhdGEpO1xuLy8gICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICB9O1xuICAgICAgICBhZGRyZXNzSW5mby5nZXRUcmFuc2FjdGlvbnMgPSBmdW5jdGlvbihhZGRyZXNzKSB7XG4vLyAgICAgICAgICAgICByZXR1cm4gJGh0dHAuZ2V0KGJhc2VVcmwgKyAnLycgKyBhZGRyZXNzICsgJy90cmFuc2FjdGlvbnMnKS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgcmV0dXJuICRodHRwLmdldChiYXNlVXJsICsgJy90eHMvP2FkZHJlc3M9JyArIGFkZHJlc3MgKS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgIHZhciB0eHMgPSByZXMuZGF0YS50eHM7XG4vLyAgICAgICAgICAgICAgICAgdHhzID0gdHhzLmNvbmNhdChyZXMuZGF0YS51bmNvbmZpcm1lZF90cmFuc2FjdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eHM7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KGVyci5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gYWRkcmVzc0luZm87XG4gICAgfVxuXG59KSh3aW5kb3csIHdpbmRvdy5hbmd1bGFyKTtcbiIsIihmdW5jdGlvbih3aW5kb3csIGFuZ3VsYXIsIEJpZ051bWJlcikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGFuZ3VsYXIubW9kdWxlKCdiaXRjb2luJylcbiAgICAgICAgLmZhY3RvcnkoJ2JjTWF0aCcsIGJjTWF0aEZhY3RvcnkpO1xuXG4gICAgYmNNYXRoRmFjdG9yeS4kaW5qZWN0ID0gWydDT0lOJ107XG5cbiAgICBmdW5jdGlvbiBiY01hdGhGYWN0b3J5KENPSU4pIHtcblxuICAgICAgICB2YXIgYmNNYXRoID0ge1xuICAgICAgICAgICAgc2F0b3NoaVRvQlRDOiBzYXRvc2hpVG9CVEMsXG4gICAgICAgICAgICB0b0JUQzogc2F0b3NoaVRvQlRDLFxuICAgICAgICAgICAgYnRjVG9TYXRvc2hpOiBidGNUb1NhdG9zaGksXG4gICAgICAgICAgICB0b1NhdG9zaGk6IGJ0Y1RvU2F0b3NoaVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBiaXRjb2luID0gbmV3IEJpZ051bWJlcihDT0lOKTtcblxuICAgICAgICByZXR1cm4gYmNNYXRoO1xuXG4gICAgICAgIGZ1bmN0aW9uIHNhdG9zaGlUb0JUQyhzYXRvc2hpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihzYXRvc2hpKS5kaXZpZGVkQnkoYml0Y29pbikudG9OdW1iZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGJ0Y1RvU2F0b3NoaShidGMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKGJ0YykudGltZXMoYml0Y29pbikudG9OdW1iZXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxufSkod2luZG93LCB3aW5kb3cuYW5ndWxhciwgd2luZG93LkJpZ051bWJlcik7XG4iLCIoZnVuY3Rpb24od2luZG93LCBhbmd1bGFyKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgYW5ndWxhci5tb2R1bGUoJ2JpdGNvaW4nKVxuICAgICAgICAuZmlsdGVyKCdiY051bWJlcicsIGJjTnVtYmVyRmFjdG9yeSk7XG5cbiAgICBiY051bWJlckZhY3RvcnkuJGluamVjdCA9IFsnJGZpbHRlciddO1xuXG4gICAgZnVuY3Rpb24gYmNOdW1iZXJGYWN0b3J5KCRmaWx0ZXIpIHtcbiAgICAgICAgdmFyIGZpbHRlciA9ICRmaWx0ZXIoJ251bWJlcicpO1xuICAgICAgICB2YXIgcmVwbGFjZSA9IC9cXC4/MCskLztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGJjTnVtYmVyKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gZmlsdGVyKGlucHV0LCA4KTtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQucmVwbGFjZShyZXBsYWNlLCAnJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG59KSh3aW5kb3csIHdpbmRvdy5hbmd1bGFyKTtcbiIsIihmdW5jdGlvbih3aW5kb3csIGFuZ3VsYXIsIEJpdGNvaW4sIEJJUDMyKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgYW5ndWxhci5tb2R1bGUoJ2JpdGNvaW4nKVxuICAgICAgICAuZmFjdG9yeSgnQklQMzInLCBCaXAzMkZhY3RvcnkpO1xuXG4gICAgQmlwMzJGYWN0b3J5LiRpbmplY3QgPSBbXG4gICAgICAgICdNQUlOTkVUX1BVQkxJQycsXG4gICAgICAgICdNQUlOTkVUX1BSSVZBVEUnLFxuICAgICAgICAnVEVTVE5FVF9QVUJMSUMnLFxuICAgICAgICAnVEVTVE5FVF9QUklWQVRFJyxcbiAgICAgICAgJ1JFQ0VJVkVfQ0hBSU4nLFxuICAgICAgICAnQ0hBTkdFX0NIQUlOJyxcbiAgICAgICAgJ0dBUCdcbiAgICBdO1xuXG4gICAgZnVuY3Rpb24gQmlwMzJGYWN0b3J5KE1BSU5ORVRfUFVCTElDLCBNQUlOTkVUX1BSSVZBVEUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFRFU1RORVRfUFVCTElDLCBURVNUTkVUX1BSSVZBVEUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFJFQ0VJVkVfQ0hBSU4sIENIQU5HRV9DSEFJTiwgR0FQKSB7XG5cbiAgICAgICAgdmFyIEJpcDMyID0gZnVuY3Rpb24oeHB1Yikge1xuICAgICAgICAgICAgdmFyIGJpcDMyID0gdGhpcztcbiAgICAgICAgICAgIHZhciBrZXkgPSBiaXAzMi5rZXkgPSBuZXcgQklQMzIoeHB1Yik7XG4gICAgICAgICAgICBzd2l0Y2ggKGtleS52ZXJzaW9uKSB7XG4gICAgICAgICAgICBjYXNlIE1BSU5ORVRfUFVCTElDOlxuICAgICAgICAgICAgICAgIGJpcDMyLmtleWxhYmVsID0gXCJQdWJsaWMga2V5XCI7XG4gICAgICAgICAgICAgICAgYmlwMzIubmV0d29yayA9ICdwcm9kJztcbiAgICAgICAgICAgICAgICBiaXAzMi5uZXR3b3JrbGFiZWwgPSBcIkJpdGNvaW4gTWFpbm5ldFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBNQUlOTkVUX1BSSVZBVEU6XG4gICAgICAgICAgICAgICAgYmlwMzIua2V5bGFiZWwgPSBcIlByaXZhdGUga2V5XCI7XG4gICAgICAgICAgICAgICAgYmlwMzIubmV0d29yayA9ICdwcm9kJztcbiAgICAgICAgICAgICAgICBiaXAzMi5uZXR3b3JrbGFiZWwgPSBcIkJpdGNvaW4gTWFpbm5ldFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBURVNUTkVUX1BVQkxJQzpcbiAgICAgICAgICAgICAgICBiaXAzMi5rZXlsYWJlbCA9IFwiUHVibGljIGtleVwiO1xuICAgICAgICAgICAgICAgIGJpcDMyLm5ldHdvcmsgPSAndGVzdCc7XG4gICAgICAgICAgICAgICAgYmlwMzIubmV0d29ya2xhYmVsID0gXCJCaXRjb2luIFRlc3RuZXRcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVEVTVE5FVF9QUklWQVRFOlxuICAgICAgICAgICAgICAgIGJpcDMyLmtleWxhYmVsID0gXCJQcml2YXRlIGtleVwiO1xuICAgICAgICAgICAgICAgIGJpcDMyLm5ldHdvcmsgPSAndGVzdCc7XG4gICAgICAgICAgICAgICAgYmlwMzIubmV0d29ya2xhYmVsID0gXCJCaXRjb2luIFRlc3RuZXRcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBrZXkgdmVyc2lvblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEJpdGNvaW4uc2V0TmV0d29yayhiaXAzMi5uZXR3b3JrKTtcblxuICAgICAgICAgICAgYmlwMzIuY2hhaW5zID0ge1xuICAgICAgICAgICAgICAgIHJlY2VpdmU6IGtleS5kZXJpdmVfY2hpbGQoUkVDRUlWRV9DSEFJTiksXG4gICAgICAgICAgICAgICAgY2hhbmdlOiBrZXkuZGVyaXZlX2NoaWxkKENIQU5HRV9DSEFJTilcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGJpcDMyLmtleUNvdW50ID0ge1xuICAgICAgICAgICAgICAgIHJlY2VpdmU6IEdBUCxcbiAgICAgICAgICAgICAgICBjaGFuZ2U6IEdBUFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBCaXAzMi5wcm90b3R5cGUuZ2VuZXJhdGVBZGRyZXNzID0gZnVuY3Rpb24oY2hhaW4sIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgYmlwMzIgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCFiaXAzMi5jaGFpbnNbY2hhaW5dKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjaGFpblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhZGRyZXNzID0ge307XG4gICAgICAgICAgICB2YXIgY2hpbGRLZXkgPSBiaXAzMi5jaGFpbnNbY2hhaW5dLmRlcml2ZV9jaGlsZChpbmRleCk7XG4gICAgICAgICAgICB2YXIgY2hpbGRBZGRyID0gY2hpbGRLZXkuZWNrZXkuZ2V0Qml0Y29pbkFkZHJlc3MoKS50b1N0cmluZygpO1xuICAgICAgICAgICAgYWRkcmVzcy5wdWIgPSBjaGlsZEFkZHI7XG4gICAgICAgICAgICBhZGRyZXNzLmtleSA9IGNoaWxkS2V5O1xuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH07XG5cbiAgICAgICAgQmlwMzIucHJvdG90eXBlLmdlbmVyYXRlQWRkcmVzc2VzID0gZnVuY3Rpb24oY2hhaW4pIHtcbiAgICAgICAgICAgIHZhciBiaXAzMiA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIWJpcDMyLmNoYWluc1tjaGFpbl0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNoYWluXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFkZHJlc3NlcyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaXAzMi5rZXlDb3VudFtjaGFpbl07IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBhZGRyZXNzID0gYmlwMzIuZ2VuZXJhdGVBZGRyZXNzKGNoYWluLCBpKTtcbiAgICAgICAgICAgICAgICBhZGRyZXNzZXNbYWRkcmVzcy5wdWJdID0gYWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzZXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIEJpcDMyO1xuXG4gICAgfVxuXG59KSh3aW5kb3csIHdpbmRvdy5hbmd1bGFyLCB3aW5kb3cuQml0Y29pbiwgd2luZG93LkJJUDMyKTtcbiIsIihmdW5jdGlvbih3aW5kb3csIGFuZ3VsYXIpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBhbmd1bGFyLm1vZHVsZSgnYml0Y29pbicpXG4gICAgICAgIC5jb25zdGFudCgnQklQMzlXb3JkTGlzdCcsIFtcbiAgICAgICAgICAgIFwiYWJhbmRvblwiLCBcImFiaWxpdHlcIiwgXCJhYmxlXCIsIFwiYWJvdXRcIiwgXCJhYm92ZVwiLCBcImFic2VudFwiLFxuICAgICAgICAgICAgXCJhYnNvcmJcIiwgXCJhYnN0cmFjdFwiLCBcImFic3VyZFwiLCBcImFidXNlXCIsIFwiYWNjZXNzXCIsIFwiYWNjaWRlbnRcIixcbiAgICAgICAgICAgIFwiYWNjb3VudFwiLCBcImFjY3VzZVwiLCBcImFjaGlldmVcIiwgXCJhY2lkXCIsIFwiYWNvdXN0aWNcIiwgXCJhY3F1aXJlXCIsXG4gICAgICAgICAgICBcImFjcm9zc1wiLCBcImFjdFwiLCBcImFjdGlvblwiLCBcImFjdG9yXCIsIFwiYWN0cmVzc1wiLCBcImFjdHVhbFwiLFxuICAgICAgICAgICAgXCJhZGFwdFwiLCBcImFkZFwiLCBcImFkZGljdFwiLCBcImFkZHJlc3NcIiwgXCJhZGp1c3RcIiwgXCJhZG1pdFwiLFxuICAgICAgICAgICAgXCJhZHVsdFwiLCBcImFkdmFuY2VcIiwgXCJhZHZpY2VcIiwgXCJhZXJvYmljXCIsIFwiYWZmYWlyXCIsIFwiYWZmb3JkXCIsXG4gICAgICAgICAgICBcImFmcmFpZFwiLCBcImFnYWluXCIsIFwiYWdlXCIsIFwiYWdlbnRcIiwgXCJhZ3JlZVwiLCBcImFoZWFkXCIsXG4gICAgICAgICAgICBcImFpbVwiLCBcImFpclwiLCBcImFpcnBvcnRcIiwgXCJhaXNsZVwiLCBcImFsYXJtXCIsIFwiYWxidW1cIixcbiAgICAgICAgICAgIFwiYWxjb2hvbFwiLCBcImFsZXJ0XCIsIFwiYWxpZW5cIiwgXCJhbGxcIiwgXCJhbGxleVwiLCBcImFsbG93XCIsXG4gICAgICAgICAgICBcImFsbW9zdFwiLCBcImFsb25lXCIsIFwiYWxwaGFcIiwgXCJhbHJlYWR5XCIsIFwiYWxzb1wiLCBcImFsdGVyXCIsXG4gICAgICAgICAgICBcImFsd2F5c1wiLCBcImFtYXRldXJcIiwgXCJhbWF6aW5nXCIsIFwiYW1vbmdcIiwgXCJhbW91bnRcIiwgXCJhbXVzZWRcIixcbiAgICAgICAgICAgIFwiYW5hbHlzdFwiLCBcImFuY2hvclwiLCBcImFuY2llbnRcIiwgXCJhbmdlclwiLCBcImFuZ2xlXCIsIFwiYW5ncnlcIixcbiAgICAgICAgICAgIFwiYW5pbWFsXCIsIFwiYW5rbGVcIiwgXCJhbm5vdW5jZVwiLCBcImFubnVhbFwiLCBcImFub3RoZXJcIiwgXCJhbnN3ZXJcIixcbiAgICAgICAgICAgIFwiYW50ZW5uYVwiLCBcImFudGlxdWVcIiwgXCJhbnhpZXR5XCIsIFwiYW55XCIsIFwiYXBhcnRcIiwgXCJhcG9sb2d5XCIsXG4gICAgICAgICAgICBcImFwcGVhclwiLCBcImFwcGxlXCIsIFwiYXBwcm92ZVwiLCBcImFwcmlsXCIsIFwiYXJjaFwiLCBcImFyY3RpY1wiLFxuICAgICAgICAgICAgXCJhcmVhXCIsIFwiYXJlbmFcIiwgXCJhcmd1ZVwiLCBcImFybVwiLCBcImFybWVkXCIsIFwiYXJtb3JcIixcbiAgICAgICAgICAgIFwiYXJteVwiLCBcImFyb3VuZFwiLCBcImFycmFuZ2VcIiwgXCJhcnJlc3RcIiwgXCJhcnJpdmVcIiwgXCJhcnJvd1wiLFxuICAgICAgICAgICAgXCJhcnRcIiwgXCJhcnRlZmFjdFwiLCBcImFydGlzdFwiLCBcImFydHdvcmtcIiwgXCJhc2tcIiwgXCJhc3BlY3RcIixcbiAgICAgICAgICAgIFwiYXNzYXVsdFwiLCBcImFzc2V0XCIsIFwiYXNzaXN0XCIsIFwiYXNzdW1lXCIsIFwiYXN0aG1hXCIsIFwiYXRobGV0ZVwiLFxuICAgICAgICAgICAgXCJhdG9tXCIsIFwiYXR0YWNrXCIsIFwiYXR0ZW5kXCIsIFwiYXR0aXR1ZGVcIiwgXCJhdHRyYWN0XCIsIFwiYXVjdGlvblwiLFxuICAgICAgICAgICAgXCJhdWRpdFwiLCBcImF1Z3VzdFwiLCBcImF1bnRcIiwgXCJhdXRob3JcIiwgXCJhdXRvXCIsIFwiYXV0dW1uXCIsXG4gICAgICAgICAgICBcImF2ZXJhZ2VcIiwgXCJhdm9jYWRvXCIsIFwiYXZvaWRcIiwgXCJhd2FrZVwiLCBcImF3YXJlXCIsIFwiYXdheVwiLFxuICAgICAgICAgICAgXCJhd2Vzb21lXCIsIFwiYXdmdWxcIiwgXCJhd2t3YXJkXCIsIFwiYXhpc1wiLCBcImJhYnlcIiwgXCJiYWNoZWxvclwiLFxuICAgICAgICAgICAgXCJiYWNvblwiLCBcImJhZGdlXCIsIFwiYmFnXCIsIFwiYmFsYW5jZVwiLCBcImJhbGNvbnlcIiwgXCJiYWxsXCIsXG4gICAgICAgICAgICBcImJhbWJvb1wiLCBcImJhbmFuYVwiLCBcImJhbm5lclwiLCBcImJhclwiLCBcImJhcmVseVwiLCBcImJhcmdhaW5cIixcbiAgICAgICAgICAgIFwiYmFycmVsXCIsIFwiYmFzZVwiLCBcImJhc2ljXCIsIFwiYmFza2V0XCIsIFwiYmF0dGxlXCIsIFwiYmVhY2hcIixcbiAgICAgICAgICAgIFwiYmVhblwiLCBcImJlYXV0eVwiLCBcImJlY2F1c2VcIiwgXCJiZWNvbWVcIiwgXCJiZWVmXCIsIFwiYmVmb3JlXCIsXG4gICAgICAgICAgICBcImJlZ2luXCIsIFwiYmVoYXZlXCIsIFwiYmVoaW5kXCIsIFwiYmVsaWV2ZVwiLCBcImJlbG93XCIsIFwiYmVsdFwiLFxuICAgICAgICAgICAgXCJiZW5jaFwiLCBcImJlbmVmaXRcIiwgXCJiZXN0XCIsIFwiYmV0cmF5XCIsIFwiYmV0dGVyXCIsIFwiYmV0d2VlblwiLFxuICAgICAgICAgICAgXCJiZXlvbmRcIiwgXCJiaWN5Y2xlXCIsIFwiYmlkXCIsIFwiYmlrZVwiLCBcImJpbmRcIiwgXCJiaW9sb2d5XCIsXG4gICAgICAgICAgICBcImJpcmRcIiwgXCJiaXJ0aFwiLCBcImJpdHRlclwiLCBcImJsYWNrXCIsIFwiYmxhZGVcIiwgXCJibGFtZVwiLFxuICAgICAgICAgICAgXCJibGFua2V0XCIsIFwiYmxhc3RcIiwgXCJibGVha1wiLCBcImJsZXNzXCIsIFwiYmxpbmRcIiwgXCJibG9vZFwiLFxuICAgICAgICAgICAgXCJibG9zc29tXCIsIFwiYmxvdXNlXCIsIFwiYmx1ZVwiLCBcImJsdXJcIiwgXCJibHVzaFwiLCBcImJvYXJkXCIsXG4gICAgICAgICAgICBcImJvYXRcIiwgXCJib2R5XCIsIFwiYm9pbFwiLCBcImJvbWJcIiwgXCJib25lXCIsIFwiYm9udXNcIixcbiAgICAgICAgICAgIFwiYm9va1wiLCBcImJvb3N0XCIsIFwiYm9yZGVyXCIsIFwiYm9yaW5nXCIsIFwiYm9ycm93XCIsIFwiYm9zc1wiLFxuICAgICAgICAgICAgXCJib3R0b21cIiwgXCJib3VuY2VcIiwgXCJib3hcIiwgXCJib3lcIiwgXCJicmFja2V0XCIsIFwiYnJhaW5cIixcbiAgICAgICAgICAgIFwiYnJhbmRcIiwgXCJicmFzc1wiLCBcImJyYXZlXCIsIFwiYnJlYWRcIiwgXCJicmVlemVcIiwgXCJicmlja1wiLFxuICAgICAgICAgICAgXCJicmlkZ2VcIiwgXCJicmllZlwiLCBcImJyaWdodFwiLCBcImJyaW5nXCIsIFwiYnJpc2tcIiwgXCJicm9jY29saVwiLFxuICAgICAgICAgICAgXCJicm9rZW5cIiwgXCJicm9uemVcIiwgXCJicm9vbVwiLCBcImJyb3RoZXJcIiwgXCJicm93blwiLCBcImJydXNoXCIsXG4gICAgICAgICAgICBcImJ1YmJsZVwiLCBcImJ1ZGR5XCIsIFwiYnVkZ2V0XCIsIFwiYnVmZmFsb1wiLCBcImJ1aWxkXCIsIFwiYnVsYlwiLFxuICAgICAgICAgICAgXCJidWxrXCIsIFwiYnVsbGV0XCIsIFwiYnVuZGxlXCIsIFwiYnVua2VyXCIsIFwiYnVyZGVuXCIsIFwiYnVyZ2VyXCIsXG4gICAgICAgICAgICBcImJ1cnN0XCIsIFwiYnVzXCIsIFwiYnVzaW5lc3NcIiwgXCJidXN5XCIsIFwiYnV0dGVyXCIsIFwiYnV5ZXJcIixcbiAgICAgICAgICAgIFwiYnV6elwiLCBcImNhYmJhZ2VcIiwgXCJjYWJpblwiLCBcImNhYmxlXCIsIFwiY2FjdHVzXCIsIFwiY2FnZVwiLFxuICAgICAgICAgICAgXCJjYWtlXCIsIFwiY2FsbFwiLCBcImNhbG1cIiwgXCJjYW1lcmFcIiwgXCJjYW1wXCIsIFwiY2FuXCIsXG4gICAgICAgICAgICBcImNhbmFsXCIsIFwiY2FuY2VsXCIsIFwiY2FuZHlcIiwgXCJjYW5ub25cIiwgXCJjYW5vZVwiLCBcImNhbnZhc1wiLFxuICAgICAgICAgICAgXCJjYW55b25cIiwgXCJjYXBhYmxlXCIsIFwiY2FwaXRhbFwiLCBcImNhcHRhaW5cIiwgXCJjYXJcIiwgXCJjYXJib25cIixcbiAgICAgICAgICAgIFwiY2FyZFwiLCBcImNhcmdvXCIsIFwiY2FycGV0XCIsIFwiY2FycnlcIiwgXCJjYXJ0XCIsIFwiY2FzZVwiLFxuICAgICAgICAgICAgXCJjYXNoXCIsIFwiY2FzaW5vXCIsIFwiY2FzdGxlXCIsIFwiY2FzdWFsXCIsIFwiY2F0XCIsIFwiY2F0YWxvZ1wiLFxuICAgICAgICAgICAgXCJjYXRjaFwiLCBcImNhdGVnb3J5XCIsIFwiY2F0dGxlXCIsIFwiY2F1Z2h0XCIsIFwiY2F1c2VcIiwgXCJjYXV0aW9uXCIsXG4gICAgICAgICAgICBcImNhdmVcIiwgXCJjZWlsaW5nXCIsIFwiY2VsZXJ5XCIsIFwiY2VtZW50XCIsIFwiY2Vuc3VzXCIsIFwiY2VudHVyeVwiLFxuICAgICAgICAgICAgXCJjZXJlYWxcIiwgXCJjZXJ0YWluXCIsIFwiY2hhaXJcIiwgXCJjaGFsa1wiLCBcImNoYW1waW9uXCIsIFwiY2hhbmdlXCIsXG4gICAgICAgICAgICBcImNoYW9zXCIsIFwiY2hhcHRlclwiLCBcImNoYXJnZVwiLCBcImNoYXNlXCIsIFwiY2hhdFwiLCBcImNoZWFwXCIsXG4gICAgICAgICAgICBcImNoZWNrXCIsIFwiY2hlZXNlXCIsIFwiY2hlZlwiLCBcImNoZXJyeVwiLCBcImNoZXN0XCIsIFwiY2hpY2tlblwiLFxuICAgICAgICAgICAgXCJjaGllZlwiLCBcImNoaWxkXCIsIFwiY2hpbW5leVwiLCBcImNob2ljZVwiLCBcImNob29zZVwiLCBcImNocm9uaWNcIixcbiAgICAgICAgICAgIFwiY2h1Y2tsZVwiLCBcImNodW5rXCIsIFwiY2h1cm5cIiwgXCJjaWdhclwiLCBcImNpbm5hbW9uXCIsIFwiY2lyY2xlXCIsXG4gICAgICAgICAgICBcImNpdGl6ZW5cIiwgXCJjaXR5XCIsIFwiY2l2aWxcIiwgXCJjbGFpbVwiLCBcImNsYXBcIiwgXCJjbGFyaWZ5XCIsXG4gICAgICAgICAgICBcImNsYXdcIiwgXCJjbGF5XCIsIFwiY2xlYW5cIiwgXCJjbGVya1wiLCBcImNsZXZlclwiLCBcImNsaWNrXCIsXG4gICAgICAgICAgICBcImNsaWVudFwiLCBcImNsaWZmXCIsIFwiY2xpbWJcIiwgXCJjbGluaWNcIiwgXCJjbGlwXCIsIFwiY2xvY2tcIixcbiAgICAgICAgICAgIFwiY2xvZ1wiLCBcImNsb3NlXCIsIFwiY2xvdGhcIiwgXCJjbG91ZFwiLCBcImNsb3duXCIsIFwiY2x1YlwiLFxuICAgICAgICAgICAgXCJjbHVtcFwiLCBcImNsdXN0ZXJcIiwgXCJjbHV0Y2hcIiwgXCJjb2FjaFwiLCBcImNvYXN0XCIsIFwiY29jb251dFwiLFxuICAgICAgICAgICAgXCJjb2RlXCIsIFwiY29mZmVlXCIsIFwiY29pbFwiLCBcImNvaW5cIiwgXCJjb2xsZWN0XCIsIFwiY29sb3JcIixcbiAgICAgICAgICAgIFwiY29sdW1uXCIsIFwiY29tYmluZVwiLCBcImNvbWVcIiwgXCJjb21mb3J0XCIsIFwiY29taWNcIiwgXCJjb21tb25cIixcbiAgICAgICAgICAgIFwiY29tcGFueVwiLCBcImNvbmNlcnRcIiwgXCJjb25kdWN0XCIsIFwiY29uZmlybVwiLCBcImNvbmdyZXNzXCIsIFwiY29ubmVjdFwiLFxuICAgICAgICAgICAgXCJjb25zaWRlclwiLCBcImNvbnRyb2xcIiwgXCJjb252aW5jZVwiLCBcImNvb2tcIiwgXCJjb29sXCIsIFwiY29wcGVyXCIsXG4gICAgICAgICAgICBcImNvcHlcIiwgXCJjb3JhbFwiLCBcImNvcmVcIiwgXCJjb3JuXCIsIFwiY29ycmVjdFwiLCBcImNvc3RcIixcbiAgICAgICAgICAgIFwiY290dG9uXCIsIFwiY291Y2hcIiwgXCJjb3VudHJ5XCIsIFwiY291cGxlXCIsIFwiY291cnNlXCIsIFwiY291c2luXCIsXG4gICAgICAgICAgICBcImNvdmVyXCIsIFwiY295b3RlXCIsIFwiY3JhY2tcIiwgXCJjcmFkbGVcIiwgXCJjcmFmdFwiLCBcImNyYW1cIixcbiAgICAgICAgICAgIFwiY3JhbmVcIiwgXCJjcmFzaFwiLCBcImNyYXRlclwiLCBcImNyYXdsXCIsIFwiY3JhenlcIiwgXCJjcmVhbVwiLFxuICAgICAgICAgICAgXCJjcmVkaXRcIiwgXCJjcmVla1wiLCBcImNyZXdcIiwgXCJjcmlja2V0XCIsIFwiY3JpbWVcIiwgXCJjcmlzcFwiLFxuICAgICAgICAgICAgXCJjcml0aWNcIiwgXCJjcm9wXCIsIFwiY3Jvc3NcIiwgXCJjcm91Y2hcIiwgXCJjcm93ZFwiLCBcImNydWNpYWxcIixcbiAgICAgICAgICAgIFwiY3J1ZWxcIiwgXCJjcnVpc2VcIiwgXCJjcnVtYmxlXCIsIFwiY3J1bmNoXCIsIFwiY3J1c2hcIiwgXCJjcnlcIixcbiAgICAgICAgICAgIFwiY3J5c3RhbFwiLCBcImN1YmVcIiwgXCJjdWx0dXJlXCIsIFwiY3VwXCIsIFwiY3VwYm9hcmRcIiwgXCJjdXJpb3VzXCIsXG4gICAgICAgICAgICBcImN1cnJlbnRcIiwgXCJjdXJ0YWluXCIsIFwiY3VydmVcIiwgXCJjdXNoaW9uXCIsIFwiY3VzdG9tXCIsIFwiY3V0ZVwiLFxuICAgICAgICAgICAgXCJjeWNsZVwiLCBcImRhZFwiLCBcImRhbWFnZVwiLCBcImRhbXBcIiwgXCJkYW5jZVwiLCBcImRhbmdlclwiLFxuICAgICAgICAgICAgXCJkYXJpbmdcIiwgXCJkYXNoXCIsIFwiZGF1Z2h0ZXJcIiwgXCJkYXduXCIsIFwiZGF5XCIsIFwiZGVhbFwiLFxuICAgICAgICAgICAgXCJkZWJhdGVcIiwgXCJkZWJyaXNcIiwgXCJkZWNhZGVcIiwgXCJkZWNlbWJlclwiLCBcImRlY2lkZVwiLCBcImRlY2xpbmVcIixcbiAgICAgICAgICAgIFwiZGVjb3JhdGVcIiwgXCJkZWNyZWFzZVwiLCBcImRlZXJcIiwgXCJkZWZlbnNlXCIsIFwiZGVmaW5lXCIsIFwiZGVmeVwiLFxuICAgICAgICAgICAgXCJkZWdyZWVcIiwgXCJkZWxheVwiLCBcImRlbGl2ZXJcIiwgXCJkZW1hbmRcIiwgXCJkZW1pc2VcIiwgXCJkZW5pYWxcIixcbiAgICAgICAgICAgIFwiZGVudGlzdFwiLCBcImRlbnlcIiwgXCJkZXBhcnRcIiwgXCJkZXBlbmRcIiwgXCJkZXBvc2l0XCIsIFwiZGVwdGhcIixcbiAgICAgICAgICAgIFwiZGVwdXR5XCIsIFwiZGVyaXZlXCIsIFwiZGVzY3JpYmVcIiwgXCJkZXNlcnRcIiwgXCJkZXNpZ25cIiwgXCJkZXNrXCIsXG4gICAgICAgICAgICBcImRlc3BhaXJcIiwgXCJkZXN0cm95XCIsIFwiZGV0YWlsXCIsIFwiZGV0ZWN0XCIsIFwiZGV2ZWxvcFwiLCBcImRldmljZVwiLFxuICAgICAgICAgICAgXCJkZXZvdGVcIiwgXCJkaWFncmFtXCIsIFwiZGlhbFwiLCBcImRpYW1vbmRcIiwgXCJkaWFyeVwiLCBcImRpY2VcIixcbiAgICAgICAgICAgIFwiZGllc2VsXCIsIFwiZGlldFwiLCBcImRpZmZlclwiLCBcImRpZ2l0YWxcIiwgXCJkaWduaXR5XCIsIFwiZGlsZW1tYVwiLFxuICAgICAgICAgICAgXCJkaW5uZXJcIiwgXCJkaW5vc2F1clwiLCBcImRpcmVjdFwiLCBcImRpcnRcIiwgXCJkaXNhZ3JlZVwiLCBcImRpc2NvdmVyXCIsXG4gICAgICAgICAgICBcImRpc2Vhc2VcIiwgXCJkaXNoXCIsIFwiZGlzbWlzc1wiLCBcImRpc29yZGVyXCIsIFwiZGlzcGxheVwiLCBcImRpc3RhbmNlXCIsXG4gICAgICAgICAgICBcImRpdmVydFwiLCBcImRpdmlkZVwiLCBcImRpdm9yY2VcIiwgXCJkaXp6eVwiLCBcImRvY3RvclwiLCBcImRvY3VtZW50XCIsXG4gICAgICAgICAgICBcImRvZ1wiLCBcImRvbGxcIiwgXCJkb2xwaGluXCIsIFwiZG9tYWluXCIsIFwiZG9uYXRlXCIsIFwiZG9ua2V5XCIsXG4gICAgICAgICAgICBcImRvbm9yXCIsIFwiZG9vclwiLCBcImRvc2VcIiwgXCJkb3VibGVcIiwgXCJkb3ZlXCIsIFwiZHJhZnRcIixcbiAgICAgICAgICAgIFwiZHJhZ29uXCIsIFwiZHJhbWFcIiwgXCJkcmFzdGljXCIsIFwiZHJhd1wiLCBcImRyZWFtXCIsIFwiZHJlc3NcIixcbiAgICAgICAgICAgIFwiZHJpZnRcIiwgXCJkcmlsbFwiLCBcImRyaW5rXCIsIFwiZHJpcFwiLCBcImRyaXZlXCIsIFwiZHJvcFwiLFxuICAgICAgICAgICAgXCJkcnVtXCIsIFwiZHJ5XCIsIFwiZHVja1wiLCBcImR1bWJcIiwgXCJkdW5lXCIsIFwiZHVyaW5nXCIsXG4gICAgICAgICAgICBcImR1c3RcIiwgXCJkdXRjaFwiLCBcImR1dHlcIiwgXCJkd2FyZlwiLCBcImR5bmFtaWNcIiwgXCJlYWdlclwiLFxuICAgICAgICAgICAgXCJlYWdsZVwiLCBcImVhcmx5XCIsIFwiZWFyblwiLCBcImVhcnRoXCIsIFwiZWFzaWx5XCIsIFwiZWFzdFwiLFxuICAgICAgICAgICAgXCJlYXN5XCIsIFwiZWNob1wiLCBcImVjb2xvZ3lcIiwgXCJlY29ub215XCIsIFwiZWRnZVwiLCBcImVkaXRcIixcbiAgICAgICAgICAgIFwiZWR1Y2F0ZVwiLCBcImVmZm9ydFwiLCBcImVnZ1wiLCBcImVpZ2h0XCIsIFwiZWl0aGVyXCIsIFwiZWxib3dcIixcbiAgICAgICAgICAgIFwiZWxkZXJcIiwgXCJlbGVjdHJpY1wiLCBcImVsZWdhbnRcIiwgXCJlbGVtZW50XCIsIFwiZWxlcGhhbnRcIiwgXCJlbGV2YXRvclwiLFxuICAgICAgICAgICAgXCJlbGl0ZVwiLCBcImVsc2VcIiwgXCJlbWJhcmtcIiwgXCJlbWJvZHlcIiwgXCJlbWJyYWNlXCIsIFwiZW1lcmdlXCIsXG4gICAgICAgICAgICBcImVtb3Rpb25cIiwgXCJlbXBsb3lcIiwgXCJlbXBvd2VyXCIsIFwiZW1wdHlcIiwgXCJlbmFibGVcIiwgXCJlbmFjdFwiLFxuICAgICAgICAgICAgXCJlbmRcIiwgXCJlbmRsZXNzXCIsIFwiZW5kb3JzZVwiLCBcImVuZW15XCIsIFwiZW5lcmd5XCIsIFwiZW5mb3JjZVwiLFxuICAgICAgICAgICAgXCJlbmdhZ2VcIiwgXCJlbmdpbmVcIiwgXCJlbmhhbmNlXCIsIFwiZW5qb3lcIiwgXCJlbmxpc3RcIiwgXCJlbm91Z2hcIixcbiAgICAgICAgICAgIFwiZW5yaWNoXCIsIFwiZW5yb2xsXCIsIFwiZW5zdXJlXCIsIFwiZW50ZXJcIiwgXCJlbnRpcmVcIiwgXCJlbnRyeVwiLFxuICAgICAgICAgICAgXCJlbnZlbG9wZVwiLCBcImVwaXNvZGVcIiwgXCJlcXVhbFwiLCBcImVxdWlwXCIsIFwiZXJhXCIsIFwiZXJhc2VcIixcbiAgICAgICAgICAgIFwiZXJvZGVcIiwgXCJlcm9zaW9uXCIsIFwiZXJyb3JcIiwgXCJlcnVwdFwiLCBcImVzY2FwZVwiLCBcImVzc2F5XCIsXG4gICAgICAgICAgICBcImVzc2VuY2VcIiwgXCJlc3RhdGVcIiwgXCJldGVybmFsXCIsIFwiZXRoaWNzXCIsIFwiZXZpZGVuY2VcIiwgXCJldmlsXCIsXG4gICAgICAgICAgICBcImV2b2tlXCIsIFwiZXZvbHZlXCIsIFwiZXhhY3RcIiwgXCJleGFtcGxlXCIsIFwiZXhjZXNzXCIsIFwiZXhjaGFuZ2VcIixcbiAgICAgICAgICAgIFwiZXhjaXRlXCIsIFwiZXhjbHVkZVwiLCBcImV4Y3VzZVwiLCBcImV4ZWN1dGVcIiwgXCJleGVyY2lzZVwiLCBcImV4aGF1c3RcIixcbiAgICAgICAgICAgIFwiZXhoaWJpdFwiLCBcImV4aWxlXCIsIFwiZXhpc3RcIiwgXCJleGl0XCIsIFwiZXhvdGljXCIsIFwiZXhwYW5kXCIsXG4gICAgICAgICAgICBcImV4cGVjdFwiLCBcImV4cGlyZVwiLCBcImV4cGxhaW5cIiwgXCJleHBvc2VcIiwgXCJleHByZXNzXCIsIFwiZXh0ZW5kXCIsXG4gICAgICAgICAgICBcImV4dHJhXCIsIFwiZXllXCIsIFwiZXllYnJvd1wiLCBcImZhYnJpY1wiLCBcImZhY2VcIiwgXCJmYWN1bHR5XCIsXG4gICAgICAgICAgICBcImZhZGVcIiwgXCJmYWludFwiLCBcImZhaXRoXCIsIFwiZmFsbFwiLCBcImZhbHNlXCIsIFwiZmFtZVwiLFxuICAgICAgICAgICAgXCJmYW1pbHlcIiwgXCJmYW1vdXNcIiwgXCJmYW5cIiwgXCJmYW5jeVwiLCBcImZhbnRhc3lcIiwgXCJmYXJtXCIsXG4gICAgICAgICAgICBcImZhc2hpb25cIiwgXCJmYXRcIiwgXCJmYXRhbFwiLCBcImZhdGhlclwiLCBcImZhdGlndWVcIiwgXCJmYXVsdFwiLFxuICAgICAgICAgICAgXCJmYXZvcml0ZVwiLCBcImZlYXR1cmVcIiwgXCJmZWJydWFyeVwiLCBcImZlZGVyYWxcIiwgXCJmZWVcIiwgXCJmZWVkXCIsXG4gICAgICAgICAgICBcImZlZWxcIiwgXCJmZW1hbGVcIiwgXCJmZW5jZVwiLCBcImZlc3RpdmFsXCIsIFwiZmV0Y2hcIiwgXCJmZXZlclwiLFxuICAgICAgICAgICAgXCJmZXdcIiwgXCJmaWJlclwiLCBcImZpY3Rpb25cIiwgXCJmaWVsZFwiLCBcImZpZ3VyZVwiLCBcImZpbGVcIixcbiAgICAgICAgICAgIFwiZmlsbVwiLCBcImZpbHRlclwiLCBcImZpbmFsXCIsIFwiZmluZFwiLCBcImZpbmVcIiwgXCJmaW5nZXJcIixcbiAgICAgICAgICAgIFwiZmluaXNoXCIsIFwiZmlyZVwiLCBcImZpcm1cIiwgXCJmaXJzdFwiLCBcImZpc2NhbFwiLCBcImZpc2hcIixcbiAgICAgICAgICAgIFwiZml0XCIsIFwiZml0bmVzc1wiLCBcImZpeFwiLCBcImZsYWdcIiwgXCJmbGFtZVwiLCBcImZsYXNoXCIsXG4gICAgICAgICAgICBcImZsYXRcIiwgXCJmbGF2b3JcIiwgXCJmbGVlXCIsIFwiZmxpZ2h0XCIsIFwiZmxpcFwiLCBcImZsb2F0XCIsXG4gICAgICAgICAgICBcImZsb2NrXCIsIFwiZmxvb3JcIiwgXCJmbG93ZXJcIiwgXCJmbHVpZFwiLCBcImZsdXNoXCIsIFwiZmx5XCIsXG4gICAgICAgICAgICBcImZvYW1cIiwgXCJmb2N1c1wiLCBcImZvZ1wiLCBcImZvaWxcIiwgXCJmb2xkXCIsIFwiZm9sbG93XCIsXG4gICAgICAgICAgICBcImZvb2RcIiwgXCJmb290XCIsIFwiZm9yY2VcIiwgXCJmb3Jlc3RcIiwgXCJmb3JnZXRcIiwgXCJmb3JrXCIsXG4gICAgICAgICAgICBcImZvcnR1bmVcIiwgXCJmb3J1bVwiLCBcImZvcndhcmRcIiwgXCJmb3NzaWxcIiwgXCJmb3N0ZXJcIiwgXCJmb3VuZFwiLFxuICAgICAgICAgICAgXCJmb3hcIiwgXCJmcmFnaWxlXCIsIFwiZnJhbWVcIiwgXCJmcmVxdWVudFwiLCBcImZyZXNoXCIsIFwiZnJpZW5kXCIsXG4gICAgICAgICAgICBcImZyaW5nZVwiLCBcImZyb2dcIiwgXCJmcm9udFwiLCBcImZyb3N0XCIsIFwiZnJvd25cIiwgXCJmcm96ZW5cIixcbiAgICAgICAgICAgIFwiZnJ1aXRcIiwgXCJmdWVsXCIsIFwiZnVuXCIsIFwiZnVubnlcIiwgXCJmdXJuYWNlXCIsIFwiZnVyeVwiLFxuICAgICAgICAgICAgXCJmdXR1cmVcIiwgXCJnYWRnZXRcIiwgXCJnYWluXCIsIFwiZ2FsYXh5XCIsIFwiZ2FsbGVyeVwiLCBcImdhbWVcIixcbiAgICAgICAgICAgIFwiZ2FwXCIsIFwiZ2FyYWdlXCIsIFwiZ2FyYmFnZVwiLCBcImdhcmRlblwiLCBcImdhcmxpY1wiLCBcImdhcm1lbnRcIixcbiAgICAgICAgICAgIFwiZ2FzXCIsIFwiZ2FzcFwiLCBcImdhdGVcIiwgXCJnYXRoZXJcIiwgXCJnYXVnZVwiLCBcImdhemVcIixcbiAgICAgICAgICAgIFwiZ2VuZXJhbFwiLCBcImdlbml1c1wiLCBcImdlbnJlXCIsIFwiZ2VudGxlXCIsIFwiZ2VudWluZVwiLCBcImdlc3R1cmVcIixcbiAgICAgICAgICAgIFwiZ2hvc3RcIiwgXCJnaWFudFwiLCBcImdpZnRcIiwgXCJnaWdnbGVcIiwgXCJnaW5nZXJcIiwgXCJnaXJhZmZlXCIsXG4gICAgICAgICAgICBcImdpcmxcIiwgXCJnaXZlXCIsIFwiZ2xhZFwiLCBcImdsYW5jZVwiLCBcImdsYXJlXCIsIFwiZ2xhc3NcIixcbiAgICAgICAgICAgIFwiZ2xpZGVcIiwgXCJnbGltcHNlXCIsIFwiZ2xvYmVcIiwgXCJnbG9vbVwiLCBcImdsb3J5XCIsIFwiZ2xvdmVcIixcbiAgICAgICAgICAgIFwiZ2xvd1wiLCBcImdsdWVcIiwgXCJnb2F0XCIsIFwiZ29kZGVzc1wiLCBcImdvbGRcIiwgXCJnb29kXCIsXG4gICAgICAgICAgICBcImdvb3NlXCIsIFwiZ29yaWxsYVwiLCBcImdvc3BlbFwiLCBcImdvc3NpcFwiLCBcImdvdmVyblwiLCBcImdvd25cIixcbiAgICAgICAgICAgIFwiZ3JhYlwiLCBcImdyYWNlXCIsIFwiZ3JhaW5cIiwgXCJncmFudFwiLCBcImdyYXBlXCIsIFwiZ3Jhc3NcIixcbiAgICAgICAgICAgIFwiZ3Jhdml0eVwiLCBcImdyZWF0XCIsIFwiZ3JlZW5cIiwgXCJncmlkXCIsIFwiZ3JpZWZcIiwgXCJncml0XCIsXG4gICAgICAgICAgICBcImdyb2NlcnlcIiwgXCJncm91cFwiLCBcImdyb3dcIiwgXCJncnVudFwiLCBcImd1YXJkXCIsIFwiZ3Vlc3NcIixcbiAgICAgICAgICAgIFwiZ3VpZGVcIiwgXCJndWlsdFwiLCBcImd1aXRhclwiLCBcImd1blwiLCBcImd5bVwiLCBcImhhYml0XCIsXG4gICAgICAgICAgICBcImhhaXJcIiwgXCJoYWxmXCIsIFwiaGFtbWVyXCIsIFwiaGFtc3RlclwiLCBcImhhbmRcIiwgXCJoYXBweVwiLFxuICAgICAgICAgICAgXCJoYXJib3JcIiwgXCJoYXJkXCIsIFwiaGFyc2hcIiwgXCJoYXJ2ZXN0XCIsIFwiaGF0XCIsIFwiaGF2ZVwiLFxuICAgICAgICAgICAgXCJoYXdrXCIsIFwiaGF6YXJkXCIsIFwiaGVhZFwiLCBcImhlYWx0aFwiLCBcImhlYXJ0XCIsIFwiaGVhdnlcIixcbiAgICAgICAgICAgIFwiaGVkZ2Vob2dcIiwgXCJoZWlnaHRcIiwgXCJoZWxsb1wiLCBcImhlbG1ldFwiLCBcImhlbHBcIiwgXCJoZW5cIixcbiAgICAgICAgICAgIFwiaGVyb1wiLCBcImhpZGRlblwiLCBcImhpZ2hcIiwgXCJoaWxsXCIsIFwiaGludFwiLCBcImhpcFwiLFxuICAgICAgICAgICAgXCJoaXJlXCIsIFwiaGlzdG9yeVwiLCBcImhvYmJ5XCIsIFwiaG9ja2V5XCIsIFwiaG9sZFwiLCBcImhvbGVcIixcbiAgICAgICAgICAgIFwiaG9saWRheVwiLCBcImhvbGxvd1wiLCBcImhvbWVcIiwgXCJob25leVwiLCBcImhvb2RcIiwgXCJob3BlXCIsXG4gICAgICAgICAgICBcImhvcm5cIiwgXCJob3Jyb3JcIiwgXCJob3JzZVwiLCBcImhvc3BpdGFsXCIsIFwiaG9zdFwiLCBcImhvdGVsXCIsXG4gICAgICAgICAgICBcImhvdXJcIiwgXCJob3ZlclwiLCBcImh1YlwiLCBcImh1Z2VcIiwgXCJodW1hblwiLCBcImh1bWJsZVwiLFxuICAgICAgICAgICAgXCJodW1vclwiLCBcImh1bmRyZWRcIiwgXCJodW5ncnlcIiwgXCJodW50XCIsIFwiaHVyZGxlXCIsIFwiaHVycnlcIixcbiAgICAgICAgICAgIFwiaHVydFwiLCBcImh1c2JhbmRcIiwgXCJoeWJyaWRcIiwgXCJpY2VcIiwgXCJpY29uXCIsIFwiaWRlYVwiLFxuICAgICAgICAgICAgXCJpZGVudGlmeVwiLCBcImlkbGVcIiwgXCJpZ25vcmVcIiwgXCJpbGxcIiwgXCJpbGxlZ2FsXCIsIFwiaWxsbmVzc1wiLFxuICAgICAgICAgICAgXCJpbWFnZVwiLCBcImltaXRhdGVcIiwgXCJpbW1lbnNlXCIsIFwiaW1tdW5lXCIsIFwiaW1wYWN0XCIsIFwiaW1wb3NlXCIsXG4gICAgICAgICAgICBcImltcHJvdmVcIiwgXCJpbXB1bHNlXCIsIFwiaW5jaFwiLCBcImluY2x1ZGVcIiwgXCJpbmNvbWVcIiwgXCJpbmNyZWFzZVwiLFxuICAgICAgICAgICAgXCJpbmRleFwiLCBcImluZGljYXRlXCIsIFwiaW5kb29yXCIsIFwiaW5kdXN0cnlcIiwgXCJpbmZhbnRcIiwgXCJpbmZsaWN0XCIsXG4gICAgICAgICAgICBcImluZm9ybVwiLCBcImluaGFsZVwiLCBcImluaGVyaXRcIiwgXCJpbml0aWFsXCIsIFwiaW5qZWN0XCIsIFwiaW5qdXJ5XCIsXG4gICAgICAgICAgICBcImlubWF0ZVwiLCBcImlubmVyXCIsIFwiaW5ub2NlbnRcIiwgXCJpbnB1dFwiLCBcImlucXVpcnlcIiwgXCJpbnNhbmVcIixcbiAgICAgICAgICAgIFwiaW5zZWN0XCIsIFwiaW5zaWRlXCIsIFwiaW5zcGlyZVwiLCBcImluc3RhbGxcIiwgXCJpbnRhY3RcIiwgXCJpbnRlcmVzdFwiLFxuICAgICAgICAgICAgXCJpbnRvXCIsIFwiaW52ZXN0XCIsIFwiaW52aXRlXCIsIFwiaW52b2x2ZVwiLCBcImlyb25cIiwgXCJpc2xhbmRcIixcbiAgICAgICAgICAgIFwiaXNvbGF0ZVwiLCBcImlzc3VlXCIsIFwiaXRlbVwiLCBcIml2b3J5XCIsIFwiamFja2V0XCIsIFwiamFndWFyXCIsXG4gICAgICAgICAgICBcImphclwiLCBcImphenpcIiwgXCJqZWFsb3VzXCIsIFwiamVhbnNcIiwgXCJqZWxseVwiLCBcImpld2VsXCIsXG4gICAgICAgICAgICBcImpvYlwiLCBcImpvaW5cIiwgXCJqb2tlXCIsIFwiam91cm5leVwiLCBcImpveVwiLCBcImp1ZGdlXCIsXG4gICAgICAgICAgICBcImp1aWNlXCIsIFwianVtcFwiLCBcImp1bmdsZVwiLCBcImp1bmlvclwiLCBcImp1bmtcIiwgXCJqdXN0XCIsXG4gICAgICAgICAgICBcImthbmdhcm9vXCIsIFwia2VlblwiLCBcImtlZXBcIiwgXCJrZXRjaHVwXCIsIFwia2V5XCIsIFwia2lja1wiLFxuICAgICAgICAgICAgXCJraWRcIiwgXCJraWRuZXlcIiwgXCJraW5kXCIsIFwia2luZ2RvbVwiLCBcImtpc3NcIiwgXCJraXRcIixcbiAgICAgICAgICAgIFwia2l0Y2hlblwiLCBcImtpdGVcIiwgXCJraXR0ZW5cIiwgXCJraXdpXCIsIFwia25lZVwiLCBcImtuaWZlXCIsXG4gICAgICAgICAgICBcImtub2NrXCIsIFwia25vd1wiLCBcImxhYlwiLCBcImxhYmVsXCIsIFwibGFib3JcIiwgXCJsYWRkZXJcIixcbiAgICAgICAgICAgIFwibGFkeVwiLCBcImxha2VcIiwgXCJsYW1wXCIsIFwibGFuZ3VhZ2VcIiwgXCJsYXB0b3BcIiwgXCJsYXJnZVwiLFxuICAgICAgICAgICAgXCJsYXRlclwiLCBcImxhdGluXCIsIFwibGF1Z2hcIiwgXCJsYXVuZHJ5XCIsIFwibGF2YVwiLCBcImxhd1wiLFxuICAgICAgICAgICAgXCJsYXduXCIsIFwibGF3c3VpdFwiLCBcImxheWVyXCIsIFwibGF6eVwiLCBcImxlYWRlclwiLCBcImxlYWZcIixcbiAgICAgICAgICAgIFwibGVhcm5cIiwgXCJsZWF2ZVwiLCBcImxlY3R1cmVcIiwgXCJsZWZ0XCIsIFwibGVnXCIsIFwibGVnYWxcIixcbiAgICAgICAgICAgIFwibGVnZW5kXCIsIFwibGVpc3VyZVwiLCBcImxlbW9uXCIsIFwibGVuZFwiLCBcImxlbmd0aFwiLCBcImxlbnNcIixcbiAgICAgICAgICAgIFwibGVvcGFyZFwiLCBcImxlc3NvblwiLCBcImxldHRlclwiLCBcImxldmVsXCIsIFwibGlhclwiLCBcImxpYmVydHlcIixcbiAgICAgICAgICAgIFwibGlicmFyeVwiLCBcImxpY2Vuc2VcIiwgXCJsaWZlXCIsIFwibGlmdFwiLCBcImxpZ2h0XCIsIFwibGlrZVwiLFxuICAgICAgICAgICAgXCJsaW1iXCIsIFwibGltaXRcIiwgXCJsaW5rXCIsIFwibGlvblwiLCBcImxpcXVpZFwiLCBcImxpc3RcIixcbiAgICAgICAgICAgIFwibGl0dGxlXCIsIFwibGl2ZVwiLCBcImxpemFyZFwiLCBcImxvYWRcIiwgXCJsb2FuXCIsIFwibG9ic3RlclwiLFxuICAgICAgICAgICAgXCJsb2NhbFwiLCBcImxvY2tcIiwgXCJsb2dpY1wiLCBcImxvbmVseVwiLCBcImxvbmdcIiwgXCJsb29wXCIsXG4gICAgICAgICAgICBcImxvdHRlcnlcIiwgXCJsb3VkXCIsIFwibG91bmdlXCIsIFwibG92ZVwiLCBcImxveWFsXCIsIFwibHVja3lcIixcbiAgICAgICAgICAgIFwibHVnZ2FnZVwiLCBcImx1bWJlclwiLCBcImx1bmFyXCIsIFwibHVuY2hcIiwgXCJsdXh1cnlcIiwgXCJseXJpY3NcIixcbiAgICAgICAgICAgIFwibWFjaGluZVwiLCBcIm1hZFwiLCBcIm1hZ2ljXCIsIFwibWFnbmV0XCIsIFwibWFpZFwiLCBcIm1haWxcIixcbiAgICAgICAgICAgIFwibWFpblwiLCBcIm1ham9yXCIsIFwibWFrZVwiLCBcIm1hbW1hbFwiLCBcIm1hblwiLCBcIm1hbmFnZVwiLFxuICAgICAgICAgICAgXCJtYW5kYXRlXCIsIFwibWFuZ29cIiwgXCJtYW5zaW9uXCIsIFwibWFudWFsXCIsIFwibWFwbGVcIiwgXCJtYXJibGVcIixcbiAgICAgICAgICAgIFwibWFyY2hcIiwgXCJtYXJnaW5cIiwgXCJtYXJpbmVcIiwgXCJtYXJrZXRcIiwgXCJtYXJyaWFnZVwiLCBcIm1hc2tcIixcbiAgICAgICAgICAgIFwibWFzc1wiLCBcIm1hc3RlclwiLCBcIm1hdGNoXCIsIFwibWF0ZXJpYWxcIiwgXCJtYXRoXCIsIFwibWF0cml4XCIsXG4gICAgICAgICAgICBcIm1hdHRlclwiLCBcIm1heGltdW1cIiwgXCJtYXplXCIsIFwibWVhZG93XCIsIFwibWVhblwiLCBcIm1lYXN1cmVcIixcbiAgICAgICAgICAgIFwibWVhdFwiLCBcIm1lY2hhbmljXCIsIFwibWVkYWxcIiwgXCJtZWRpYVwiLCBcIm1lbG9keVwiLCBcIm1lbHRcIixcbiAgICAgICAgICAgIFwibWVtYmVyXCIsIFwibWVtb3J5XCIsIFwibWVudGlvblwiLCBcIm1lbnVcIiwgXCJtZXJjeVwiLCBcIm1lcmdlXCIsXG4gICAgICAgICAgICBcIm1lcml0XCIsIFwibWVycnlcIiwgXCJtZXNoXCIsIFwibWVzc2FnZVwiLCBcIm1ldGFsXCIsIFwibWV0aG9kXCIsXG4gICAgICAgICAgICBcIm1pZGRsZVwiLCBcIm1pZG5pZ2h0XCIsIFwibWlsa1wiLCBcIm1pbGxpb25cIiwgXCJtaW1pY1wiLCBcIm1pbmRcIixcbiAgICAgICAgICAgIFwibWluaW11bVwiLCBcIm1pbm9yXCIsIFwibWludXRlXCIsIFwibWlyYWNsZVwiLCBcIm1pcnJvclwiLCBcIm1pc2VyeVwiLFxuICAgICAgICAgICAgXCJtaXNzXCIsIFwibWlzdGFrZVwiLCBcIm1peFwiLCBcIm1peGVkXCIsIFwibWl4dHVyZVwiLCBcIm1vYmlsZVwiLFxuICAgICAgICAgICAgXCJtb2RlbFwiLCBcIm1vZGlmeVwiLCBcIm1vbVwiLCBcIm1vbWVudFwiLCBcIm1vbml0b3JcIiwgXCJtb25rZXlcIixcbiAgICAgICAgICAgIFwibW9uc3RlclwiLCBcIm1vbnRoXCIsIFwibW9vblwiLCBcIm1vcmFsXCIsIFwibW9yZVwiLCBcIm1vcm5pbmdcIixcbiAgICAgICAgICAgIFwibW9zcXVpdG9cIiwgXCJtb3RoZXJcIiwgXCJtb3Rpb25cIiwgXCJtb3RvclwiLCBcIm1vdW50YWluXCIsIFwibW91c2VcIixcbiAgICAgICAgICAgIFwibW92ZVwiLCBcIm1vdmllXCIsIFwibXVjaFwiLCBcIm11ZmZpblwiLCBcIm11bGVcIiwgXCJtdWx0aXBseVwiLFxuICAgICAgICAgICAgXCJtdXNjbGVcIiwgXCJtdXNldW1cIiwgXCJtdXNocm9vbVwiLCBcIm11c2ljXCIsIFwibXVzdFwiLCBcIm11dHVhbFwiLFxuICAgICAgICAgICAgXCJteXNlbGZcIiwgXCJteXN0ZXJ5XCIsIFwibXl0aFwiLCBcIm5haXZlXCIsIFwibmFtZVwiLCBcIm5hcGtpblwiLFxuICAgICAgICAgICAgXCJuYXJyb3dcIiwgXCJuYXN0eVwiLCBcIm5hdGlvblwiLCBcIm5hdHVyZVwiLCBcIm5lYXJcIiwgXCJuZWNrXCIsXG4gICAgICAgICAgICBcIm5lZWRcIiwgXCJuZWdhdGl2ZVwiLCBcIm5lZ2xlY3RcIiwgXCJuZWl0aGVyXCIsIFwibmVwaGV3XCIsIFwibmVydmVcIixcbiAgICAgICAgICAgIFwibmVzdFwiLCBcIm5ldFwiLCBcIm5ldHdvcmtcIiwgXCJuZXV0cmFsXCIsIFwibmV2ZXJcIiwgXCJuZXdzXCIsXG4gICAgICAgICAgICBcIm5leHRcIiwgXCJuaWNlXCIsIFwibmlnaHRcIiwgXCJub2JsZVwiLCBcIm5vaXNlXCIsIFwibm9taW5lZVwiLFxuICAgICAgICAgICAgXCJub29kbGVcIiwgXCJub3JtYWxcIiwgXCJub3J0aFwiLCBcIm5vc2VcIiwgXCJub3RhYmxlXCIsIFwibm90ZVwiLFxuICAgICAgICAgICAgXCJub3RoaW5nXCIsIFwibm90aWNlXCIsIFwibm92ZWxcIiwgXCJub3dcIiwgXCJudWNsZWFyXCIsIFwibnVtYmVyXCIsXG4gICAgICAgICAgICBcIm51cnNlXCIsIFwibnV0XCIsIFwib2FrXCIsIFwib2JleVwiLCBcIm9iamVjdFwiLCBcIm9ibGlnZVwiLFxuICAgICAgICAgICAgXCJvYnNjdXJlXCIsIFwib2JzZXJ2ZVwiLCBcIm9idGFpblwiLCBcIm9idmlvdXNcIiwgXCJvY2N1clwiLCBcIm9jZWFuXCIsXG4gICAgICAgICAgICBcIm9jdG9iZXJcIiwgXCJvZG9yXCIsIFwib2ZmXCIsIFwib2ZmZXJcIiwgXCJvZmZpY2VcIiwgXCJvZnRlblwiLFxuICAgICAgICAgICAgXCJvaWxcIiwgXCJva2F5XCIsIFwib2xkXCIsIFwib2xpdmVcIiwgXCJvbHltcGljXCIsIFwib21pdFwiLFxuICAgICAgICAgICAgXCJvbmNlXCIsIFwib25lXCIsIFwib25pb25cIiwgXCJvbmxpbmVcIiwgXCJvbmx5XCIsIFwib3BlblwiLFxuICAgICAgICAgICAgXCJvcGVyYVwiLCBcIm9waW5pb25cIiwgXCJvcHBvc2VcIiwgXCJvcHRpb25cIiwgXCJvcmFuZ2VcIiwgXCJvcmJpdFwiLFxuICAgICAgICAgICAgXCJvcmNoYXJkXCIsIFwib3JkZXJcIiwgXCJvcmRpbmFyeVwiLCBcIm9yZ2FuXCIsIFwib3JpZW50XCIsIFwib3JpZ2luYWxcIixcbiAgICAgICAgICAgIFwib3JwaGFuXCIsIFwib3N0cmljaFwiLCBcIm90aGVyXCIsIFwib3V0ZG9vclwiLCBcIm91dGVyXCIsIFwib3V0cHV0XCIsXG4gICAgICAgICAgICBcIm91dHNpZGVcIiwgXCJvdmFsXCIsIFwib3ZlblwiLCBcIm92ZXJcIiwgXCJvd25cIiwgXCJvd25lclwiLFxuICAgICAgICAgICAgXCJveHlnZW5cIiwgXCJveXN0ZXJcIiwgXCJvem9uZVwiLCBcInBhY3RcIiwgXCJwYWRkbGVcIiwgXCJwYWdlXCIsXG4gICAgICAgICAgICBcInBhaXJcIiwgXCJwYWxhY2VcIiwgXCJwYWxtXCIsIFwicGFuZGFcIiwgXCJwYW5lbFwiLCBcInBhbmljXCIsXG4gICAgICAgICAgICBcInBhbnRoZXJcIiwgXCJwYXBlclwiLCBcInBhcmFkZVwiLCBcInBhcmVudFwiLCBcInBhcmtcIiwgXCJwYXJyb3RcIixcbiAgICAgICAgICAgIFwicGFydHlcIiwgXCJwYXNzXCIsIFwicGF0Y2hcIiwgXCJwYXRoXCIsIFwicGF0aWVudFwiLCBcInBhdHJvbFwiLFxuICAgICAgICAgICAgXCJwYXR0ZXJuXCIsIFwicGF1c2VcIiwgXCJwYXZlXCIsIFwicGF5bWVudFwiLCBcInBlYWNlXCIsIFwicGVhbnV0XCIsXG4gICAgICAgICAgICBcInBlYXJcIiwgXCJwZWFzYW50XCIsIFwicGVsaWNhblwiLCBcInBlblwiLCBcInBlbmFsdHlcIiwgXCJwZW5jaWxcIixcbiAgICAgICAgICAgIFwicGVvcGxlXCIsIFwicGVwcGVyXCIsIFwicGVyZmVjdFwiLCBcInBlcm1pdFwiLCBcInBlcnNvblwiLCBcInBldFwiLFxuICAgICAgICAgICAgXCJwaG9uZVwiLCBcInBob3RvXCIsIFwicGhyYXNlXCIsIFwicGh5c2ljYWxcIiwgXCJwaWFub1wiLCBcInBpY25pY1wiLFxuICAgICAgICAgICAgXCJwaWN0dXJlXCIsIFwicGllY2VcIiwgXCJwaWdcIiwgXCJwaWdlb25cIiwgXCJwaWxsXCIsIFwicGlsb3RcIixcbiAgICAgICAgICAgIFwicGlua1wiLCBcInBpb25lZXJcIiwgXCJwaXBlXCIsIFwicGlzdG9sXCIsIFwicGl0Y2hcIiwgXCJwaXp6YVwiLFxuICAgICAgICAgICAgXCJwbGFjZVwiLCBcInBsYW5ldFwiLCBcInBsYXN0aWNcIiwgXCJwbGF0ZVwiLCBcInBsYXlcIiwgXCJwbGVhc2VcIixcbiAgICAgICAgICAgIFwicGxlZGdlXCIsIFwicGx1Y2tcIiwgXCJwbHVnXCIsIFwicGx1bmdlXCIsIFwicG9lbVwiLCBcInBvZXRcIixcbiAgICAgICAgICAgIFwicG9pbnRcIiwgXCJwb2xhclwiLCBcInBvbGVcIiwgXCJwb2xpY2VcIiwgXCJwb25kXCIsIFwicG9ueVwiLFxuICAgICAgICAgICAgXCJwb29sXCIsIFwicG9wdWxhclwiLCBcInBvcnRpb25cIiwgXCJwb3NpdGlvblwiLCBcInBvc3NpYmxlXCIsIFwicG9zdFwiLFxuICAgICAgICAgICAgXCJwb3RhdG9cIiwgXCJwb3R0ZXJ5XCIsIFwicG92ZXJ0eVwiLCBcInBvd2RlclwiLCBcInBvd2VyXCIsIFwicHJhY3RpY2VcIixcbiAgICAgICAgICAgIFwicHJhaXNlXCIsIFwicHJlZGljdFwiLCBcInByZWZlclwiLCBcInByZXBhcmVcIiwgXCJwcmVzZW50XCIsIFwicHJldHR5XCIsXG4gICAgICAgICAgICBcInByZXZlbnRcIiwgXCJwcmljZVwiLCBcInByaWRlXCIsIFwicHJpbWFyeVwiLCBcInByaW50XCIsIFwicHJpb3JpdHlcIixcbiAgICAgICAgICAgIFwicHJpc29uXCIsIFwicHJpdmF0ZVwiLCBcInByaXplXCIsIFwicHJvYmxlbVwiLCBcInByb2Nlc3NcIiwgXCJwcm9kdWNlXCIsXG4gICAgICAgICAgICBcInByb2ZpdFwiLCBcInByb2dyYW1cIiwgXCJwcm9qZWN0XCIsIFwicHJvbW90ZVwiLCBcInByb29mXCIsIFwicHJvcGVydHlcIixcbiAgICAgICAgICAgIFwicHJvc3BlclwiLCBcInByb3RlY3RcIiwgXCJwcm91ZFwiLCBcInByb3ZpZGVcIiwgXCJwdWJsaWNcIiwgXCJwdWRkaW5nXCIsXG4gICAgICAgICAgICBcInB1bGxcIiwgXCJwdWxwXCIsIFwicHVsc2VcIiwgXCJwdW1wa2luXCIsIFwicHVuY2hcIiwgXCJwdXBpbFwiLFxuICAgICAgICAgICAgXCJwdXBweVwiLCBcInB1cmNoYXNlXCIsIFwicHVyaXR5XCIsIFwicHVycG9zZVwiLCBcInB1cnNlXCIsIFwicHVzaFwiLFxuICAgICAgICAgICAgXCJwdXRcIiwgXCJwdXp6bGVcIiwgXCJweXJhbWlkXCIsIFwicXVhbGl0eVwiLCBcInF1YW50dW1cIiwgXCJxdWFydGVyXCIsXG4gICAgICAgICAgICBcInF1ZXN0aW9uXCIsIFwicXVpY2tcIiwgXCJxdWl0XCIsIFwicXVpelwiLCBcInF1b3RlXCIsIFwicmFiYml0XCIsXG4gICAgICAgICAgICBcInJhY2Nvb25cIiwgXCJyYWNlXCIsIFwicmFja1wiLCBcInJhZGFyXCIsIFwicmFkaW9cIiwgXCJyYWlsXCIsXG4gICAgICAgICAgICBcInJhaW5cIiwgXCJyYWlzZVwiLCBcInJhbGx5XCIsIFwicmFtcFwiLCBcInJhbmNoXCIsIFwicmFuZG9tXCIsXG4gICAgICAgICAgICBcInJhbmdlXCIsIFwicmFwaWRcIiwgXCJyYXJlXCIsIFwicmF0ZVwiLCBcInJhdGhlclwiLCBcInJhdmVuXCIsXG4gICAgICAgICAgICBcInJhd1wiLCBcInJhem9yXCIsIFwicmVhZHlcIiwgXCJyZWFsXCIsIFwicmVhc29uXCIsIFwicmViZWxcIixcbiAgICAgICAgICAgIFwicmVidWlsZFwiLCBcInJlY2FsbFwiLCBcInJlY2VpdmVcIiwgXCJyZWNpcGVcIiwgXCJyZWNvcmRcIiwgXCJyZWN5Y2xlXCIsXG4gICAgICAgICAgICBcInJlZHVjZVwiLCBcInJlZmxlY3RcIiwgXCJyZWZvcm1cIiwgXCJyZWZ1c2VcIiwgXCJyZWdpb25cIiwgXCJyZWdyZXRcIixcbiAgICAgICAgICAgIFwicmVndWxhclwiLCBcInJlamVjdFwiLCBcInJlbGF4XCIsIFwicmVsZWFzZVwiLCBcInJlbGllZlwiLCBcInJlbHlcIixcbiAgICAgICAgICAgIFwicmVtYWluXCIsIFwicmVtZW1iZXJcIiwgXCJyZW1pbmRcIiwgXCJyZW1vdmVcIiwgXCJyZW5kZXJcIiwgXCJyZW5ld1wiLFxuICAgICAgICAgICAgXCJyZW50XCIsIFwicmVvcGVuXCIsIFwicmVwYWlyXCIsIFwicmVwZWF0XCIsIFwicmVwbGFjZVwiLCBcInJlcG9ydFwiLFxuICAgICAgICAgICAgXCJyZXF1aXJlXCIsIFwicmVzY3VlXCIsIFwicmVzZW1ibGVcIiwgXCJyZXNpc3RcIiwgXCJyZXNvdXJjZVwiLCBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICBcInJlc3VsdFwiLCBcInJldGlyZVwiLCBcInJldHJlYXRcIiwgXCJyZXR1cm5cIiwgXCJyZXVuaW9uXCIsIFwicmV2ZWFsXCIsXG4gICAgICAgICAgICBcInJldmlld1wiLCBcInJld2FyZFwiLCBcInJoeXRobVwiLCBcInJpYlwiLCBcInJpYmJvblwiLCBcInJpY2VcIixcbiAgICAgICAgICAgIFwicmljaFwiLCBcInJpZGVcIiwgXCJyaWRnZVwiLCBcInJpZmxlXCIsIFwicmlnaHRcIiwgXCJyaWdpZFwiLFxuICAgICAgICAgICAgXCJyaW5nXCIsIFwicmlvdFwiLCBcInJpcHBsZVwiLCBcInJpc2tcIiwgXCJyaXR1YWxcIiwgXCJyaXZhbFwiLFxuICAgICAgICAgICAgXCJyaXZlclwiLCBcInJvYWRcIiwgXCJyb2FzdFwiLCBcInJvYm90XCIsIFwicm9idXN0XCIsIFwicm9ja2V0XCIsXG4gICAgICAgICAgICBcInJvbWFuY2VcIiwgXCJyb29mXCIsIFwicm9va2llXCIsIFwicm9vbVwiLCBcInJvc2VcIiwgXCJyb3RhdGVcIixcbiAgICAgICAgICAgIFwicm91Z2hcIiwgXCJyb3VuZFwiLCBcInJvdXRlXCIsIFwicm95YWxcIiwgXCJydWJiZXJcIiwgXCJydWRlXCIsXG4gICAgICAgICAgICBcInJ1Z1wiLCBcInJ1bGVcIiwgXCJydW5cIiwgXCJydW53YXlcIiwgXCJydXJhbFwiLCBcInNhZFwiLFxuICAgICAgICAgICAgXCJzYWRkbGVcIiwgXCJzYWRuZXNzXCIsIFwic2FmZVwiLCBcInNhaWxcIiwgXCJzYWxhZFwiLCBcInNhbG1vblwiLFxuICAgICAgICAgICAgXCJzYWxvblwiLCBcInNhbHRcIiwgXCJzYWx1dGVcIiwgXCJzYW1lXCIsIFwic2FtcGxlXCIsIFwic2FuZFwiLFxuICAgICAgICAgICAgXCJzYXRpc2Z5XCIsIFwic2F0b3NoaVwiLCBcInNhdWNlXCIsIFwic2F1c2FnZVwiLCBcInNhdmVcIiwgXCJzYXlcIixcbiAgICAgICAgICAgIFwic2NhbGVcIiwgXCJzY2FuXCIsIFwic2NhcmVcIiwgXCJzY2F0dGVyXCIsIFwic2NlbmVcIiwgXCJzY2hlbWVcIixcbiAgICAgICAgICAgIFwic2Nob29sXCIsIFwic2NpZW5jZVwiLCBcInNjaXNzb3JzXCIsIFwic2NvcnBpb25cIiwgXCJzY291dFwiLCBcInNjcmFwXCIsXG4gICAgICAgICAgICBcInNjcmVlblwiLCBcInNjcmlwdFwiLCBcInNjcnViXCIsIFwic2VhXCIsIFwic2VhcmNoXCIsIFwic2Vhc29uXCIsXG4gICAgICAgICAgICBcInNlYXRcIiwgXCJzZWNvbmRcIiwgXCJzZWNyZXRcIiwgXCJzZWN0aW9uXCIsIFwic2VjdXJpdHlcIiwgXCJzZWVkXCIsXG4gICAgICAgICAgICBcInNlZWtcIiwgXCJzZWdtZW50XCIsIFwic2VsZWN0XCIsIFwic2VsbFwiLCBcInNlbWluYXJcIiwgXCJzZW5pb3JcIixcbiAgICAgICAgICAgIFwic2Vuc2VcIiwgXCJzZW50ZW5jZVwiLCBcInNlcmllc1wiLCBcInNlcnZpY2VcIiwgXCJzZXNzaW9uXCIsIFwic2V0dGxlXCIsXG4gICAgICAgICAgICBcInNldHVwXCIsIFwic2V2ZW5cIiwgXCJzaGFkb3dcIiwgXCJzaGFmdFwiLCBcInNoYWxsb3dcIiwgXCJzaGFyZVwiLFxuICAgICAgICAgICAgXCJzaGVkXCIsIFwic2hlbGxcIiwgXCJzaGVyaWZmXCIsIFwic2hpZWxkXCIsIFwic2hpZnRcIiwgXCJzaGluZVwiLFxuICAgICAgICAgICAgXCJzaGlwXCIsIFwic2hpdmVyXCIsIFwic2hvY2tcIiwgXCJzaG9lXCIsIFwic2hvb3RcIiwgXCJzaG9wXCIsXG4gICAgICAgICAgICBcInNob3J0XCIsIFwic2hvdWxkZXJcIiwgXCJzaG92ZVwiLCBcInNocmltcFwiLCBcInNocnVnXCIsIFwic2h1ZmZsZVwiLFxuICAgICAgICAgICAgXCJzaHlcIiwgXCJzaWJsaW5nXCIsIFwic2lja1wiLCBcInNpZGVcIiwgXCJzaWVnZVwiLCBcInNpZ2h0XCIsXG4gICAgICAgICAgICBcInNpZ25cIiwgXCJzaWxlbnRcIiwgXCJzaWxrXCIsIFwic2lsbHlcIiwgXCJzaWx2ZXJcIiwgXCJzaW1pbGFyXCIsXG4gICAgICAgICAgICBcInNpbXBsZVwiLCBcInNpbmNlXCIsIFwic2luZ1wiLCBcInNpcmVuXCIsIFwic2lzdGVyXCIsIFwic2l0dWF0ZVwiLFxuICAgICAgICAgICAgXCJzaXhcIiwgXCJzaXplXCIsIFwic2thdGVcIiwgXCJza2V0Y2hcIiwgXCJza2lcIiwgXCJza2lsbFwiLFxuICAgICAgICAgICAgXCJza2luXCIsIFwic2tpcnRcIiwgXCJza3VsbFwiLCBcInNsYWJcIiwgXCJzbGFtXCIsIFwic2xlZXBcIixcbiAgICAgICAgICAgIFwic2xlbmRlclwiLCBcInNsaWNlXCIsIFwic2xpZGVcIiwgXCJzbGlnaHRcIiwgXCJzbGltXCIsIFwic2xvZ2FuXCIsXG4gICAgICAgICAgICBcInNsb3RcIiwgXCJzbG93XCIsIFwic2x1c2hcIiwgXCJzbWFsbFwiLCBcInNtYXJ0XCIsIFwic21pbGVcIixcbiAgICAgICAgICAgIFwic21va2VcIiwgXCJzbW9vdGhcIiwgXCJzbmFja1wiLCBcInNuYWtlXCIsIFwic25hcFwiLCBcInNuaWZmXCIsXG4gICAgICAgICAgICBcInNub3dcIiwgXCJzb2FwXCIsIFwic29jY2VyXCIsIFwic29jaWFsXCIsIFwic29ja1wiLCBcInNvZGFcIixcbiAgICAgICAgICAgIFwic29mdFwiLCBcInNvbGFyXCIsIFwic29sZGllclwiLCBcInNvbGlkXCIsIFwic29sdXRpb25cIiwgXCJzb2x2ZVwiLFxuICAgICAgICAgICAgXCJzb21lb25lXCIsIFwic29uZ1wiLCBcInNvb25cIiwgXCJzb3JyeVwiLCBcInNvcnRcIiwgXCJzb3VsXCIsXG4gICAgICAgICAgICBcInNvdW5kXCIsIFwic291cFwiLCBcInNvdXJjZVwiLCBcInNvdXRoXCIsIFwic3BhY2VcIiwgXCJzcGFyZVwiLFxuICAgICAgICAgICAgXCJzcGF0aWFsXCIsIFwic3Bhd25cIiwgXCJzcGVha1wiLCBcInNwZWNpYWxcIiwgXCJzcGVlZFwiLCBcInNwZWxsXCIsXG4gICAgICAgICAgICBcInNwZW5kXCIsIFwic3BoZXJlXCIsIFwic3BpY2VcIiwgXCJzcGlkZXJcIiwgXCJzcGlrZVwiLCBcInNwaW5cIixcbiAgICAgICAgICAgIFwic3Bpcml0XCIsIFwic3BsaXRcIiwgXCJzcG9pbFwiLCBcInNwb25zb3JcIiwgXCJzcG9vblwiLCBcInNwb3J0XCIsXG4gICAgICAgICAgICBcInNwb3RcIiwgXCJzcHJheVwiLCBcInNwcmVhZFwiLCBcInNwcmluZ1wiLCBcInNweVwiLCBcInNxdWFyZVwiLFxuICAgICAgICAgICAgXCJzcXVlZXplXCIsIFwic3F1aXJyZWxcIiwgXCJzdGFibGVcIiwgXCJzdGFkaXVtXCIsIFwic3RhZmZcIiwgXCJzdGFnZVwiLFxuICAgICAgICAgICAgXCJzdGFpcnNcIiwgXCJzdGFtcFwiLCBcInN0YW5kXCIsIFwic3RhcnRcIiwgXCJzdGF0ZVwiLCBcInN0YXlcIixcbiAgICAgICAgICAgIFwic3RlYWtcIiwgXCJzdGVlbFwiLCBcInN0ZW1cIiwgXCJzdGVwXCIsIFwic3RlcmVvXCIsIFwic3RpY2tcIixcbiAgICAgICAgICAgIFwic3RpbGxcIiwgXCJzdGluZ1wiLCBcInN0b2NrXCIsIFwic3RvbWFjaFwiLCBcInN0b25lXCIsIFwic3Rvb2xcIixcbiAgICAgICAgICAgIFwic3RvcnlcIiwgXCJzdG92ZVwiLCBcInN0cmF0ZWd5XCIsIFwic3RyZWV0XCIsIFwic3RyaWtlXCIsIFwic3Ryb25nXCIsXG4gICAgICAgICAgICBcInN0cnVnZ2xlXCIsIFwic3R1ZGVudFwiLCBcInN0dWZmXCIsIFwic3R1bWJsZVwiLCBcInN0eWxlXCIsIFwic3ViamVjdFwiLFxuICAgICAgICAgICAgXCJzdWJtaXRcIiwgXCJzdWJ3YXlcIiwgXCJzdWNjZXNzXCIsIFwic3VjaFwiLCBcInN1ZGRlblwiLCBcInN1ZmZlclwiLFxuICAgICAgICAgICAgXCJzdWdhclwiLCBcInN1Z2dlc3RcIiwgXCJzdWl0XCIsIFwic3VtbWVyXCIsIFwic3VuXCIsIFwic3VubnlcIixcbiAgICAgICAgICAgIFwic3Vuc2V0XCIsIFwic3VwZXJcIiwgXCJzdXBwbHlcIiwgXCJzdXByZW1lXCIsIFwic3VyZVwiLCBcInN1cmZhY2VcIixcbiAgICAgICAgICAgIFwic3VyZ2VcIiwgXCJzdXJwcmlzZVwiLCBcInN1cnJvdW5kXCIsIFwic3VydmV5XCIsIFwic3VzcGVjdFwiLCBcInN1c3RhaW5cIixcbiAgICAgICAgICAgIFwic3dhbGxvd1wiLCBcInN3YW1wXCIsIFwic3dhcFwiLCBcInN3YXJtXCIsIFwic3dlYXJcIiwgXCJzd2VldFwiLFxuICAgICAgICAgICAgXCJzd2lmdFwiLCBcInN3aW1cIiwgXCJzd2luZ1wiLCBcInN3aXRjaFwiLCBcInN3b3JkXCIsIFwic3ltYm9sXCIsXG4gICAgICAgICAgICBcInN5bXB0b21cIiwgXCJzeXJ1cFwiLCBcInN5c3RlbVwiLCBcInRhYmxlXCIsIFwidGFja2xlXCIsIFwidGFnXCIsXG4gICAgICAgICAgICBcInRhaWxcIiwgXCJ0YWxlbnRcIiwgXCJ0YWxrXCIsIFwidGFua1wiLCBcInRhcGVcIiwgXCJ0YXJnZXRcIixcbiAgICAgICAgICAgIFwidGFza1wiLCBcInRhc3RlXCIsIFwidGF0dG9vXCIsIFwidGF4aVwiLCBcInRlYWNoXCIsIFwidGVhbVwiLFxuICAgICAgICAgICAgXCJ0ZWxsXCIsIFwidGVuXCIsIFwidGVuYW50XCIsIFwidGVubmlzXCIsIFwidGVudFwiLCBcInRlcm1cIixcbiAgICAgICAgICAgIFwidGVzdFwiLCBcInRleHRcIiwgXCJ0aGFua1wiLCBcInRoYXRcIiwgXCJ0aGVtZVwiLCBcInRoZW5cIixcbiAgICAgICAgICAgIFwidGhlb3J5XCIsIFwidGhlcmVcIiwgXCJ0aGV5XCIsIFwidGhpbmdcIiwgXCJ0aGlzXCIsIFwidGhvdWdodFwiLFxuICAgICAgICAgICAgXCJ0aHJlZVwiLCBcInRocml2ZVwiLCBcInRocm93XCIsIFwidGh1bWJcIiwgXCJ0aHVuZGVyXCIsIFwidGlja2V0XCIsXG4gICAgICAgICAgICBcInRpZGVcIiwgXCJ0aWdlclwiLCBcInRpbHRcIiwgXCJ0aW1iZXJcIiwgXCJ0aW1lXCIsIFwidGlueVwiLFxuICAgICAgICAgICAgXCJ0aXBcIiwgXCJ0aXJlZFwiLCBcInRpc3N1ZVwiLCBcInRpdGxlXCIsIFwidG9hc3RcIiwgXCJ0b2JhY2NvXCIsXG4gICAgICAgICAgICBcInRvZGF5XCIsIFwidG9kZGxlclwiLCBcInRvZVwiLCBcInRvZ2V0aGVyXCIsIFwidG9pbGV0XCIsIFwidG9rZW5cIixcbiAgICAgICAgICAgIFwidG9tYXRvXCIsIFwidG9tb3Jyb3dcIiwgXCJ0b25lXCIsIFwidG9uZ3VlXCIsIFwidG9uaWdodFwiLCBcInRvb2xcIixcbiAgICAgICAgICAgIFwidG9vdGhcIiwgXCJ0b3BcIiwgXCJ0b3BpY1wiLCBcInRvcHBsZVwiLCBcInRvcmNoXCIsIFwidG9ybmFkb1wiLFxuICAgICAgICAgICAgXCJ0b3J0b2lzZVwiLCBcInRvc3NcIiwgXCJ0b3RhbFwiLCBcInRvdXJpc3RcIiwgXCJ0b3dhcmRcIiwgXCJ0b3dlclwiLFxuICAgICAgICAgICAgXCJ0b3duXCIsIFwidG95XCIsIFwidHJhY2tcIiwgXCJ0cmFkZVwiLCBcInRyYWZmaWNcIiwgXCJ0cmFnaWNcIixcbiAgICAgICAgICAgIFwidHJhaW5cIiwgXCJ0cmFuc2ZlclwiLCBcInRyYXBcIiwgXCJ0cmFzaFwiLCBcInRyYXZlbFwiLCBcInRyYXlcIixcbiAgICAgICAgICAgIFwidHJlYXRcIiwgXCJ0cmVlXCIsIFwidHJlbmRcIiwgXCJ0cmlhbFwiLCBcInRyaWJlXCIsIFwidHJpY2tcIixcbiAgICAgICAgICAgIFwidHJpZ2dlclwiLCBcInRyaW1cIiwgXCJ0cmlwXCIsIFwidHJvcGh5XCIsIFwidHJvdWJsZVwiLCBcInRydWNrXCIsXG4gICAgICAgICAgICBcInRydWVcIiwgXCJ0cnVseVwiLCBcInRydW1wZXRcIiwgXCJ0cnVzdFwiLCBcInRydXRoXCIsIFwidHJ5XCIsXG4gICAgICAgICAgICBcInR1YmVcIiwgXCJ0dWl0aW9uXCIsIFwidHVtYmxlXCIsIFwidHVuYVwiLCBcInR1bm5lbFwiLCBcInR1cmtleVwiLFxuICAgICAgICAgICAgXCJ0dXJuXCIsIFwidHVydGxlXCIsIFwidHdlbHZlXCIsIFwidHdlbnR5XCIsIFwidHdpY2VcIiwgXCJ0d2luXCIsXG4gICAgICAgICAgICBcInR3aXN0XCIsIFwidHdvXCIsIFwidHlwZVwiLCBcInR5cGljYWxcIiwgXCJ1Z2x5XCIsIFwidW1icmVsbGFcIixcbiAgICAgICAgICAgIFwidW5hYmxlXCIsIFwidW5hd2FyZVwiLCBcInVuY2xlXCIsIFwidW5jb3ZlclwiLCBcInVuZGVyXCIsIFwidW5kb1wiLFxuICAgICAgICAgICAgXCJ1bmZhaXJcIiwgXCJ1bmZvbGRcIiwgXCJ1bmhhcHB5XCIsIFwidW5pZm9ybVwiLCBcInVuaXF1ZVwiLCBcInVuaXRcIixcbiAgICAgICAgICAgIFwidW5pdmVyc2VcIiwgXCJ1bmtub3duXCIsIFwidW5sb2NrXCIsIFwidW50aWxcIiwgXCJ1bnVzdWFsXCIsIFwidW52ZWlsXCIsXG4gICAgICAgICAgICBcInVwZGF0ZVwiLCBcInVwZ3JhZGVcIiwgXCJ1cGhvbGRcIiwgXCJ1cG9uXCIsIFwidXBwZXJcIiwgXCJ1cHNldFwiLFxuICAgICAgICAgICAgXCJ1cmJhblwiLCBcInVyZ2VcIiwgXCJ1c2FnZVwiLCBcInVzZVwiLCBcInVzZWRcIiwgXCJ1c2VmdWxcIixcbiAgICAgICAgICAgIFwidXNlbGVzc1wiLCBcInVzdWFsXCIsIFwidXRpbGl0eVwiLCBcInZhY2FudFwiLCBcInZhY3V1bVwiLCBcInZhZ3VlXCIsXG4gICAgICAgICAgICBcInZhbGlkXCIsIFwidmFsbGV5XCIsIFwidmFsdmVcIiwgXCJ2YW5cIiwgXCJ2YW5pc2hcIiwgXCJ2YXBvclwiLFxuICAgICAgICAgICAgXCJ2YXJpb3VzXCIsIFwidmFzdFwiLCBcInZhdWx0XCIsIFwidmVoaWNsZVwiLCBcInZlbHZldFwiLCBcInZlbmRvclwiLFxuICAgICAgICAgICAgXCJ2ZW50dXJlXCIsIFwidmVudWVcIiwgXCJ2ZXJiXCIsIFwidmVyaWZ5XCIsIFwidmVyc2lvblwiLCBcInZlcnlcIixcbiAgICAgICAgICAgIFwidmVzc2VsXCIsIFwidmV0ZXJhblwiLCBcInZpYWJsZVwiLCBcInZpYnJhbnRcIiwgXCJ2aWNpb3VzXCIsIFwidmljdG9yeVwiLFxuICAgICAgICAgICAgXCJ2aWRlb1wiLCBcInZpZXdcIiwgXCJ2aWxsYWdlXCIsIFwidmludGFnZVwiLCBcInZpb2xpblwiLCBcInZpcnR1YWxcIixcbiAgICAgICAgICAgIFwidmlydXNcIiwgXCJ2aXNhXCIsIFwidmlzaXRcIiwgXCJ2aXN1YWxcIiwgXCJ2aXRhbFwiLCBcInZpdmlkXCIsXG4gICAgICAgICAgICBcInZvY2FsXCIsIFwidm9pY2VcIiwgXCJ2b2lkXCIsIFwidm9sY2Fub1wiLCBcInZvbHVtZVwiLCBcInZvdGVcIixcbiAgICAgICAgICAgIFwidm95YWdlXCIsIFwid2FnZVwiLCBcIndhZ29uXCIsIFwid2FpdFwiLCBcIndhbGtcIiwgXCJ3YWxsXCIsXG4gICAgICAgICAgICBcIndhbG51dFwiLCBcIndhbnRcIiwgXCJ3YXJmYXJlXCIsIFwid2FybVwiLCBcIndhcnJpb3JcIiwgXCJ3YXNoXCIsXG4gICAgICAgICAgICBcIndhc3BcIiwgXCJ3YXN0ZVwiLCBcIndhdGVyXCIsIFwid2F2ZVwiLCBcIndheVwiLCBcIndlYWx0aFwiLFxuICAgICAgICAgICAgXCJ3ZWFwb25cIiwgXCJ3ZWFyXCIsIFwid2Vhc2VsXCIsIFwid2VhdGhlclwiLCBcIndlYlwiLCBcIndlZGRpbmdcIixcbiAgICAgICAgICAgIFwid2Vla2VuZFwiLCBcIndlaXJkXCIsIFwid2VsY29tZVwiLCBcIndlc3RcIiwgXCJ3ZXRcIiwgXCJ3aGFsZVwiLFxuICAgICAgICAgICAgXCJ3aGF0XCIsIFwid2hlYXRcIiwgXCJ3aGVlbFwiLCBcIndoZW5cIiwgXCJ3aGVyZVwiLCBcIndoaXBcIixcbiAgICAgICAgICAgIFwid2hpc3BlclwiLCBcIndpZGVcIiwgXCJ3aWR0aFwiLCBcIndpZmVcIiwgXCJ3aWxkXCIsIFwid2lsbFwiLFxuICAgICAgICAgICAgXCJ3aW5cIiwgXCJ3aW5kb3dcIiwgXCJ3aW5lXCIsIFwid2luZ1wiLCBcIndpbmtcIiwgXCJ3aW5uZXJcIixcbiAgICAgICAgICAgIFwid2ludGVyXCIsIFwid2lyZVwiLCBcIndpc2RvbVwiLCBcIndpc2VcIiwgXCJ3aXNoXCIsIFwid2l0bmVzc1wiLFxuICAgICAgICAgICAgXCJ3b2xmXCIsIFwid29tYW5cIiwgXCJ3b25kZXJcIiwgXCJ3b29kXCIsIFwid29vbFwiLCBcIndvcmRcIixcbiAgICAgICAgICAgIFwid29ya1wiLCBcIndvcmxkXCIsIFwid29ycnlcIiwgXCJ3b3J0aFwiLCBcIndyYXBcIiwgXCJ3cmVja1wiLFxuICAgICAgICAgICAgXCJ3cmVzdGxlXCIsIFwid3Jpc3RcIiwgXCJ3cml0ZVwiLCBcIndyb25nXCIsIFwieWFyZFwiLCBcInllYXJcIixcbiAgICAgICAgICAgIFwieWVsbG93XCIsIFwieW91XCIsIFwieW91bmdcIiwgXCJ5b3V0aFwiLCBcInplYnJhXCIsIFwiemVyb1wiLFxuICAgICAgICAgICAgXCJ6b25lXCIsIFwiem9vXCJcbiAgICAgICAgXSk7XG59KSh3aW5kb3csIHdpbmRvdy5hbmd1bGFyKTtcbiIsIihmdW5jdGlvbih3aW5kb3csIGFuZ3VsYXIpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBhbmd1bGFyLm1vZHVsZSgnYml0Y29pbicpXG4gICAgICAgIC5jb25zdGFudCgnQ09JTicsIDEwMDAwMDAwMClcbiAgICAgICAgLmNvbnN0YW50KCdERUZBVUxUX0ZFRScsIDEwMDAwKSAvLyAwLjAwMDEgQlRDXG4gICAgICAgIC5jb25zdGFudCgnTUlOX09VVFBVVCcsIDU0NjApICAgLy8gMC4wMDAwNTQ2IEJUQ1xuICAgICAgICAuY29uc3RhbnQoJ01BSU5ORVRfUFVCTElDJywgMHgwNDg4YjIxZSlcbiAgICAgICAgLmNvbnN0YW50KCdNQUlOTkVUX1BSSVZBVEUnLCAweDA0ODhhZGU0KVxuICAgICAgICAuY29uc3RhbnQoJ1RFU1RORVRfUFVCTElDJywgMHgwNDM1ODdjZilcbiAgICAgICAgLmNvbnN0YW50KCdURVNUTkVUX1BSSVZBVEUnLCAweDA0MzU4Mzk0KVxuXG4gICAgICAgIC5jb25zdGFudCgnUkVDRUlWRV9DSEFJTicsIDApXG4gICAgICAgIC5jb25zdGFudCgnQ0hBTkdFX0NIQUlOJywgMSlcbiAgICAvLyBob3cgbWFueSBleHRyYSBhZGRyZXNzZXMgdG8gZ2VuZXJhdGVcbiAgICAgICAgLmNvbnN0YW50KCdHQVAnLCAxKTtcblxufSkod2luZG93LCB3aW5kb3cuYW5ndWxhcik7XG4iLCIoZnVuY3Rpb24od2luZG93LCBhbmd1bGFyLCBCaWdOdW1iZXIpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBhbmd1bGFyLm1vZHVsZSgnYml0Y29pbicpXG4gICAgICAgIC5kaXJlY3RpdmUoJ2JjSW5wdXQnLCBiY0lucHV0KTtcblxuICAgIGJjSW5wdXQuJGluamVjdCA9IFsnJHJvb3RTY29wZSddO1xuXG4gICAgZnVuY3Rpb24gYmNJbnB1dCgkcm9vdFNjb3BlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZW1wbGF0ZTogJzxpbnB1dCBjbGFzcz1cImZvcm0tY29udHJvbCBjcnlwdG8taW5wdXRcIiAnICtcbiAgICAgICAgICAgICAgICAndHlwZT1cInRleHRcIiBuZy1tb2RlbD1cImRpc3BsYXlWYWxcIj4nICtcbiAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC1hZGRvbiBjcnlwdG8taW5wdXQtbGFiZWxcIj57e3N5bWJvbH19PC9zcGFuPicsXG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICAgICAgICBpbnRWYWw6ICc9bW9kZWwnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kd2F0Y2goJ2N1cnJlbmN5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnN5bWJvbCA9ICRyb290U2NvcGUuY3VycmVuY3k7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZURpc3BsYXkoKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHNjb3BlLiR3YXRjaCgnaW50VmFsJywgZnVuY3Rpb24obmV3VmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWwgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuZGlzcGxheVZhbCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhc2NvcGUuZGlzcGxheVZhbC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gcGFyc2VJbnQobmV3VmFsLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY29wZS5kaXNwbGF5VmFsLnRvU3RyaW5nKCkubWF0Y2goL14wK1xcLjArJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIW5ld1ZhbC50b1N0cmluZygpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuZGlzcGxheVZhbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuZGlzcGxheVZhbCA9IFwiLVwiO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlRGlzcGxheSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBzY29wZS4kd2F0Y2goJ2Rpc3BsYXlWYWwnLCBmdW5jdGlvbihuZXdWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IG5ldyBCaWdOdW1iZXIocGFyc2VGbG9hdChuZXdWYWwpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdWYWwudG9TdHJpbmcoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLmludFZhbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV3VmFsLnRvU3RyaW5nKCkubWF0Y2goL14wK1xcLjArJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5pbnRWYWwgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLmludFZhbCA9IE5hTjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLmludFZhbCA9IE1hdGguZmxvb3IodmFsLnRpbWVzKCRyb290U2NvcGUuZGVub21pbmF0aW9uKS50b051bWJlcigpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlRGlzcGxheSgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IG5ldyBCaWdOdW1iZXIocGFyc2VJbnQoc2NvcGUuaW50VmFsLCAxMCkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtU3RyID0gdmFsLmRpdmlkZWRCeSgkcm9vdFNjb3BlLmRlbm9taW5hdGlvbikudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuZGlzcGxheVZhbCA9IG51bVN0cjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG59KSh3aW5kb3csIHdpbmRvdy5hbmd1bGFyLCB3aW5kb3cuQmlnTnVtYmVyKTtcbiIsIihmdW5jdGlvbih3aW5kb3csIGFuZ3VsYXIsIEJpZ0ludGVnZXIsIENyeXB0bywgQml0Y29pbiwgRUNQb2ludEZwLCBnZXRTRUNDdXJ2ZUJ5TmFtZSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGFuZ3VsYXIubW9kdWxlKCdiaXRjb2luJylcbiAgICAgICAgLmZhY3RvcnkoJ21lc3NhZ2VVdGlsJywgbWVzc2FnZVV0aWxGYWN0b3J5KTtcblxuICAgIG1lc3NhZ2VVdGlsRmFjdG9yeS4kaW5qZWN0ID0gW107XG5cbiAgICBmdW5jdGlvbiBtZXNzYWdlVXRpbEZhY3RvcnkoKSB7XG5cbiAgICAgICAgdmFyIHRyaW1SZWdleHAgPSAvKF5bXFxzXFxuXSt8W1xcc1xcbl0rJCkvZztcbiAgICAgICAgdmFyIE1FU1NBR0VfSEVBREVSID0gXCJCaXRjb2luIFNpZ25lZCBNZXNzYWdlOlxcblwiO1xuXG4gICAgICAgIHZhciBtZXNzYWdlVXRpbCA9IHtcbiAgICAgICAgICAgIHRyaW06IHRyaW0sXG4gICAgICAgICAgICBtYWtlTWVzc2FnZUJ5dGVzOiBtYWtlTWVzc2FnZUJ5dGVzLFxuICAgICAgICAgICAgZ2V0Qnl0ZXM6IGdldEJ5dGVzLFxuICAgICAgICAgICAgcHJvY2Vzc1NpZ25hdHVyZTogcHJvY2Vzc1NpZ25hdHVyZSxcbiAgICAgICAgICAgIE1FU1NBR0VfSEVBREVSOiBNRVNTQUdFX0hFQURFUixcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbWVzc2FnZVV0aWw7XG5cbiAgICAgICAgZnVuY3Rpb24gbWFrZU1lc3NhZ2VCeXRlcyhtZXNzYWdlKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gdHJpbShtZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiBnZXRCeXRlcyhNRVNTQUdFX0hFQURFUikuY29uY2F0KGdldEJ5dGVzKG1lc3NhZ2UpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHRyaW0obWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2UucmVwbGFjZSh0cmltUmVnZXhwLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRCeXRlcyhzdHIpIHtcbiAgICAgICAgICAgIHZhciBieXRlcyA9IENyeXB0by5jaGFyZW5jLlVURjguc3RyaW5nVG9CeXRlcyhzdHIpO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW4gPCAweGZkKSB7IC8vIDI1M1xuICAgICAgICAgICAgICAgIGJ5dGVzID0gW2xlbl0uY29uY2F0KGJ5dGVzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGVuIDwgMHhmZmZmKSB7IC8vIDY1NTM1XG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIHRoaXMgbGluZSBpbiBqc2hpbnQsIGl0IGRvZXMgbm90IGxpa2VcbiAgICAgICAgICAgICAgICAvLyBiaXR3aXNlIG9wZXJhdGlvbnNcbiAgICAgICAgICAgICAgICBieXRlcyA9IFsweGZkLCBsZW4gJiAweGZmLCBsZW4gPj4+IDB4OF0uY29uY2F0KGJ5dGVzKTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1lc3NhZ2UgdG8gbGFyZ2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzU2lnbmF0dXJlKG1lc3NhZ2UsIGFkZHJlc3MsIHNpZ0J5dGVzLCBjb21wcmVzc2VkLCBhZGRyVHlwZSkge1xuICAgICAgICAgICAgYWRkclR5cGUgPSBhZGRyVHlwZSB8fCAwO1xuICAgICAgICAgICAgaWYgKGNvbXByZXNzZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbXByZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBhcnNlZCA9IEJpdGNvaW4uRUNEU0EucGFyc2VTaWcoc2lnQnl0ZXMpO1xuICAgICAgICAgICAgdmFyIHNlcXVlbmNlID0gWzBdO1xuICAgICAgICAgICAgc2VxdWVuY2UgPSBzZXF1ZW5jZS5jb25jYXQocGFyc2VkLnIudG9CeXRlQXJyYXlVbnNpZ25lZCgpKTtcbiAgICAgICAgICAgIHNlcXVlbmNlID0gc2VxdWVuY2UuY29uY2F0KHBhcnNlZC5zLnRvQnl0ZUFycmF5VW5zaWduZWQoKSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBuViA9IDI3ICsgaTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKFwicHJvY2Vzc1NpZ25hdHVyZTogaXMgY29tcHJlc3NlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgblYgKz0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VxdWVuY2VbMF0gPSBuVjtcbiAgICAgICAgICAgICAgICB2YXIgc2lnID0gQ3J5cHRvLnV0aWwuYnl0ZXNUb0Jhc2U2NChzZXF1ZW5jZSk7XG4gICAgICAgICAgICAgICAgdmFyIHNpZ0FkZHJlc3MgPSB2ZXJpZnlNZXNzYWdlKHNpZywgbWVzc2FnZSwgYWRkclR5cGUpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoXCJwcm9jZXNzU2lnbmF0dXJlOiBnb3Qgc2lnQWRkcmVzc1wiLCBzaWdBZGRyZXNzLCBcImFkZHJlc3M9XCIsIGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGlmIChzaWdBZGRyZXNzID09PSBhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoXCJwcm9jZXNzU2lnbmF0dXJlOiBmb3VuZCBtYXRjaFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKFwicHJvY2Vzc1NpZ25hdHVyZTogbm8gbWF0Y2ggZm91bmRcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtc2dEaWdlc3QobWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIGJ5dGVzID0gbWFrZU1lc3NhZ2VCeXRlcyhtZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiBDcnlwdG8uU0hBMjU2KENyeXB0by5TSEEyNTYoYnl0ZXMsIHthc0J5dGVzOnRydWV9KSwge2FzQnl0ZXM6dHJ1ZX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdmVyaWZ5TWVzc2FnZShzaWduYXR1cmUsIG1lc3NhZ2UsIGFkZHJ0eXBlKSB7XG4gICAgICAgICAgICB2YXIgc2lnO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzaWcgPSBDcnlwdG8udXRpbC5iYXNlNjRUb0J5dGVzKHNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyLCBzaWduYXR1cmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNpZy5sZW5ndGggIT09IDY1KXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBzaWcgbGVuZ3RoXCIsIHNpZy5sZW5ndGgsIHNpZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGV4dHJhY3QgcixzIGZyb20gc2lnbmF0dXJlXG4gICAgICAgICAgICB2YXIgciA9IEJpZ0ludGVnZXIuZnJvbUJ5dGVBcnJheVVuc2lnbmVkKHNpZy5zbGljZSgxLDErMzIpKTtcbiAgICAgICAgICAgIHZhciBzID0gQmlnSW50ZWdlci5mcm9tQnl0ZUFycmF5VW5zaWduZWQoc2lnLnNsaWNlKDMzLDMzKzMyKSk7XG5cbiAgICAgICAgICAgIC8vIGdldCByZWNpZFxuICAgICAgICAgICAgdmFyIGNvbXByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBuViA9IHNpZ1swXTtcbiAgICAgICAgICAgIGlmIChuViA8IDI3IHx8IG5WID49IDM1KXtcbiAgICBcdCAgICAgICAgY29uc29sZS5lcnJvcihcIm5WIGVycm9yXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuViA+PSAzMSkge1xuICAgICAgICAgICAgICAgIGNvbXByZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG5WIC09IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVjaWQgPSBCaWdJbnRlZ2VyLnZhbHVlT2YoblYgLSAyNyk7XG5cbiAgICAgICAgICAgIHZhciBlY3BhcmFtcyA9IGdldFNFQ0N1cnZlQnlOYW1lKFwic2VjcDI1NmsxXCIpO1xuICAgICAgICAgICAgdmFyIGN1cnZlID0gZWNwYXJhbXMuZ2V0Q3VydmUoKTtcbiAgICAgICAgICAgIHZhciBhID0gY3VydmUuZ2V0QSgpLnRvQmlnSW50ZWdlcigpO1xuICAgICAgICAgICAgdmFyIGIgPSBjdXJ2ZS5nZXRCKCkudG9CaWdJbnRlZ2VyKCk7XG4gICAgICAgICAgICB2YXIgcCA9IGN1cnZlLmdldFEoKTtcbiAgICAgICAgICAgIHZhciBHID0gZWNwYXJhbXMuZ2V0RygpO1xuICAgICAgICAgICAgdmFyIG9yZGVyID0gZWNwYXJhbXMuZ2V0TigpO1xuXG4gICAgICAgICAgICB2YXIgeCA9IHIuYWRkKG9yZGVyLm11bHRpcGx5KHJlY2lkLmRpdmlkZShCaWdJbnRlZ2VyLnZhbHVlT2YoMikpKSk7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSB4Lm11bHRpcGx5KHgpLm11bHRpcGx5KHgpLmFkZChhLm11bHRpcGx5KHgpKS5hZGQoYikubW9kKHApO1xuICAgICAgICAgICAgdmFyIGJldGEgPSBhbHBoYS5tb2RQb3cocC5hZGQoQmlnSW50ZWdlci5PTkUpLmRpdmlkZShCaWdJbnRlZ2VyLnZhbHVlT2YoNCkpLCBwKTtcbiAgICAgICAgICAgIHZhciB5ID0gYmV0YS5zdWJ0cmFjdChyZWNpZCkuaXNFdmVuKCkgPyBiZXRhIDogcC5zdWJ0cmFjdChiZXRhKTtcblxuICAgICAgICAgICAgdmFyIFIgPSBuZXcgRUNQb2ludEZwKGN1cnZlLCBjdXJ2ZS5mcm9tQmlnSW50ZWdlcih4KSwgY3VydmUuZnJvbUJpZ0ludGVnZXIoeSkpO1xuICAgICAgICAgICAgdmFyIGUgPSBCaWdJbnRlZ2VyLmZyb21CeXRlQXJyYXlVbnNpZ25lZChtc2dEaWdlc3QobWVzc2FnZSkpO1xuICAgICAgICAgICAgdmFyIG1pbnVzX2UgPSBlLm5lZ2F0ZSgpLm1vZChvcmRlcik7XG4gICAgICAgICAgICB2YXIgaW52X3IgPSByLm1vZEludmVyc2Uob3JkZXIpO1xuICAgICAgICAgICAgdmFyIFEgPSAoUi5tdWx0aXBseShzKS5hZGQoRy5tdWx0aXBseShtaW51c19lKSkpLm11bHRpcGx5KGludl9yKTtcblxuICAgICAgICAgICAgdmFyIHB1YmxpY19rZXkgPSBRLmdldEVuY29kZWQoY29tcHJlc3NlZCk7XG4gICAgICAgICAgICB2YXIgYWRkciA9IG5ldyBCaXRjb2luLkFkZHJlc3MoQml0Y29pbi5VdGlsLnNoYTI1NnJpcGUxNjAocHVibGljX2tleSkpO1xuICAgICAgICAgICAgYWRkci52ZXJzaW9uID0gYWRkcnR5cGUgPyBhZGRydHlwZSA6IDA7XG4gICAgICAgICAgICByZXR1cm4gYWRkci50b1N0cmluZygpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbn0pKHdpbmRvdywgd2luZG93LmFuZ3VsYXIsIHdpbmRvdy5CaWdJbnRlZ2VyLCB3aW5kb3cuQ3J5cHRvLCB3aW5kb3cuQml0Y29pbiwgd2luZG93LkVDUG9pbnRGcCwgd2luZG93LmdldFNFQ0N1cnZlQnlOYW1lKTtcbiIsIihmdW5jdGlvbih3aW5kb3csIGFuZ3VsYXIsIEJpdGNvaW4pIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBhbmd1bGFyLm1vZHVsZSgnYml0Y29pbicpXG4gICAgICAgIC5mYWN0b3J5KCdUcmFuc2FjdGlvbicsIFRyYW5zYWN0aW9uRmFjdG9yeSk7XG5cbiAgICBUcmFuc2FjdGlvbkZhY3RvcnkuJGluamVjdCA9IFsnaGV4VXRpbCcsICdERUZBVUxUX0ZFRScsICdNSU5fT1VUUFVUJ107XG5cbiAgICBmdW5jdGlvbiBUcmFuc2FjdGlvbkZhY3RvcnkoaGV4VXRpbCwgREVGQVVMVF9GRUUsIE1JTl9PVVRQVVQpIHtcblxuICAgICAgICB2YXIgRVJSX0lOVkFMSURfRkVFICAgICAgICAgID0gVHJhbnNhY3Rpb24uRVJSX0lOVkFMSURfRkVFICAgICAgICAgPSBcIkludmFsaWQgZmVlXCI7XG4gICAgICAgIHZhciBFUlJfTk9fT1VUUFVUUyAgICAgICAgICAgPSBUcmFuc2FjdGlvbi5FUlJfTk9fT1VUUFVUUyAgICAgICAgICA9IFwiTm8gb3V0cHV0c1wiO1xuICAgICAgICB2YXIgRVJSX0lOVkFMSURfQU1PVU5UICAgICAgID0gVHJhbnNhY3Rpb24uRVJSX0lOVkFMSURfQU1PVU5UICAgICAgPSBcIkludmFsaWQgYW1vdW50XCI7XG4gICAgICAgIHZhciBFUlJfQU1PVU5UX1RPT19MT1cgICAgICAgPSBUcmFuc2FjdGlvbi5FUlJfQU1PVU5UX1RPT19MT1cgICAgICA9IFwiQW1vdW50IG11c3QgYmUgZ3JlYXRlciB0aGFuIFwiICsgTUlOX09VVFBVVDtcbiAgICAgICAgdmFyIEVSUl9OT19JTlBVVFMgICAgICAgICAgICA9IFRyYW5zYWN0aW9uLkVSUl9OT19JTlBVVFMgICAgICAgICAgID0gXCJNaXNzaW5nIGlucHV0IGFycmF5XCI7XG4gICAgICAgIHZhciBFUlJfTk9fQ0hBTkdFX0FERFJFU1MgICAgPSBUcmFuc2FjdGlvbi5FUlJfTk9fQ0hBTkdFX0FERFJFU1MgICA9IFwiTWlzc2luZyBjaGFuZ2UgYWRkcmVzc1wiO1xuICAgICAgICB2YXIgRVJSX0lOU1VGRklDSUVOVF9JTlBVVFMgID0gVHJhbnNhY3Rpb24uRVJSX0lOU1VGRklDSUVOVF9JTlBVVFMgPSBcIk5vdCBlbm91Z2ggaW5wdXRzXCI7XG4gICAgICAgIHZhciBFUlJfQkFEX1NJR05FRF9TQ1JJUFRTICAgPSBUcmFuc2FjdGlvbi5FUlJfQkFEX1NJR05FRF9TQ1JJUFRTICA9IFwiSW52YWxpZCBzaWduZWQgc2NyaXB0c1wiO1xuXG4gICAgICAgIGZ1bmN0aW9uIFRyYW5zYWN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBmZWUgPSB0aGlzLmZlZSA9IG9wdGlvbnMuZmVlID09PSB1bmRlZmluZWQgPyBERUZBVUxUX0ZFRSA6IHBhcnNlSW50KG9wdGlvbnMuZmVlLCAxMCk7XG4gICAgICAgICAgICBpZiAoaXNOYU4oZmVlKSB8fCBmZWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRVJSX0lOVkFMSURfRkVFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG91dHB1dHMgPSB0aGlzLm91dHB1dHMgPSBvcHRpb25zLm91dHB1dHM7XG4gICAgICAgICAgICBpZiAoIW91dHB1dHMpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBubyBvdXRwdXRzIGluIHRoZSBvcHRpb25zLCBsb29rIGZvciBcInRvXCIgYW5kXG4gICAgICAgICAgICAgICAgLy8gXCJhbW91bnRcIiBhbmQgbWFrZSBhbiBvdXRwdXQgb2JqZWN0XG4gICAgICAgICAgICAgICAgdmFyIHRvID0gb3B0aW9ucy50bztcbiAgICAgICAgICAgICAgICBpZiAoIXRvKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVSUl9OT19PVVRQVVRTO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYW1vdW50ID0gcGFyc2VJbnQob3B0aW9ucy5hbW91bnQsIDEwKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oYW1vdW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFUlJfSU5WQUxJRF9BTU9VTlQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dHMgPSB0aGlzLm91dHB1dHMgPSBbe1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiB0byxcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50OiBhbW91bnRcbiAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvdXRwdXRzKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dHMgPSBbb3V0cHV0c107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5wdXRzID0gb3B0aW9ucy5pbnB1dHM7XG4gICAgICAgICAgICBpZiAoIWlucHV0cyB8fCAhQXJyYXkuaXNBcnJheShpbnB1dHMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRVJSX05PX0lOUFVUUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNvcnQgaW5wdXRzIGJ5IG1vc3QgdG8gbGVhc3QgY29uZmlybWF0aW9uc1xuICAgICAgICAgICAgaW5wdXRzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLmNvbmZpcm1hdGlvbnMgPiBiLmNvbmZpcm1hdGlvbnMgPyAtMSA6IDE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VBZGRyZXNzID0gdGhpcy5jaGFuZ2VBZGRyZXNzID0gb3B0aW9ucy5jaGFuZ2UgfHwgb3B0aW9ucy5jaGFuZ2VBZGRyZXNzO1xuICAgICAgICAgICAgaWYgKCFjaGFuZ2VBZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRVJSX05PX0NIQU5HRV9BRERSRVNTO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBtYWtlIGEgbmV3IHRyYW5zYWN0aW9uXG4gICAgICAgICAgICB0aGlzLnR4ID0gbmV3IEJpdGNvaW4uVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICAgIC8vIGluaXRpYWxpemUgdG90YWwgb3V0IGFuZCBpblxuICAgICAgICAgICAgdGhpcy50b3RhbE91dCA9IDA7XG4gICAgICAgICAgICB0aGlzLnRvdGFsSW4gPSAwO1xuICAgICAgICAgICAgLy8gc2V0IHVwIGVtcHR5IGlucHV0IGFycmF5IG9uICd0aGlzJywgaXQgZ2V0cyBmaWxsZWQgd2l0aFxuICAgICAgICAgICAgLy8gdGhlIGlucHV0cyB3ZSBhY3R1YWxseSB1c2Ugb24gY2FsbGluZyBhZGRJbnB1dHNcbiAgICAgICAgICAgIHRoaXMuaW5wdXRzID0gW107XG4gICAgICAgICAgICAvLyBub3cgYWRkIHRoZSBvdXRwdXRzXG4gICAgICAgICAgICB0aGlzLmFkZE91dHB1dHMob3V0cHV0cyk7XG4gICAgICAgICAgICAvLyBzZXQgdGhlIHRhcmdldCBhbW91bnRcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdGhpcy50b3RhbE91dCArIHRoaXMuZmVlO1xuICAgICAgICAgICAgLy8gdGhlbiBhZGQgaW5wdXRzXG4gICAgICAgICAgICB2YXIgY2hhbmdlID0gdGhpcy5jaGFuZ2VBbW91bnQgPSB0aGlzLmFkZElucHV0cyhpbnB1dHMpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZSA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBjaGFuZ2UgaXMgbGVzcyB0aGFuIDAsIG91dCBpbnB1dHMgd2VyZSBub3QgZW5vdWdoIHRvXG4gICAgICAgICAgICAgICAgLy8gY292ZXIgdGhlIG91dHB1dHNcbiAgICAgICAgICAgICAgICB0aHJvdyBFUlJfSU5TVUZGSUNJRU5UX0lOUFVUUztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhbmdlID4gMCAmJiBjaGFuZ2UgPCBNSU5fT1VUUFVUKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZm9yY2VTbWFsbENoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE91dHB1dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBjaGFuZ2VBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW1vdW50OiBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgfSwgJ2ZvcmNlIGl0Jyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlOiBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoYW5nZSA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBncmVhdGVyIHRoYW4gMCwgdGhlbiB3ZSBoYXZlIGNoYW5nZSBsZWZ0IG92ZXIsXG4gICAgICAgICAgICAgICAgLy8gc2VuZCBpdCB0byB0aGUgY2hhbmdlIGFkZHJlc3MgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICB0aGlzLmFkZE91dHB1dCh7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGNoYW5nZUFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIGFtb3VudDogY2hhbmdlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgdGhlIHVuc2lnbmVkIHR4IHRvIHRoaXMgaW5zdGFuY2VcbiAgICAgICAgICAgIHRoaXMudW5zaWduZWRIZXggPSBCaXRjb2luLlV0aWwuYnl0ZXNUb0hleCh0aGlzLnR4LnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoXCJ0cmFuc2FjdGlvbiBhc3NlbWJsZWRcIiwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgb3V0cHV0cyB3aWxsIHRha2UgdGhlIG91dHB1dHMgZm9yIG91ciBBUEkgYW5kIGNvbnZlcnRcbiAgICAgICAgLy8gdGhlbSB0byB0aGUgYml0Y29pbmpzIEFQSSBhbmQgYWRkIHRoZW0gdG8gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgICAvLyByZXR1cm4gdGhlIHRvdGFsIG9mIHRoZSBvdXRwdXQgdmFsdWVzIHdlIGVuY291bnRlcmVkIHRoaXNcbiAgICAgICAgLy8gcnVuXG5cbiAgICAgICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLmFkZE91dHB1dHMgPSBmdW5jdGlvbihvdXRwdXRzKSB7XG4gICAgICAgICAgICBvdXRwdXRzLmZvckVhY2godGhpcy5hZGRPdXRwdXQsIHRoaXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5hZGRPdXRwdXQgPSBmdW5jdGlvbihvdXRwdXQsIGZvcmNlU21hbGwpIHtcbiAgICAgICAgICAgIHZhciBhbW91bnQgPSBwYXJzZUludChvdXRwdXQuYW1vdW50LCAxMCk7XG4gICAgICAgICAgICBpZiAoaXNOYU4oYW1vdW50KSkge1xuICAgICAgICAgICAgICAgIHRocm93IEVSUl9JTlZBTElEX0FNT1VOVDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbW91bnQgPCBNSU5fT1VUUFVUICYmICFmb3JjZVNtYWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRVJSX0FNT1VOVF9UT09fTE9XO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50b3RhbE91dCArPSBhbW91bnQ7XG4gICAgICAgICAgICB2YXIgYWRkcmVzcyA9IG91dHB1dC5hZGRyZXNzO1xuICAgICAgICAgICAgdmFyIGJjQWRkciA9IG5ldyBCaXRjb2luLkFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgICAgICB2YXIgYmNPdXQgPSBuZXcgQml0Y29pbi5UcmFuc2FjdGlvbk91dCh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGhleFV0aWwuaW50VG9CaWdFbmRpYW5WYWx1ZShhbW91bnQsIDgpLFxuICAgICAgICAgICAgICAgIHNjcmlwdDogQml0Y29pbi5TY3JpcHQuY3JlYXRlT3V0cHV0U2NyaXB0KGJjQWRkcilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50eC5hZGRPdXRwdXQoYmNPdXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGFkZCBpbnB1dHMgd2lsbCB0YWtlIHRoZSBpbnB1dHMgZm9yIG91ciBBUEkgYW5kIGNvbnZlcnRcbiAgICAgICAgLy8gdGhlbSB0byB0aGUgYml0Y29pbmpzIEFQSSBhbmQgYWRkIHRoZW0gdG8gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgICAvLyBhZGQgYWxsIGlucHV0cyB3ZSB1c2UgdG8gdGhlICdpbnB1dHMnIGFycmF5IG9uIG91clxuICAgICAgICAvLyBUcmFuc2FjdGlvbiBpbnN0YW5jZVxuXG4gICAgICAgIC8vIHJldHVybiB0aGUgcmVtYWluZGVyIHRvIHNlbmQgdG8gY2hhbmdlXG4gICAgICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5hZGRJbnB1dHMgPSBmdW5jdGlvbihpbnB1dHMpIHtcbiAgICAgICAgICAgIGlucHV0cy5mb3JFYWNoKHRoaXMuYWRkSW5wdXQsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG90YWxJbiAtIHRoaXMudGFyZ2V0O1xuICAgICAgICB9O1xuXG4gICAgICAgIFRyYW5zYWN0aW9uLnByb3RvdHlwZS5hZGRJbnB1dCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGFsbCB0aGUgaW5wdXRzIHdlIG5lZWQgdG8gY292ZXIgdGhlXG4gICAgICAgICAgICAvLyBvdXRwdXQgYW5kIHRoZSBmZWUsIGp1c3QgbW92ZSBvblxuICAgICAgICAgICAgaWYgKHRoaXMudG90YWxJbiA+PSB0aGlzLnRhcmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnB1dC5jb25maXJtYXRpb25zIDwgMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgIHZhciBhbW91bnQgPSBwYXJzZUludChpbnB1dC52YWx1ZSwgMTApO1xuXHRcdFx0Y29uc29sZS5kZWJ1ZyhcImFkZGluZyBpbnB1dHNcIik7XG4gICAgICAgICAgICB2YXIgYW1vdW50ID0gcGFyc2VJbnQoaW5wdXQudmFsdWUsIDEwKTtcbiAgICAgICAgICAgIGlmIChpc05hTihhbW91bnQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRVJSX0lOVkFMSURfQU1PVU5UO1xuICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgdmFyIGhhc2ggPSBCaXRjb2luLlV0aWwuYnl0ZXNUb0Jhc2U2NChCaXRjb2luLlV0aWwuaGV4VG9CeXRlcyhpbnB1dC50eGlkKSk7XG4gICAgICAgICAgICB2YXIgaGFzaCA9IEJpdGNvaW4uVXRpbC5ieXRlc1RvQmFzZTY0KEJpdGNvaW4uVXRpbC5oZXhUb0J5dGVzKGhleFV0aWwubWFrZVN0cmluZ1NtYWxsRW5kaWFuKGlucHV0LnR4aWQpKSk7XG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gQml0Y29pbi5VdGlsLmhleFRvQnl0ZXMoaW5wdXQuc2NyaXB0KTtcbiAgICAgICAgICAgIHZhciBiY0luID0gbmV3IEJpdGNvaW4uVHJhbnNhY3Rpb25Jbih7XG4gICAgICAgICAgICAgICAgb3V0cG9pbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGlucHV0LnZvdXRcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNjcmlwdDogc2NyaXB0LFxuICAgICAgICAgICAgICAgIHNlcXVlbmNlOiA0Mjk0OTY3Mjk1XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMudHguYWRkSW5wdXQoYmNJbik7XG4gICAgICAgICAgICAvLyBhZGQgc29tZSBtb3JlIGluZm8gdG8gdGhlIGlucHV0IG9iamVjdCBoZXJlXG4gICAgICAgICAgICB0aGlzLmlucHV0cy5wdXNoKGlucHV0KTtcbiAgICAgICAgICAgIHRoaXMudG90YWxJbiArPSBhbW91bnQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgVHJhbnNhY3Rpb24ucHJvdG90eXBlLnJlcGxhY2VTY3JpcHRzID0gZnVuY3Rpb24oc2lnbmVkU2NyaXB0cykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNpZ25lZFNjcmlwdHMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRVJSX0JBRF9TSUdORURfU0NSSVBUUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaWduZWRTY3JpcHRzLmxlbmd0aCAhPT0gdGhpcy5pbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRVJSX0JBRF9TSUdORURfU0NSSVBUUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoZXggPSB0aGlzLnVuc2lnbmVkSGV4O1xuICAgICAgICAgICAgdGhpcy5pbnB1dHMuZm9yRWFjaChmdW5jdGlvbihpbnB1dCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBoZXggPSBoZXgucmVwbGFjZSgnMTknICsgaW5wdXQuc2NyaXB0LCBzaWduZWRTY3JpcHRzW2luZGV4XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2lnbmVkSGV4ID0gaGV4O1xuICAgICAgICAgICAgcmV0dXJuIGhleDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb247XG4gICAgfVxuXG59KSh3aW5kb3csIHdpbmRvdy5hbmd1bGFyLCB3aW5kb3cuQml0Y29pbik7XG4iLCIoZnVuY3Rpb24od2luZG93LCBhbmd1bGFyKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgYW5ndWxhci5tb2R1bGUoJ2JpdGNvaW4nKVxuICAgICAgICAuZmFjdG9yeSgndHhVdGlsJywgdHhVdGlsRmFjdG9yeSk7XG5cbiAgICB0eFV0aWxGYWN0b3J5LiRpbmplY3QgPSBbXG4gICAgICAgICckcScsXG4gICAgICAgICckaHR0cCcsXG4gICAgXTtcblxuICAgIGZ1bmN0aW9uIHR4VXRpbEZhY3RvcnkoJHEsICRodHRwKSB7XG5cblxuICAgICAgICB2YXIgYmFzZVVybCA9ICdodHRwczovL2JpdGxveC5pby9hcGknO1xuXG4vLyAgICAgICAgIHZhciBiYXNlVXJsID0gJy9hcGknO1xuXG4gICAgICAgIHZhciB0eFV0aWwgPSB7XG4gICAgICAgICAgICBnZXRIZXg6IGdldEhleCxcbiAgICAgICAgICAgIHN1Ym1pdDogc3VibWl0LFxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldEhleChiaWdFbmRpYW5UeGlkKSB7XG4gICAgICAgIFx0Y29uc29sZS5kZWJ1ZyhcInJhdyBzb3VyY2UgdHhpZCBcIiArIGJpZ0VuZGlhblR4aWQpO1xuICAgICAgICAgICAgcmV0dXJuICRodHRwLmdldChiYXNlVXJsICsgJy9yYXd0eC8nICsgYmlnRW5kaWFuVHhpZCApLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICBcdGNvbnNvbGUuZGVidWcoXCJyYXcgc291cmNlIHR4IFwiICsgcmVzLmRhdGEucmF3dHgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXMuZGF0YS5yYXd0eDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cblxuLy8gdGhpcyBzaGl0IGhhcyB0byBiZSBjb21wbGV0ZWx5IGRpZmZlcmVudC5cbi8vICAgICAgICAgZnVuY3Rpb24gc3VibWl0KHNpZ25lZEhleCkge1xuLy8gICAgICAgICAgICAgcmV0dXJuICRodHRwLnBvc3QoYmFzZVVybCwge1xuLy8gICAgICAgICAgICAgICAgIGhleDogc2lnbmVkSGV4XG4vLyAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHJlcykge1xuLy8gICAgICAgICAgICAgICAgIGlmIChyZXMuZGF0YS5lcnJvcikge1xuLy8gICAgICAgICAgICAgICAgICAgICBpZiAocmVzLmRhdGEuZXJyb3IuaW5kZXhPZihcImFscmVhZHkgc3BlbnRcIikgPj0gMCkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdChuZXcgRXJyb3IoXCJTb21lIGlucHV0cyBhbHJlYWR5IHNwZW50LCBwbGVhc2UgdHJ5IHRyYW5zYWN0aW9uIGFnYWluIGluIGEgZmV3IG1pbnV0ZXNcIikpO1xuLy8gICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdChuZXcgRXJyb3IocmVzLmRhdGEuZXJyb3IpKTtcbi8vICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmRhdGE7XG4vLyAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgfVxuXG4vLyB0aGlzIHNoaXQgaGFzIHRvIGJlIGNvbXBsZXRlbHkgZGlmZmVyZW50LlxuICAgICAgICBmdW5jdGlvbiBzdWJtaXQoc2lnbmVkSGV4KSB7XG4gICAgICAgIFx0Y29uc29sZS5kZWJ1ZyhcInJhdyBzaWduZWQgdHggXCIgKyBzaWduZWRIZXgpO1xuICAgICAgICAgICAgcmV0dXJuICRodHRwLnBvc3QoYmFzZVVybCArICcvdHgvc2VuZCcsIHtcbiAgICAgICAgICAgICAgICByYXd0eDogc2lnbmVkSGV4XG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgICAgIGlmIChyZXMuZGF0YS5lcnJvcikge1xuICAgICAgICAgICAgICAgIFx0Y29uc29sZS5kZWJ1ZyhcInR4IGVycm9yIFwiICsgcmVzLmRhdGEuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzLmRhdGEuZXJyb3IuaW5kZXhPZihcImFscmVhZHkgc3BlbnRcIikgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdChuZXcgRXJyb3IoXCJTb21lIGlucHV0cyBhbHJlYWR5IHNwZW50LCBwbGVhc2UgdHJ5IHRyYW5zYWN0aW9uIGFnYWluIGluIGEgZmV3IG1pbnV0ZXNcIikpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRxLnJlamVjdChuZXcgRXJyb3IocmVzLmRhdGEuZXJyb3IpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKFwidHggZ29vZCBcIiArIHJlcy5kYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmRhdGE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0eFV0aWw7XG4gICAgfVxuXG59KSh3aW5kb3csIHdpbmRvdy5hbmd1bGFyKTtcbiIsIihmdW5jdGlvbih3aW5kb3csIGFuZ3VsYXIsIEJpZ051bWJlcikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGFuZ3VsYXIubW9kdWxlKCdiaXRjb2luJylcbiAgICAgICAgLmRpcmVjdGl2ZSgnYmNVbml0U2VsZWN0b3InLCBiY1VuaXRTZWxlY3Rvcik7XG5cbiAgICBiY1VuaXRTZWxlY3Rvci4kaW5qZWN0ID0gWyckcm9vdFNjb3BlJywgJ0NPSU4nLCAnQ29va2llJ107XG5cbiAgICB2YXIgQ09PS0lFX05BTUUgPSAnYml0bG94LWRlbm9tJztcblxuICAgIGZ1bmN0aW9uIGJjVW5pdFNlbGVjdG9yKCRyb290U2NvcGUsIENPSU4sIENvb2tpZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NvcGU6IHRydWUsXG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdiaXRjb2luL3VuaXQtc2VsZWN0b3IuaHRtbCcsXG4gICAgICAgICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYml0Y29pbiA9IG5ldyBCaWdOdW1iZXIoQ09JTik7XG4gICAgICAgICAgICAgICAgdmFyIG1pbGx5ID0gYml0Y29pbi5kaXZpZGVkQnkoMTAwMCk7XG4gICAgICAgICAgICAgICAgdmFyIGJpdCA9IGJpdGNvaW4uZGl2aWRlZEJ5KDEwMDAwMDApO1xuXG4gICAgICAgICAgICAgICAgc2NvcGUub3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgQlRDOiBiaXRjb2luLFxuICAgICAgICAgICAgICAgICAgICBtQlRDOiBtaWxseSxcbiAgICAgICAgICAgICAgICAgICAgYml0czogYml0XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHNjb3BlLmNoYW5nZUN1cnJlbmN5ID0gZnVuY3Rpb24oZGVub20sIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgICAgICAgICBzY29wZS4kd2F0Y2goJ2N1cnJlbnQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjb3BlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuZGVub21pbmF0aW9uID0gc2NvcGUuY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY29wZS5jdXJyZW50LmVxdWFscyhzY29wZS5vcHRpb25zLkJUQykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmN1cnJlbmN5ID0gJ0JUQyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNjb3BlLmN1cnJlbnQuZXF1YWxzKHNjb3BlLm9wdGlvbnMubUJUQykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLmN1cnJlbmN5ID0gJ21CVEMnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzY29wZS5jdXJyZW50LmVxdWFscyhzY29wZS5vcHRpb25zLmJpdHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZS5jdXJyZW5jeSA9ICdiaXRzJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLmN1cnJlbnREaXNwbGF5ID0gJHJvb3RTY29wZS5jdXJyZW5jeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIENvb2tpZS5zZXQoQ09PS0lFX05BTUUsICRyb290U2NvcGUuY3VycmVuY3kpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgY29va2llVmFsID0gQ29va2llLmdldChDT09LSUVfTkFNRSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvb2tpZVZhbCkge1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5jdXJyZW50ID0gc2NvcGUub3B0aW9uc1tjb29raWVWYWxdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLmN1cnJlbnQgPSBiaXRjb2luO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxufSkod2luZG93LCB3aW5kb3cuYW5ndWxhciwgd2luZG93LkJpZ051bWJlcik7XG4iLCIoZnVuY3Rpb24od2luZG93LCBhbmd1bGFyLCBCaWdOdW1iZXIpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBhbmd1bGFyLm1vZHVsZSgnYml0Y29pbicpXG4gICAgICAgIC5kaXJlY3RpdmUoJ2JjVmFsJywgYmNWYWwpO1xuXG4gICAgYmNWYWwuJGluamVjdCA9IFsnJHJvb3RTY29wZScsICckZmlsdGVyJ107XG5cbiAgICBmdW5jdGlvbiBiY1ZhbCgkcm9vdFNjb3BlLCAkZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICAgICAgICBiY1ZhbDogJz0nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IG5ldyBCaWdOdW1iZXIocGFyc2VJbnQoc2NvcGUuYmNWYWwsIDEwKSk7XG5cbiAgICAgICAgICAgICAgICBzY29wZS4kd2F0Y2goJ2JjVmFsJywgZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBuZXcgQmlnTnVtYmVyKHBhcnNlSW50KHYsIDEwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kd2F0Y2goJ2Rlbm9taW5hdGlvbicsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZmlsdGVyID0gJGZpbHRlcignYmNOdW1iZXInKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBudW1TdHIgPSB2YWwuZGl2aWRlZEJ5KCRyb290U2NvcGUuZGVub21pbmF0aW9uKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBudW1TdHIgPSBmaWx0ZXIobnVtU3RyKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbS50ZXh0KG51bVN0ciArIFwiIFwiICsgJHJvb3RTY29wZS5jdXJyZW5jeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxufSkod2luZG93LCB3aW5kb3cuYW5ndWxhciwgd2luZG93LkJpZ051bWJlcik7XG4iLCIoZnVuY3Rpb24od2luZG93LCBhbmd1bGFyKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgYW5ndWxhci5tb2R1bGUoJ2FwcC5jb3JlJylcbiAgICAgICAgLmNvbmZpZyhjb25maWcpO1xuXG4gICAgY29uZmlnLiRpbmplY3QgPSBbJyRyb3V0ZVByb3ZpZGVyJ107XG5cbiAgICBmdW5jdGlvbiBjb25maWcoKSB7XG4gICAgfVxuXG59KSh3aW5kb3csIHdpbmRvdy5hbmd1bGFyKTtcbiIsIihmdW5jdGlvbih3aW5kb3csIGFuZ3VsYXIpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBhbmd1bGFyLm1vZHVsZSgnYXBwLmNvcmUnKVxuICAgICAgICAuZGlyZWN0aXZlKCdleHBlcnRNb2RlJywgZXhwZXJ0TW9kZSk7XG5cbiAgICBleHBlcnRNb2RlLiRpbmplY3QgPSBbJyRyb290U2NvcGUnLCAnQ29va2llJ107XG5cbiAgICB2YXIgQ09PS0lFX05BTUUgPSAnYml0bG94LWV4cGVydCc7XG5cbiAgICBmdW5jdGlvbiBleHBlcnRNb2RlKCRyb290U2NvcGUsIENvb2tpZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NvcGU6IHRydWUsXG4gICAgICAgICAgICByZXN0cmljdDogJ0UnLFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdjb3JlL2V4cGVydC1tb2RlLmh0bWwnLFxuICAgICAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlKSB7XG5cbiAgICAgICAgICAgICAgICBzY29wZS5zdGF0dXMgPSBcIkFjdGl2YXRlIEV4cGVydCBNb2RlXCI7XG4gICAgICAgICAgICAgICAgc2NvcGUuJHdhdGNoKCdjdXJyZW50JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuZXhwZXJ0TW9kZSA9IHNjb3BlLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnN0YXR1cyA9IHNjb3BlLmN1cnJlbnQgPyBcIkV4cGVydCBNb2RlIEFjdGl2ZVwiIDogXCJBY3RpdmF0ZSBFeHBlcnQgTW9kZVwiO1xuICAgICAgICAgICAgICAgICAgICBDb29raWUuc2V0KENPT0tJRV9OQU1FLCAkcm9vdFNjb3BlLmV4cGVydE1vZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNvb2tpZVZhbCA9IENvb2tpZS5nZXQoQ09PS0lFX05BTUUpO1xuICAgICAgICAgICAgICAgIGlmIChjb29raWVWYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuY3VycmVudCA9IGNvb2tpZVZhbCA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG59KSh3aW5kb3csIHdpbmRvdy5hbmd1bGFyKTtcbiIsIihmdW5jdGlvbih3aW5kb3csIGFuZ3VsYXIpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBhbmd1bGFyLm1vZHVsZSgnYXBwLmNvcmUnKVxuICAgICAgICAuY29udHJvbGxlcignSG9tZUN0cmwnLCBIb21lQ3RybCk7XG5cbiAgICBIb21lQ3RybC4kaW5qZWN0ID0gWyckdGltZW91dCcsICdoaWRhcGknLCAnVG9hc3QnXTtcblxuXG5cbiAgICBmdW5jdGlvbiBIb21lQ3RybCgkdGltZW91dCwgaGlkYXBpLCBUb2FzdCkge1xuICAgICAgICB2YXIgdm0gPSB0aGlzO1xuXG4gICAgICAgIHZhciBjaGVja0RldmljZSA9IHZtLmNoZWNrRGV2aWNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2bS5vcGVuaW5nRGV2aWNlID0gdHJ1ZTtcbiAgICAgICAgICAgIGhpZGFwaS5waW5nKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBoaWRhcGkudXVpZCgpLnRoZW4oZnVuY3Rpb24odXVpZCkge1xuICAgICAgICAgICAgICAgICAgICB2bS51dWlkID0gdXVpZDtcbiAgICAgICAgICAgICAgICAgICAgdm0ub3BlbmluZ0RldmljZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sIFRvYXN0LmVycm9ySGFuZGxlcik7XG4gICAgICAgICAgICB9LCBUb2FzdC5lcnJvckhhbmRsZXIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNoZWNrRGV2aWNlKCk7XG5cbiAgICB9XG5cbn0pKHdpbmRvdywgd2luZG93LmFuZ3VsYXIpO1xuIiwiKGZ1bmN0aW9uKHdpbmRvdywgYW5ndWxhcikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGFuZ3VsYXIubW9kdWxlKCdhcHAuY29yZScpXG4gICAgICAgIC5jb250cm9sbGVyKCdOYXZDdHJsJywgTmF2Q3RybCk7XG5cbiAgICBOYXZDdHJsLiRpbmplY3QgPSBbXTtcblxuICAgIGZ1bmN0aW9uIE5hdkN0cmwoKSB7XG4gICAgfVxuXG59KSh3aW5kb3csIHdpbmRvdy5hbmd1bGFyKTtcbiIsIihmdW5jdGlvbih3aW5kb3csIGFuZ3VsYXIpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBhbmd1bGFyLm1vZHVsZSgnYXBwLmNvcmUnKVxuICAgICAgICAuY29uZmlnKFsnJHByb3ZpZGUnLCBmdW5jdGlvbigkcHJvdmlkZSkge1xuICAgICAgICAgICAgLy8gRml4IHNvdXJjZW1hcHNcbiAgICAgICAgICAgIC8vIEB1cmwgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci5qcy9pc3N1ZXMvNTIxNyNpc3N1ZWNvbW1lbnQtNTA5OTM1MTNcbiAgICAgICAgICAgICRwcm92aWRlLmRlY29yYXRvcignJGV4Y2VwdGlvbkhhbmRsZXInLCBbJyRkZWxlZ2F0ZScsIGZ1bmN0aW9uKCRkZWxlZ2F0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihleGNlcHRpb24sIGNhdXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICRkZWxlZ2F0ZShleGNlcHRpb24sIGNhdXNlKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1dKTtcbiAgICAgICB9XSk7XG5cbn0pKHdpbmRvdywgd2luZG93LmFuZ3VsYXIpO1xuIiwiKGZ1bmN0aW9uKHdpbmRvdywgYW5ndWxhcikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGFuZ3VsYXIubW9kdWxlKCdhcHAuY29yZScpXG4gICAgICAgIC5jb250cm9sbGVyKCdTdGF0dXNDdHJsJywgU3RhdHVzQ3RybCk7XG5cbiAgICBTdGF0dXNDdHJsLiRpbmplY3QgPSBbJ2hpZGFwaScsICdXYWxsZXRTdGF0dXMnXTtcblxuICAgIGZ1bmN0aW9uIFN0YXR1c0N0cmwoaGlkYXBpLCBXYWxsZXRTdGF0dXMpIHtcbiAgICAgICAgdmFyIHZtID0gdGhpcztcblxuICAgICAgICB2bS5iaXRsb3ggPSB7XG4gICAgICAgICAgICBjb25uZWN0QXR0ZW1wdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbm5lY3RlZDogdHJ1ZSxcbiAgICAgICAgICAgIHN0YXR1czogXCJObyBCaXRsb3hcIixcbiAgICAgICAgICAgIGFsZXJ0Q2xhc3M6IFwiZGFuZ2VyXCJcbiAgICAgICAgfTtcblxuICAgICAgICB2bS53YWxsZXQgPSB7XG4gICAgICAgICAgICBzdGF0dXM6IFwiTm8gV2FsbGV0XCIsXG4gICAgICAgICAgICBhbGVydENsYXNzOiBcIndhcm5pbmdcIlxuICAgICAgICB9O1xuXG4gICAgICAgIHZtLnJlZnJlc2hCaXRsb3ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGhpZGFwaS5waW5nKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaGlkYXBpLiRzY29wZS4kd2F0Y2goJ3N0YXR1cycsIGZ1bmN0aW9uKGhpZHN0YXR1cykge1xuICAgICAgICAgICAgc3dpdGNoKGhpZHN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBoaWRhcGkuU1RBVFVTX0NPTk5FQ1RFRDpcbiAgICAgICAgICAgICAgICB2bS5iaXRsb3guY29ubmVjdEF0dGVtcHRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdm0uYml0bG94LmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdm0uYml0bG94LnN0YXR1cyA9IFwiQml0bG94IGNvbm5lY3RlZFwiO1xuICAgICAgICAgICAgICAgIHZtLmJpdGxveC5hbGVydENsYXNzID0gXCJzdWNjZXNzXCI7XG4gICAgICAgICAgICAgICAgdm0uYml0bG94LmdseXBoID0gXCJnbHlwaGljb24tb2tcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgaGlkYXBpLlNUQVRVU19ESVNDT05ORUNURUQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRElTQ09OTkVDVEVEXCIpO1xuICAgICAgICAgICAgICAgIHZtLmJpdGxveC5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2bS5iaXRsb3guc3RhdHVzID0gXCJCaXRsb3ggZGlzY29ubmVjdGVkIVwiO1xuICAgICAgICAgICAgICAgIHZtLmJpdGxveC5hbGVydENsYXNzID0gXCJkYW5nZXJcIjtcbiAgICAgICAgICAgICAgICB2bS5iaXRsb3guZ2x5cGggPSBcImdseXBoaWNvbi1yZW1vdmVcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgaGlkYXBpLlNUQVRVU19XUklUSU5HOlxuICAgICAgICAgICAgICAgIHZtLmJpdGxveC5jb25uZWN0QXR0ZW1wdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2bS5iaXRsb3guY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2bS5iaXRsb3guc3RhdHVzID0gXCJCaXRsb3ggd3JpdGluZ1wiO1xuICAgICAgICAgICAgICAgIHZtLmJpdGxveC5hbGVydENsYXNzID0gXCJpbmZvXCI7XG4gICAgICAgICAgICAgICAgdm0uYml0bG94LmdseXBoID0gXCJnbHlwaGljb24tdXBsb2FkXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGhpZGFwaS5TVEFUVVNfUkVBRElORzpcbiAgICAgICAgICAgICAgICB2bS5iaXRsb3guY29ubmVjdEF0dGVtcHRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdm0uYml0bG94LmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdm0uYml0bG94LnN0YXR1cyA9IFwiQml0bG94IHJlYWRpbmdcIjtcbiAgICAgICAgICAgICAgICB2bS5iaXRsb3guYWxlcnRDbGFzcyA9IFwiaW5mb1wiO1xuICAgICAgICAgICAgICAgIHZtLmJpdGxveC5nbHlwaCA9IFwiZ2x5cGhpY29uLWRvd25sb2FkXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHZtLmJpdGxveC5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2bS5iaXRsb3guc3RhdHVzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgV2FsbGV0U3RhdHVzLiR3YXRjaCgnc3RhdHVzJywgZnVuY3Rpb24od2FsbGV0c3RhdHVzKSB7XG4gICAgICAgICAgICBzd2l0Y2god2FsbGV0c3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIFdhbGxldFN0YXR1cy5TVEFUVVNfTE9BRElORzpcbiAgICAgICAgICAgICAgICB2bS53YWxsZXQuc3RhdHVzID0gXCJMb2FkaW5nIHdhbGxldFwiO1xuICAgICAgICAgICAgICAgIHZtLndhbGxldC5hbGVydENsYXNzID0gXCJpbmZvXCI7XG4gICAgICAgICAgICAgICAgdm0ud2FsbGV0LmdseXBoID0gXCJnbHlwaGljb24tZG93bmxvYWRcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgV2FsbGV0U3RhdHVzLlNUQVRVU19MT0FESU5HX1VOU1BFTlQ6XG4gICAgICAgICAgICAgICAgdm0ud2FsbGV0LnN0YXR1cyA9IFwiRmluZGluZyB1bnNwZW50IG91dHB1dHNcIjtcbiAgICAgICAgICAgICAgICB2bS53YWxsZXQuYWxlcnRDbGFzcyA9IFwiaW5mb1wiO1xuICAgICAgICAgICAgICAgIHZtLndhbGxldC5nbHlwaCA9IFwiZ2x5cGhpY29uLWNsb3VkLWRvd25sb2FkXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFdhbGxldFN0YXR1cy5TVEFUVVNfTE9BRElOR19UUkFOU0FDVElPTlM6XG4gICAgICAgICAgICAgICAgdm0ud2FsbGV0LnN0YXR1cyA9IFwiRmluZGluZyB0cmFuc2FjdGlvbnNcIjtcbiAgICAgICAgICAgICAgICB2bS53YWxsZXQuYWxlcnRDbGFzcyA9IFwiaW5mb1wiO1xuICAgICAgICAgICAgICAgIHZtLndhbGxldC5nbHlwaCA9IFwiZ2x5cGhpY29uLWNsb3VkLWRvd25sb2FkXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFdhbGxldFN0YXR1cy5TVEFUVVNfU0VORElORzpcbiAgICAgICAgICAgICAgICB2bS53YWxsZXQuc3RhdHVzID0gXCJXYWxsZXQgc2VuZGluZ1wiO1xuICAgICAgICAgICAgICAgIHZtLndhbGxldC5hbGVydENsYXNzID0gXCJpbmZvXCI7XG4gICAgICAgICAgICAgICAgdm0ud2FsbGV0LmdseXBoID0gXCJnbHlwaGljb24tbG9nLW91dFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBXYWxsZXRTdGF0dXMuU1RBVFVTX1NJR05JTkc6XG4gICAgICAgICAgICAgICAgdm0ud2FsbGV0LnN0YXR1cyA9IFwiV2FsbGV0IHNpZ25pbmdcIjtcbiAgICAgICAgICAgICAgICB2bS53YWxsZXQuYWxlcnRDbGFzcyA9IFwiaW5mb1wiO1xuICAgICAgICAgICAgICAgIHZtLndhbGxldC5nbHlwaCA9IFwiZ2x5cGhpY29uLXBlbmNpbFwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB2bS53YWxsZXQuc3RhdHVzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cblxuICAgIH1cblxufSkod2luZG93LCB3aW5kb3cuYW5ndWxhcik7XG4iLCIoZnVuY3Rpb24od2luZG93LCBhbmd1bGFyKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgYW5ndWxhci5tb2R1bGUoJ2hpZCcpXG4gICAgICAgIC5jb25zdGFudCgnVkVORE9SX0lEJywgMHgwM0VCKVxuICAgICAgICAuY29uc3RhbnQoJ1BST0RVQ1RfSUQnLCAweDIwNEYpO1xuXG59KSh3aW5kb3csIHdpbmRvdy5hbmd1bGFyKTtcbiIsIihmdW5jdGlvbih3aW5kb3csIGFuZ3VsYXIpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBhbmd1bGFyLm1vZHVsZSgnaGlkJylcbiAgICAgICAgLmNvbnN0YW50KCdoaWRDb21tYW5kcycsIHtcbiAgICAgICAgICAgIGJ1dHRvbl9hY2s6ICcyMzIzMDA1MTAwMDAwMDAwJyxcbiAgICAgICAgICAgIGZvcm1hdF9zdG9yYWdlOiAnMjMyMzAwMEQwMDAwMDAyMjBBMjA0MjQyNDI0MjQyNDI0MjQyNDI0MjQyNDI0MjQyNDI0MjQyNDI0MjQyNDI0MjQyNDI0MjQyNDI0MjQyNDI0MjQyJyxcblxuICAgICAgICAgICAgbGlzdF93YWxsZXRzOiAgJzIzMjMwMDEwMDAwMDAwMDAnLFxuXG4gICAgICAgICAgICBzY2FuX3dhbGxldDogICAnMjMyMzAwNjEwMDAwMDAwMCcsXG5cbiAgICAgICAgICAgIC8vIHByZWZpeGVzIGZvciBjb21tYW5kcyB0aGF0IHRha2UgaW4gYSB2YXJpYWJsZSBhbW91bnQgb2ZcbiAgICAgICAgICAgIC8vIGRhdGEsIGEgY29udGVudCBzaXplIGFuZCB0aGUgcGF5bG9hZCBkYXRhIGlzIGFwcGVuZGVkXG4gICAgICAgICAgICBuZXdXYWxsZXRQcmVmaXg6ICcyMzIzMDAwNCcsXG4gICAgICAgICAgICByZXN0b3JlV2FsbGV0UHJlZml4OiAnMjMyMzAwMTgnLFxuICAgICAgICAgICAgcmVuYW1lV2FsbGV0UHJlZml4OiAnMjMyMzAwMEYnLFxuICAgICAgICAgICAgc2lnblR4UHJlZml4OiAgICAnMjMyMzAwNjUnLFxuICAgICAgICAgICAgc2lnbk1lc3NhZ2VQcmVmaXg6ICcyMzIzMDA3MCcsXG4gICAgICAgICAgICBvdHBQcmVmaXg6ICcyMzIzMDA1NycsXG4gICAgICAgICAgICBxclByZWZpeDogJzIzMjMwMDgwJyxcbiAgICAgICAgICAgIHNldENoYW5nZVByZWZpeDogJzIzMjMwMDY2JyxcblxuICAgICAgICAgICAgLy8gdGhlc2UganVzdCBnZXQgb25lIGJ5dGUgb2YgaGV4IGZvciB0aGUgd2FsbGV0IG51bWJlclxuICAgICAgICAgICAgLy8gYWRkZWQgdG8gdGhlbVxuICAgICAgICAgICAgZGVsZXRlV2FsbGV0UHJlZml4OiAnMjMyMzAwMTYwMDAwMDAwMjA4JyxcbiAgICAgICAgICAgIGxvYWRXYWxsZXRQcmVmaXg6ICcyMzIzMDAwQjAwMDAwMDAyMDgnLFxuXG4gICAgICAgICAgICAvLyBqdXN0IGEgcGluZ1xuICAgICAgICAgICAgcGluZzogJzIzMjMwMDAwMDAwMDAwMDcwQTA1NDg2NTZDNkM2RicsXG5cbiAgICAgICAgfSk7XG5cbn0pKHdpbmRvdywgd2luZG93LmFuZ3VsYXIpO1xuIiwiKGZ1bmN0aW9uKHdpbmRvdywgYW5ndWxhciwgYXN5bmMsIFByb3RvQnVmLCBCeXRlQnVmZmVyKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgYW5ndWxhci5tb2R1bGUoJ2hpZCcpXG4gICAgICAgIC5zZXJ2aWNlKCdoaWRhcGknLCBIaWRBUEkpO1xuXG4gICAgSGlkQVBJLiRpbmplY3QgPSBbXG4gICAgICAgICckcScsICckdGltZW91dCcsICckaW50ZXJ2YWwnLCAnJHJvb3RTY29wZScsXG4gICAgICAgICdUb2FzdCcsICdoZXhVdGlsJywgJ3R4VXRpbCcsICdtZXNzYWdlVXRpbCcsXG4gICAgICAgICdWRU5ET1JfSUQnLCAnUFJPRFVDVF9JRCcsICdSRUNFSVZFX0NIQUlOJywgJ0NIQU5HRV9DSEFJTicsXG4gICAgICAgICdoaWRDb21tYW5kcydcbiAgICBdO1xuXG4gICAgdmFyIFBVTFNFX0lOVEVSVkFMID0gKDMwICogMTAwMCk7XG5cbiAgICBmdW5jdGlvbiBIaWRBUEkoJHEsICR0aW1lb3V0LCAkaW50ZXJ2YWwsICRyb290U2NvcGUsXG4gICAgICAgICAgICAgICAgICAgIFRvYXN0LCBoZXhVdGlsLCB0eFV0aWwsIG1lc3NhZ2VVdGlsLFxuICAgICAgICAgICAgICAgICAgICBWRU5ET1JfSUQsIFBST0RVQ1RfSUQsIFJFQ0VJVkVfQ0hBSU4sIENIQU5HRV9DSEFJTixcbiAgICAgICAgICAgICAgICAgICAgaGlkQ29tbWFuZHMpIHtcbiAgICAgICAgdGhpcy5WRU5ET1JfSUQgPSBWRU5ET1JfSUQ7XG4gICAgICAgIHRoaXMuUFJPRFVDVF9JRCA9IFBST0RVQ1RfSUQ7XG4gICAgICAgIHRoaXMuUkVDRUlWRV9DSEFJTiA9IFJFQ0VJVkVfQ0hBSU47XG4gICAgICAgIHRoaXMuQ0hBTkdFX0NIQUlOID0gQ0hBTkdFX0NIQUlOO1xuICAgICAgICB0aGlzLlRvYXN0ID0gVG9hc3Q7XG4gICAgICAgIHRoaXMuX3BsdWdpbiA9IG51bGw7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IG51bGw7XG4gICAgICAgIHRoaXMucGF0aCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2RldmljZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2J1aWxkZXIgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuJHEgPSAkcTtcbiAgICAgICAgdGhpcy4kdGltZW91dCA9ICR0aW1lb3V0O1xuICAgICAgICB0aGlzLiRpbnRlcnZhbCA9ICRpbnRlcnZhbDtcblxuICAgICAgICB0aGlzLmNvbW1hbmRzID0gaGlkQ29tbWFuZHM7XG5cbiAgICAgICAgdGhpcy5oZXhVdGlsID0gaGV4VXRpbDtcbiAgICAgICAgdGhpcy5tZXNzYWdlVXRpbCA9IG1lc3NhZ2VVdGlsO1xuICAgICAgICB0aGlzLmdldFR4SGV4ID0gdHhVdGlsLmdldEhleDtcblxuICAgICAgICB0aGlzLiRzY29wZSA9ICRyb290U2NvcGUuJG5ldygpO1xuICAgICAgICB0aGlzLiRzY29wZS5zdGF0dXMgPSBIaWRBUEkuU1RBVFVTX0RJU0NPTk5FQ1RFRDtcbiAgICB9XG5cbiAgICBIaWRBUEkuVFlQRV9JTklUSUFMSVpFICAgICAgICAgPSBIaWRBUEkucHJvdG90eXBlLlRZUEVfSU5JVElBTElaRSA9ICdpbml0aWFsaXplJztcbiAgICBIaWRBUEkuVFlQRV9QVUJMSUNfQUREUkVTUyAgICAgPSBIaWRBUEkucHJvdG90eXBlLlRZUEVfUFVCTElDX0FERFJFU1MgPSAncHVibGljIGFkZHJlc3MnO1xuICAgIEhpZEFQSS5UWVBFX0FERFJFU1NfQ09VTlQgICAgICA9IEhpZEFQSS5wcm90b3R5cGUuVFlQRV9BRERSRVNTX0NPVU5UID0gJ2FkZHJlc3MgY291bnQnO1xuICAgIEhpZEFQSS5UWVBFX1dBTExFVF9MSVNUICAgICAgICA9IEhpZEFQSS5wcm90b3R5cGUuVFlQRV9XQUxMRVRfTElTVCA9ICd3YWxsZXQgbGlzdCc7XG4gICAgSGlkQVBJLlRZUEVfUE9ORyAgICAgICAgICAgICAgID0gSGlkQVBJLnByb3RvdHlwZS5UWVBFX1BPTkcgPSAncG9uZyc7XG4gICAgSGlkQVBJLlRZUEVfU1VDQ0VTUyAgICAgICAgICAgID0gSGlkQVBJLnByb3RvdHlwZS5UWVBFX1NVQ0NFU1MgPSAnc3VjY2Vzcyc7XG4gICAgSGlkQVBJLlRZUEVfRVJST1IgICAgICAgICAgICAgID0gSGlkQVBJLnByb3RvdHlwZS5UWVBFX0VSUk9SID0gJ2Vycm9yJztcbiAgICBIaWRBUEkuVFlQRV9VVUlEICAgICAgICAgICAgICAgPSBIaWRBUEkucHJvdG90eXBlLlRZUEVfVVVJRCA9ICd1dWlkJztcbiAgICBIaWRBUEkuVFlQRV9TSUdOQVRVUkUgICAgICAgICAgPSBIaWRBUEkucHJvdG90eXBlLlRZUEVfU0lHTkFUVVJFID0gJ3NpZ25hdHVyZSc7XG4gICAgSGlkQVBJLlRZUEVfUExFQVNFX0FDSyAgICAgICAgID0gSGlkQVBJLnByb3RvdHlwZS5UWVBFX1BMRUFTRV9BQ0sgPSAncGxlYXNlIGFjayc7XG4gICAgSGlkQVBJLlRZUEVfUExFQVNFX09UUCAgICAgICAgID0gSGlkQVBJLnByb3RvdHlwZS5UWVBFX1BMRUFTRV9PVFAgPSAncGxlYXNlIG90cCc7XG4gICAgSGlkQVBJLlRZUEVfWFBVQiAgICAgICAgICAgICAgID0gSGlkQVBJLnByb3RvdHlwZS5UWVBFX1hQVUIgPSAneHB1Yic7XG4gICAgSGlkQVBJLlRZUEVfU0lHTkFUVVJFX1JFVFVSTiAgID0gSGlkQVBJLnByb3RvdHlwZS5UWVBFX1NJR05BVFVSRV9SRVRVUk4gPSAnc2lnbmF0dXJlIHJldHVybic7XG4gICAgSGlkQVBJLlRZUEVfTUVTU0FHRV9TSUdOQVRVUkUgID0gSGlkQVBJLnByb3RvdHlwZS5UWVBFX01FU1NBR0VfU0lHTkFUVVJFID0gJ21lc3NhZ2Ugc2lnbmF0dXJlJztcblxuICAgIEhpZEFQSS5TVEFUVVNfRElTQ09OTkVDVEVEICAgICA9IEhpZEFQSS5wcm90b3R5cGUuU1RBVFVTX0RJU0NPTk5FQ1RFRCA9IFwiZGlzY29ubmVjdGVkXCI7XG4gICAgSGlkQVBJLlNUQVRVU19DT05ORUNURUQgICAgICAgID0gSGlkQVBJLnByb3RvdHlwZS5TVEFUVVNfQ09OTkVDVEVEID0gXCJjb25uZWN0ZWRcIjtcbiAgICBIaWRBUEkuU1RBVFVTX1JFQURJTkcgICAgICAgICAgPSBIaWRBUEkucHJvdG90eXBlLlNUQVRVU19SRUFESU5HID0gXCJyZWFkaW5nXCI7XG4gICAgSGlkQVBJLlNUQVRVU19XUklUSU5HICAgICAgICAgID0gSGlkQVBJLnByb3RvdHlwZS5TVEFUVVNfV1JJVElORyA9IFwid3JpdGluZ1wiO1xuXG5cbiAgICAvLyBmdW5jdGlvbiB0byBnZXQgdGhlIHBsdWdpbiBmcm9tIHRoZSBkb2N1bWVudCBlbGVtZW50XG4gICAgSGlkQVBJLnByb3RvdHlwZS5wbHVnaW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BsdWdpbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcInBsdWdpbjogZGV2aWNlIGlzIG51bGwsIGZpbmRpbmcgb24gZG9jdW1lbnRcIik7XG4gICAgICAgICAgICB0aGlzLl9wbHVnaW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaGlkYXBpUGx1Z2luJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5kZWJ1ZyhcInBsdWdpbjogZm91bmRcIiwgdGhpcy5fcGx1Z2luKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BsdWdpbjtcbiAgICB9O1xuXG4gICAgLy8gR2V0IHRoZSBkZXZpY2UuIElmIHdlIGFscmVheSBoYXZlIGl0LCBqdXN0IHJldHVybiBpdC5cbiAgICAvLyBPdGhlcndpc2UsIGRvIGEgaGlkcmF3IHNjYW4gYW5kIGZpbmQsIHRoZW4gb3BlbiwgdGhlIGRldmljZVxuICAgIEhpZEFQSS5wcm90b3R5cGUuZGV2aWNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoaWRhcGkgPSB0aGlzO1xuICAgICAgICBpZiAoaGlkYXBpLl9kZXZpY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBoaWRhcGkuX2RldmljZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGlkYXBpLnB1bHNlKSB7XG4gICAgICAgICAgICBoaWRhcGkuJGludGVydmFsLmNhbmNlbChoaWRhcGkucHVsc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCB0aGUgaGlkIHBsdWdpblxuICAgICAgICBjb25zb2xlLmRlYnVnKFwiZGV2aWNlOiBsb29raW5nIGZvciBwbHVnaW5cIik7XG4gICAgICAgIHZhciBwbHVnaW4gPSBoaWRhcGkucGx1Z2luKCk7XG4gICAgICAgIGlmIChwbHVnaW4gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGhpZGFwaS5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGhpZGFwaS5fZGV2aWNlOyAvLyBpdCdzIHN0aWxsIG51bGxcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmRlYnVnKFwiZGV2aWNlOiBmb3VuZCBwbHVnaW5cIiwgcGx1Z2luKTtcbiAgICAgICAgLy8gYW5kIGxpc3QgYWxsIG9mIHRoZSBoaWRyYXcgZGV2aWNlcyB0aGF0IG1hdGNoIG91clxuICAgICAgICAvLyB2ZW5kb3IgYW5kIHByb2R1Y3QgaWRzXG4gICAgICAgIGNvbnNvbGUuZGVidWcoXCJkZXZpY2U6IGxvb2tpbmcgZm9yIGRldmljZXNcIik7XG4gICAgICAgIHZhciBkZXZpY2VzID0gcGx1Z2luLmhpZF9lbnVtZXJhdGUoaGlkYXBpLlZFTkRPUl9JRCwgaGlkYXBpLlBST0RVQ1RfSUQpO1xuICAgICAgICBjb25zb2xlLmRlYnVnKFwiZGV2aWNlOiBmb3VuZCBkZXZpY2VzXCIsIGRldmljZXMpO1xuICAgICAgICAvLyBpZiB3ZSBkbyBub3QgZmluZCBpdCwgcmV0dXJuIG51bGxcbiAgICAgICAgaWYgKCFkZXZpY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgaGlkYXBpLmNsb3NlKCk7XG4gICAgICAgICAgICBoaWRhcGkuVG9hc3QuZXJyb3IoXCJObyBkZXZpY2VzIGNvbm5lY3RlZFwiKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIG90aGVyd2lzZSwgZ2V0IHRoZSBwYXRoXG4gICAgICAgIHZhciBwYXRoID0gaGlkYXBpLnBhdGggPSBkZXZpY2VzWzBdLnBhdGg7XG4gICAgICAgIC8vIGFuZCBvcGVuIGl0XG4gICAgICAgIGNvbnNvbGUuZGVidWcoXCJkZXZpY2U6IG9wZW5pbmcgcGF0aFwiLCBwYXRoKTtcbiAgICAgICAgaGlkYXBpLl9kZXZpY2UgPSBoaWRhcGkucGx1Z2luKCkuaGlkX29wZW5fcGF0aChwYXRoKTtcbiAgICAgICAgY29uc29sZS5kZWJ1ZyhcImRldmljZTogcGF0aCBvcGVuZWRcIiwgaGlkYXBpLl9kZXZpY2UpO1xuICAgICAgICAvLyBpZiB0aGUgZGV2aWNlIGlzIG51bGwgc3RpbGwsIHRoZXJlIHdhcyBhbiBlcnJvciBvcGVuaW5nIHRoZVxuICAgICAgICAvLyBwYXRoXG4gICAgICAgIGlmIChoaWRhcGkuX2RldmljZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaGlkYXBpLmNsb3NlKCk7XG4gICAgICAgICAgICBoaWRhcGkuVG9hc3QuZXJyb3IoXCJFcnJvciBvcGVuaW5nIGRldmljZVwiKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGhpZGFwaS4kc2NvcGUuc3RhdHVzID0gaGlkYXBpLlNUQVRVU19DT05ORUNURUQ7XG4gICAgICAgIC8vIHNldCB1cCB0aGUgaGVhcnRiZWF0IGludGVydmFsIGlmIGl0IGRvZXMgbm93IGV4aXN0XG4gICAgICAgIGlmICghaGlkYXBpLnB1bHNlKSB7XG4gICAgICAgICAgICBoaWRhcGkucHVsc2UgPSBoaWRhcGkuJGludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgZG8gdGhpcyBpZiB3ZSBhcmUgbm90IGFscmVhZHkgZG9pbmcgc29tZXRoaW5nXG4gICAgICAgICAgICAgICAgaWYgKCFoaWRhcGkuZG9pbmdDb21tYW5kICYmXG4gICAgICAgICAgICAgICAgICAgIGhpZGFwaS4kc2NvcGUuc3RhdHVzICE9PSBoaWRhcGkuU1RBVFVTX1JFQURJTkcgJiZcbiAgICAgICAgICAgICAgICAgICAgaGlkYXBpLiRzY29wZS5zdGF0dXMgIT09IGhpZGFwaS5TVEFUVVNfV1JJVElORykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKFwiaGVhcnRiZWF0XCIpO1xuICAgICAgICAgICAgICAgICAgICBoaWRhcGkucGluZygpLmNhdGNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGlkYXBpLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFBVTFNFX0lOVEVSVkFMKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXR1cm4gdGhlIG5ld2x5IGZvdW5kIGRldmljZVxuICAgICAgICByZXR1cm4gaGlkYXBpLl9kZXZpY2U7XG4gICAgfTtcblxuICAgIEhpZEFQSS5wcm90b3R5cGUucHJvdG9CdWlsZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9idWlsZGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgYnVpbGRlciA9IFByb3RvQnVmLmxvYWRQcm90b0ZpbGUoXCJwcm90by9tZXNzYWdlcy5wcm90b1wiKTtcbiAgICAgICAgICAgIHRoaXMuX2J1aWxkZXIgPSBidWlsZGVyLmJ1aWxkKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1aWxkZXI7XG4gICAgfTtcblxuICAgIEhpZEFQSS5wcm90b3R5cGUucGx1Z2luRGV0ZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwbHVnaW4gPSBuYXZpZ2F0b3IucGx1Z2luc1tuYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZihwbHVnaW4pICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB2YXIgcmUgPSAvKFswLTkuXSspXFwuZGxsLzsgLy8gbG9vayBmb3IgdGhlIHZlcnNpb24gYXQgdGhlIGVuZCBvZiB0aGUgZmlsZW5hbWUsIGJlZm9yZSBkbGxcbiAgICAgICAgICAgIC8vIEdldCB0aGUgZmlsZW5hbWVcbiAgICAgICAgICAgIHZhciBmaWxlbmFtZSA9IHBsdWdpbi5maWxlbmFtZTtcbiAgICAgICAgICAgIC8vIFNlYXJjaCBmb3IgdGhlIHZlcnNpb25cbiAgICAgICAgICAgIHZhciBmbmQ7XG4gICAgICAgICAgICBmbmQgPSByZS5leGVjKGZpbGVuYW1lKTtcbiAgICAgICAgICAgIGlmIChmbmQgPT09IG51bGwpIHsgLy8gbm8gdmVyc2lvbiBmb3VuZFxuICAgICAgICAgICAgICAgIGlmIChwbHVnaW4udmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZlcnNpb24gPSBwbHVnaW4udmVyc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVyc2lvbjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gcGx1Z2luIGluc3RhbGxlZCwgdW5rbm93biB2ZXJzaW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnNpb24gPSBmbmRbMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVyc2lvbjsgLy8gcGx1Z2luIGluc3RhbGxlZCwgcmV0dXJuaW5nIHZlcnNpb25cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlBsdWdpbiBtaXNzaW5nXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgSGlkQVBJLnByb3RvdHlwZS5jaHVua0RhdGEgPSBmdW5jdGlvbihkYXRhLCBjaHVua1NpemUpIHtcbiAgICAgICAgaWYgKGNodW5rU2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaHVua1NpemUgPSAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhLm1hdGNoKG5ldyBSZWdFeHAoJy57MSwnICsgY2h1bmtTaXplICsgJ30nLCAnZycpKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcGF1c2Vjb21wKG1pbGxpc2Vjb25kcykge1xuICAgICAgICB2YXIgc3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxZTc7IGkrKykge1xuICAgICAgICAgICAgaWYgKChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0KSA+IG1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgSGlkQVBJLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIGhpZGFwaSA9IHRoaXM7XG4gICAgICAgIGhpZGFwaS4kc2NvcGUuc3RhdHVzID0gaGlkYXBpLlNUQVRVU19XUklUSU5HO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSB0aGlzLiRxLmRlZmVyKCk7XG4gICAgICAgIHRoaXMuJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBnZXQgdGhlIGRldmljZVxuICAgICAgICAgICAgdmFyIGRldiA9IGhpZGFwaS5kZXZpY2UoKTtcbiAgICAgICAgICAgIGlmIChkZXYgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBoaWRhcGkuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucmVqZWN0KG5ldyBFcnJvcihcIk5vIGRldmljZSB0byB3cml0ZSB0b1wiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayByZW1haW5kZXIgYWdhaW5zdCA4IGJ5dGVzIGFuZCBhZGQgNCBudWxsIGJ5dGVzIGlmIHdlXG4gICAgICAgICAgICAvLyBoYXZlIDAsIDYsIG9yIDcgYnl0ZXMgb2Ygc3BhY2UgbGVmdCBvdmVyXG4gICAgICAgICAgICB2YXIgcmVtYWluZGVyID0gZGF0YS5sZW5ndGggJSAxNjtcbiAgICAgICAgICAgIGlmIChyZW1haW5kZXIgPT09IDAgfHwgcmVtYWluZGVyID09PSAxMiB8fCByZW1haW5kZXIgPT09IDE0KSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9ICcwMDAwMDAwMCcgKyBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3BsaXQgaW50byAxNiBieXRlIGNodW5rc1xuICAgICAgICAgICAgdmFyIGNodW5rcyA9IGhpZGFwaS5jaHVua0RhdGEoZGF0YSwgMzIpO1xuICAgICAgICAgICAgLy8ga2VlcCB0cmFjayBvZiB0aGUgdG90YWwgc2VudFxuICAgICAgICAgICAgdmFyIHRvdGFsU2VudCA9IDA7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRoaXNEYXRhID0gY2h1bmtzW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0RhdGEgPSAnMDAnICsgdGhpc0RhdGE7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgdGhlIGZpbmFsIGNodW5rLCBhcHBlbmQgdGhlIHRlcm1pbmF0b3JcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxID09PSBjaHVua3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzRGF0YSArPSAnN0U3RSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gd3JpdGUgdG8gdGhlIGRldmljZVxuICAgICAgICAgICAgICAgICAgICB2YXIgdHhSZXN1bHQgPSBkZXYuaGlkX3dyaXRlKHRoaXNEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcGF1c2Vjb21wKDUwKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgZGlkIG5vdCB3cml0ZSBhbnl0aGluZywgcmV0dXJuIDAgdG8gZmFpbCB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VuZFxuICAgICAgICAgICAgICAgICAgICBpZiAodHhSZXN1bHQgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGlkYXBpLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucmVqZWN0KG5ldyBFcnJvcihcIldyaXRlIGVycm9yXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdG8gdGhlIHRvdGFsIHNlbnRcbiAgICAgICAgICAgICAgICAgICAgdG90YWxTZW50ICs9IHR4UmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5yZXNvbHZlKHRvdGFsU2VudCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaGlkYXBpLiRzY29wZS5zdGF0dXMgPSBoaWRhcGkuU1RBVFVTX0NPTk5FQ1RFRDtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciB0cmltQmVlZiA9IG5ldyBSZWdFeHAoJ14oREVBRHxCRUVGfEFEQkVFRnxFRkRFQUQpKERFQUR8QkVFRikrKDIzMjMpJyk7XG4gICAgSGlkQVBJLnByb3RvdHlwZS5oaWRSZWFkID0gZnVuY3Rpb24oc2l6ZSwgdGltZW91dCkge1xuICAgICAgICBpZiAodGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aW1lb3V0ID0gMzAwMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzaXplID0gNjQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhpZGFwaSA9IHRoaXM7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IHRoaXMuJHEuZGVmZXIoKTtcbiAgICAgICAgdGhpcy4kdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGhpZGFwaS5kZXZpY2UoKS5oaWRfcmVhZChzaXplLCB0aW1lb3V0KS5yZXBsYWNlKHRyaW1CZWVmLCAnJDMnKTtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5yZWplY3QoZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcblxuICAgIHZhciBtYWdpYyA9ICcyMzIzJztcbiAgICB2YXIgbWFnaWNSZWdleHAgPSBuZXcgUmVnRXhwKG1hZ2ljKTtcbiAgICB2YXIgbWFnaWNSZWdleHBFZGdlID0gbmV3IFJlZ0V4cCgnQkVFRigyMyl7MSwyfSQnKTtcbiAgICBIaWRBUEkucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihzZXJpYWxEYXRhLCB3YWl0KSB7XG4gICAgICAgIGlmIChzZXJpYWxEYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNlcmlhbERhdGEgPSAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGlkYXBpID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlkUmVhZCgpLnRoZW4oZnVuY3Rpb24obmV3RGF0YSkge1xuICAgICAgICAgICAgaGlkYXBpLiRzY29wZS5zdGF0dXMgPSBoaWRhcGkuU1RBVFVTX1JFQURJTkc7XG4gICAgICAgICAgICBzZXJpYWxEYXRhID0gc2VyaWFsRGF0YSArIG5ld0RhdGE7XG4gICAgICAgICAgICBpZiAobWFnaWNSZWdleHBFZGdlLnRlc3Qoc2VyaWFsRGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGlkYXBpLnJlYWQoc2VyaWFsRGF0YSwgd2FpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWFnaWNSZWdleHAudGVzdChzZXJpYWxEYXRhKSkge1xuICAgICAgICAgICAgICAgIC8vIGZpbmQgdGhlIHBvc2l0aW9uIG9mIHRoZSBtYWdpYyBzdHJpbmdcbiAgICAgICAgICAgICAgICB2YXIgaGVhZGVyUG9zaXRpb24gPSBzZXJpYWxEYXRhLnNlYXJjaChtYWdpYyk7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGhlYWRlciBpcyBjbG9zZSBlbm91Z2ggdG8gdGhlIGVuZCB0aGF0IHRoZVxuICAgICAgICAgICAgICAgIC8vIGNvbW1hbmQgYW5kIGNvbnRlbnQgbGVuZ3RoIGNvdWxkIGJlIGN1dCBvZmYsIGdvIGFoZWFkXG4gICAgICAgICAgICAgICAgLy8gYW5kIGdldCBtb3JlIGRhdGFcbiAgICAgICAgICAgICAgICBpZiAoaGVhZGVyUG9zaXRpb24gPj0gKHNlcmlhbERhdGEubGVuZ3RoIC0gKDY0IC0gNDgpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGlkYXBpLnJlYWQoc2VyaWFsRGF0YSwgd2FpdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNvbW1hbmQgaXMgdGhlIDIgYnl0ZXMgYWZ0ZXIgdGhlIG1hZ2ljXG4gICAgICAgICAgICAgICAgdmFyIGNvbW1hbmQgPSBzZXJpYWxEYXRhLnN1YnN0cmluZyhoZWFkZXJQb3NpdGlvbiArIDQsIGhlYWRlclBvc2l0aW9uICsgOCk7XG4gICAgICAgICAgICAgICAgLy8gcGF5bG9hZCBzaXplIGlzIDQgYnl0ZXMgYWZ0ZXIgY29tbWFuZFxuICAgICAgICAgICAgICAgIHZhciBwYXlsb2FkU2l6ZSA9IHNlcmlhbERhdGEuc3Vic3RyaW5nKGhlYWRlclBvc2l0aW9uICsgOCwgaGVhZGVyUG9zaXRpb24gKyAxNik7XG4gICAgICAgICAgICAgICAgLy8gcGFyc2UgdGhlIGhleCBudW1iZXIgdG8gZGVjaW1hbFxuICAgICAgICAgICAgICAgIHZhciBkZWNQYXlsb2FkU2l6ZSA9IHBhcnNlSW50KHBheWxvYWRTaXplLCAxNik7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGNvbnRlbnQgbGVuZ3RoIGlzIGxvbmdlciB0aGFuIHRoZSByZXN0IG9mIHRoZVxuICAgICAgICAgICAgICAgIC8vIGRhdGEsIGdvIGdldCBzb21lIG1vcmVcbiAgICAgICAgICAgICAgICBpZiAoKGhlYWRlclBvc2l0aW9uICsgMTYgKyAoMiAqIGRlY1BheWxvYWRTaXplKSkgPiBzZXJpYWxEYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGlkYXBpLnJlYWQoc2VyaWFsRGF0YSwgd2FpdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRoZSBwYXlsb2FkIHdpbGwgc3RhcnQgYWZ0ZXIgOCBieXRlc1xuICAgICAgICAgICAgICAgIHZhciBwYXlsb2FkID0gc2VyaWFsRGF0YS5zdWJzdHJpbmcoaGVhZGVyUG9zaXRpb24gKyAxNiwgaGVhZGVyUG9zaXRpb24gKyAxNiArICgyICogKGRlY1BheWxvYWRTaXplKSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBoaWRhcGkucHJvY2Vzc1Jlc3VsdHMoY29tbWFuZCwgcGF5bG9hZFNpemUsIHBheWxvYWQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghd2FpdCAmJiBzZXJpYWxEYXRhID09PSBcIlwiKSB7IC8vSWYgbm90aGluZyBpcyBkZXRlY3RlZCwgY2xvc2UgZG93biBwb3J0XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRGV2aWNlIHVucGx1Z2dlZFwiKTtcbiAgICAgICAgICAgICAgICBoaWRhcGkuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBoaWRhcGkuJHNjb3BlLnN0YXR1cyA9IGhpZGFwaS5TVEFUVVNfQ09OTkVDVEVEO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgSGlkQVBJLnByb3RvdHlwZS5wcm9jZXNzUmVzdWx0cyA9IGZ1bmN0aW9uKGNvbW1hbmQsIGxlbmd0aCwgcGF5bG9hZCkge1xuICAgICAgICB2YXIgRGV2aWNlID0gdGhpcy5wcm90b0J1aWxkZXIoKTtcbiAgICAgICAgY29tbWFuZCA9IGNvbW1hbmQuc3Vic3RyaW5nKDIsIDQpO1xuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgICBwYXlsb2FkOiB7fVxuICAgICAgICB9O1xuXG4gICAgICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICBjYXNlIFwiM0FcIjogLy8gaW5pdGlhbGl6ZVxuICAgICAgICAgICAgZGF0YS50eXBlID0gSGlkQVBJLlRZUEVfSU5JVElBTElaRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiMzBcIjogLy8gcHVibGljIGFkZHJlc3NcbiAgICAgICAgICAgIGRhdGEudHlwZSA9IEhpZEFQSS5UWVBFX1BVQkxJQ19BRERSRVNTO1xuICAgICAgICAgICAgZGF0YS5wYXlsb2FkLmVjZHNhID0gcGF5bG9hZC5zdWJzdHJpbmcoOCwgNzQpO1xuICAgICAgICAgICAgZGF0YS5wYXlsb2FkLnJpcGUxNjBvZjIgPSBwYXlsb2FkLnN1YnN0cmluZyg3OCwgMTE4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiMzFcIjogLy8gbnVtYmVyIG9mIGFkZHJlc3NlcyBpbiBsb2FkZWQgd2FsbGV0XG4gICAgICAgICAgICBkYXRhLnR5cGUgPSBIaWRBUEkuVFlQRV9BRERSRVNTX0NPVU5UO1xuICAgICAgICAgICAgZGF0YS5wYXlsb2FkLmNvdW50ID0gcGF5bG9hZC5zdWJzdHJpbmcoMiwgNCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIjMyXCI6IC8vIFdhbGxldCBsaXN0XG4gICAgICAgICAgICBkYXRhLnR5cGUgPSBIaWRBUEkuVFlQRV9XQUxMRVRfTElTVDtcbiAgICAgICAgICAgIGRhdGEucGF5bG9hZC53YWxsZXRzID0gRGV2aWNlLldhbGxldHMuZGVjb2RlSGV4KHBheWxvYWQpLndhbGxldF9pbmZvO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCIzM1wiOiAvLyBQaW5nIHJlc3BvbnNlXG4gICAgICAgICAgICBkYXRhLnR5cGUgPSBIaWRBUEkuVFlQRV9QT05HO1xuICAgICAgICAgICAgZGF0YS5wYXlsb2FkID0gRGV2aWNlLlBpbmdSZXNwb25zZS5kZWNvZGVIZXgocGF5bG9hZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIjM0XCI6IC8vIHN1Y2Nlc3NcbiAgICAgICAgICAgIGRhdGEudHlwZSA9IEhpZEFQSS5UWVBFX1NVQ0NFU1M7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIjM1XCI6IC8vIGdlbmVyYWwgcHVycG9zZSBlcnJvci9jYW5jZWxcbiAgICAgICAgICAgIGRhdGEudHlwZSA9IEhpZEFQSS5UWVBFX0VSUk9SO1xuICAgICAgICAgICAgdmFyIGhpZEVyciA9IERldmljZS5GYWlsdXJlLmRlY29kZUhleChwYXlsb2FkKTtcbiAgICAgICAgICAgIGRhdGEucGF5bG9hZCA9IG5ldyBFcnJvcihoaWRFcnIuZXJyb3JfbWVzc2FnZS50b1N0cmluZygndXRmOCcpKTtcbiAgICAgICAgICAgIGRhdGEucGF5bG9hZC5jb2RlID0gcGFyc2VJbnQoaGlkRXJyLmVycm9yX2NvZGUsIDEwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiMzZcIjogLy8gZGV2aWNlIHV1aWQgcmV0dXJuXG4gICAgICAgICAgICBkYXRhLnR5cGUgPSBIaWRBUEkuVFlQRV9VVUlEO1xuICAgICAgICAgICAgZGF0YS5wYXlsb2FkID0gRGV2aWNlLkRldmljZVVVSUQuZGVjb2RlSGV4KHBheWxvYWQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCIzOVwiOiAvLyBzaWduYXR1cmUgcmV0dXJuIFtvcmlnaW5hbF1cbiAgICAgICAgICAgIGRhdGEudHlwZSA9IEhpZEFQSS5UWVBFX1NJR05BVFVSRTtcbiAgICAgICAgICAgIGRhdGEucGF5bG9hZCA9IERldmljZS5TaWduYXR1cmUuZGVjb2RlSGV4KHBheWxvYWQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCI1MFwiOiAvLyBwbGVhc2UgYWNrXG4gICAgICAgICAgICBkYXRhLnR5cGUgPSBIaWRBUEkuVFlQRV9QTEVBU0VfQUNLO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCI1NlwiOiAvLyBwbGVhc2Ugb3RwXG4gICAgICAgICAgICBkYXRhLnR5cGUgPSBIaWRBUEkuVFlQRV9QTEVBU0VfT1RQO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCI2MlwiOiAvLyBwYXJzZSAmIGluc2VydCB4cHViIGZyb20gY3VycmVudCB3YWxsZXQgLy9SRVRVUk4gZnJvbSBzY2FuIHdhbGxldFxuICAgICAgICAgICAgZGF0YS50eXBlID0gSGlkQVBJLlRZUEVfWFBVQjtcbiAgICAgICAgICAgIGRhdGEucGF5bG9hZCA9IERldmljZS5DdXJyZW50V2FsbGV0WFBVQi5kZWNvZGVIZXgocGF5bG9hZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIjY0XCI6IC8vIHNpZ25hdHVyZSByZXR1cm5cbiAgICAgICAgICAgIGRhdGEudHlwZSA9IEhpZEFQSS5UWVBFX1NJR05BVFVSRV9SRVRVUk47XG4gICAgICAgICAgICB2YXIgc2lnbmVkU2NyaXB0cyA9IFtdO1xuICAgICAgICAgICAgdmFyIHNpZ3MgPSBEZXZpY2UuU2lnbmF0dXJlQ29tcGxldGUuZGVjb2RlSGV4KHBheWxvYWQpLnNpZ25hdHVyZV9jb21wbGV0ZV9kYXRhO1xuICAgICAgICAgICAgc2lncy5mb3JFYWNoKGZ1bmN0aW9uKHNpZykge1xuICAgICAgICAgICAgICAgIHZhciBzaWdIZXggPSBzaWcuc2lnbmF0dXJlX2RhdGFfY29tcGxldGUudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICAgICAgICAgIHZhciBzaWdTaXplID0gcGFyc2VJbnQoc2lnSGV4LnNsaWNlKDAsIDIpLCAxNik7XG4gICAgICAgICAgICAgICAgdmFyIHNpZ0NoYXJzID0gMiArIChzaWdTaXplICogMik7XG4gICAgICAgICAgICAgICAgc2lnSGV4ID0gc2lnSGV4LnNsaWNlKDAsIHNpZ0NoYXJzKTtcbiAgICAgICAgICAgICAgICBzaWduZWRTY3JpcHRzLnB1c2goc2lnSGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGF0YS5wYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgIHNpZ25lZFNjcmlwdHM6IHNpZ25lZFNjcmlwdHNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIjcxXCI6IC8vIG1lc3NhZ2Ugc2lnbmluZyByZXR1cm5cbiAgICAgICAgICAgIGRhdGEudHlwZSA9IEhpZEFQSS5UWVBFX01FU1NBR0VfU0lHTkFUVVJFO1xuICAgICAgICAgICAgdmFyIHByb3RvU2lnID0gRGV2aWNlLlNpZ25hdHVyZU1lc3NhZ2UuZGVjb2RlSGV4KHBheWxvYWQpLnNpZ25hdHVyZV9kYXRhX2NvbXBsZXRlO1xuICAgICAgICAgICAgZGF0YS5wYXlsb2FkID0gdGhpcy5oZXhVdGlsLmhleFRvQnl0ZXMocHJvdG9TaWcudG9TdHJpbmcoJ2hleCcpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZGF0YS50eXBlID0gSGlkQVBJLlRZUEVfRVJST1I7XG4gICAgICAgICAgICBkYXRhLnBheWxvYWQgPSBuZXcgRXJyb3IoXCJVbmtub3duIGNvbW1hbmQgcmVjZWl2ZWQ6IDAwXCIgKyBjb21tYW5kKTtcbiAgICAgICAgICAgIGRhdGEucGF5bG9hZC5jb2RlID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICBIaWRBUEkucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoaWRhcGkgPSB0aGlzO1xuICAgICAgICBoaWRhcGkuJHNjb3BlLnN0YXR1cyA9IG51bGw7XG4gICAgICAgIGhpZGFwaS5fZGV2aWNlID0gbnVsbDtcbiAgICAgICAgaGlkYXBpLl9wbHVnaW4gPSBudWxsO1xuICAgICAgICBjb25zb2xlLmRlYnVnKFwiY2xvc2VkXCIpO1xuICAgICAgICByZXR1cm4gaGlkYXBpLiR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcInNldHRuZyB0byBkaXNjb25uZWN0ZWRcIik7XG4gICAgICAgICAgICBoaWRhcGkuJHNjb3BlLnN0YXR1cyA9IGhpZGFwaS5TVEFUVVNfRElTQ09OTkVDVEVEO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIHJlYWRUaW1lb3V0ID0gMTA7XG4gICAgdmFyIGNvdW50ZXJNYXggPSAoMTIwICogMTAwMCkgLyByZWFkVGltZW91dDsgLy8gYXBweCAyIG1pbnV0ZXMgdGltZW91dFxuXG4gICAgSGlkQVBJLnByb3RvdHlwZS5fZG9Db21tYW5kID0gZnVuY3Rpb24oY29tbWFuZCwgZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIHZhciBoaWRhcGkgPSB0aGlzO1xuICAgICAgICBoaWRhcGkuZG9pbmdDb21tYW5kID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGhpZGFwaS53cml0ZShjb21tYW5kKS50aGVuKGZ1bmN0aW9uKHdyaXR0ZW4pIHtcbiAgICAgICAgICAgIGlmICh3cml0dGVuID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhpZGFwaS5jbG9zZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoaWRhcGkuJHEucmVqZWN0KG5ldyBFcnJvcihcIk5vIGRhdGEgd3JpdHRlblwiKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHdyaXR0ZW4gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhpZGFwaS5jbG9zZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoaWRhcGkuJHEucmVqZWN0KG5ldyBFcnJvcihcIldyaXRlIGVycm9yXCIpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgICAgICAgIHZhciBkb1JlYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGlkYXBpLnJlYWQoJycsICd3YWl0IHBsZWFzZScpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlciA9PT0gY291bnRlck1heCkgeyAvLyB0d28gbWludXRlcy4uLiBpc2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGlkYXBpLmNsb3NlKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhpZGFwaS4kcS5yZWplY3QobmV3IEVycm9yKFwiQ29tbWFuZCByZXNwb25zZSB0aW1lb3V0XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoaWRhcGkuJHRpbWVvdXQoZG9SZWFkLCByZWFkVGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSBIaWRBUEkuVFlQRV9FUlJPUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGlkYXBpLmRvaW5nQ29tbWFuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhpZGFwaS4kcS5yZWplY3QoZGF0YS5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09IEhpZEFQSS5UWVBFX1BMRUFTRV9BQ0spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoaWRhcGkuX2RvQ29tbWFuZChoaWRhcGkuY29tbWFuZHMuYnV0dG9uX2FjaywgZXhwZWN0ZWRUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnR5cGUgPT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGdvdCB3aGF0IHdlIHdhbnRlZCwgcmV0dXJuIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkYXBpLmRvaW5nQ29tbWFuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhpZGFwaS4kdGltZW91dChkb1JlYWQsIHJlYWRUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGFwaS5kb2luZ0NvbW1hbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGhpZGFwaS4kdGltZW91dChmdW5jdGlvbigpe30pXG4gICAgICAgICAgICAgICAgLnRoZW4oZG9SZWFkKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gaGlkYXBpLmNsb3NlKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGlkYXBpLiRxLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBIaWRBUEkucHJvdG90eXBlLm1ha2VDb21tYW5kID0gZnVuY3Rpb24ocHJlZml4LCBwcm90b0J1Zikge1xuICAgICAgICB2YXIgdG1wQnVmID0gcHJvdG9CdWYuZW5jb2RlKCk7XG4gICAgICAgIHZhciBtZXNzYWdlSGV4ID0gdG1wQnVmLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgdmFyIHR4U2l6ZUhleCA9IChtZXNzYWdlSGV4Lmxlbmd0aCAvIDIpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgd2hpbGUgKHR4U2l6ZUhleC5sZW5ndGggPCA4KSB7XG4gICAgICAgICAgICB0eFNpemVIZXggPSBcIjBcIiArIHR4U2l6ZUhleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJlZml4ICsgdHhTaXplSGV4ICsgbWVzc2FnZUhleDtcbiAgICB9O1xuXG4gICAgLy8gY29tbWFuZHMgdG8gYmUgY2FsbGVkIGZyb20gb3V0c2lkZSB0aGlzIGZpbGVcblxuICAgIEhpZEFQSS5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZG9Db21tYW5kKHRoaXMuY29tbWFuZHMucGluZywgdGhpcy5UWVBFX1BPTkcpO1xuICAgIH07XG5cbiAgICBIaWRBUEkucHJvdG90eXBlLmxpc3RXYWxsZXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kb0NvbW1hbmQodGhpcy5jb21tYW5kcy5saXN0X3dhbGxldHMsIHRoaXMuVFlQRV9XQUxMRVRfTElTVCk7XG4gICAgfTtcblxuICAgIEhpZEFQSS5wcm90b3R5cGUuZ2V0V2FsbGV0Q29tbWFuZCA9IGZ1bmN0aW9uKHR5cGUsIHdhbGxldE51bWJlcikge1xuICAgICAgICB2YXIgY21kID0gdGhpcy5jb21tYW5kc1t0eXBlICsgJ1dhbGxldFByZWZpeCddO1xuICAgICAgICB2YXIgbnVtSGV4ID0gcGFyc2VJbnQod2FsbGV0TnVtYmVyLCAxMCkudG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAobnVtSGV4Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgbnVtSGV4ID0gJzAnICsgbnVtSGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbWQgKyBudW1IZXg7XG4gICAgfTtcblxuICAgIEhpZEFQSS5wcm90b3R5cGUubG9hZFdhbGxldCA9IGZ1bmN0aW9uKHdhbGxldE51bWJlcikge1xuICAgICAgICB2YXIgY21kID0gdGhpcy5nZXRXYWxsZXRDb21tYW5kKCdsb2FkJywgd2FsbGV0TnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvQ29tbWFuZChjbWQsIHRoaXMuVFlQRV9TVUNDRVNTKTtcbiAgICB9O1xuXG4gICAgSGlkQVBJLnByb3RvdHlwZS5kZWxldGVXYWxsZXQgPSBmdW5jdGlvbih3YWxsZXROdW1iZXIpIHtcbiAgICAgICAgdmFyIGNtZCA9IHRoaXMuZ2V0V2FsbGV0Q29tbWFuZCgnZGVsZXRlJywgd2FsbGV0TnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvQ29tbWFuZChjbWQsIHRoaXMuVFlQRV9QTEVBU0VfT1RQKTtcbiAgICB9O1xuXG4gICAgSGlkQVBJLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvQ29tbWFuZCh0aGlzLmNvbW1hbmRzLmZvcm1hdF9zdG9yYWdlLCB0aGlzLlRZUEVfUExFQVNFX09UUCk7XG4gICAgfTtcblxuICAgIEhpZEFQSS5wcm90b3R5cGUuc2NhbldhbGxldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZG9Db21tYW5kKHRoaXMuY29tbWFuZHMuc2Nhbl93YWxsZXQsIHRoaXMuVFlQRV9YUFVCKTtcbiAgICB9O1xuXG4gICAgSGlkQVBJLnByb3RvdHlwZS5uZXdXYWxsZXQgPSBmdW5jdGlvbih3YWxsZXROdW1iZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIERldmljZSA9IHRoaXMucHJvdG9CdWlsZGVyKCk7XG4gICAgICAgIC8vIGxvb2sgdGhyb3VnaCB0aGUgb3B0aW9ucyBhbmQgZmlsbCBpbiB0aGUgZGF0YSBmb3IgdGhlIHByb3RvXG4gICAgICAgIC8vIGJ1ZmZlclxuICAgICAgICB2YXIgcHJvdG9EYXRhID0ge307XG4gICAgICAgIGlmIChvcHRpb25zLmlzU2VjdXJlKSB7XG4gICAgICAgICAgICB2YXIgcGFzcyA9IG5ldyBCeXRlQnVmZmVyKCk7XG4gICAgICAgICAgICBwYXNzLndyaXRlVWludDgoMHg3NCk7XG4gICAgICAgICAgICBwYXNzLmZsaXAoKTtcbiAgICAgICAgICAgIHByb3RvRGF0YS5wYXNzd29yZCA9IHBhc3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm90b0RhdGEucGFzc3dvcmQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHByb3RvRGF0YS5pc19oaWRkZW4gPSBvcHRpb25zLmlzSGlkZGVuID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICAvLyBnZXQgdGhlIG5hbWUgYW5kIHB1dCBpdCBpbiBhIGJ5dGUgYnVmZmVyXG4gICAgICAgIHZhciBuYW1lID0gIFwiV2FsbGV0IFwiICsgd2FsbGV0TnVtYmVyO1xuICAgICAgICBpZiAob3B0aW9ucy5uYW1lICYmICdzdHJpbmcnID09PSB0eXBlb2YgbmFtZSkge1xuICAgICAgICAgICAgbmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZUhleCA9IHRoaXMuaGV4VXRpbC50b1BhZGRlZEhleChuYW1lLCAzOSkgKyAnMDAnO1xuICAgICAgICB2YXIgbmFtZUJ1ZiA9IHRoaXMuaGV4VXRpbC5oZXhUb0J5dGVCdWZmZXIobmFtZUhleCk7XG4gICAgICAgIG5hbWVCdWYuZmxpcCgpO1xuICAgICAgICBwcm90b0RhdGEud2FsbGV0X25hbWUgPSBuYW1lQnVmO1xuICAgICAgICAvLyBtYWtlIGEgcHJvdG8gYnVmZmVyIGZvciB0aGUgZGF0YSwgZ2VuZXJhdGUgYSBjb21tYW5kIGFuZFxuICAgICAgICAvLyBzZW5kIGl0IG9mZlxuICAgICAgICB2YXIgbmV3V2FsbGV0TWVzc2FnZSA9IG5ldyBEZXZpY2UuTmV3V2FsbGV0KHByb3RvRGF0YSk7XG4gICAgICAgIC8vIGlmIGlzUmVzdG9yZSA9PT0gdHJ1ZSBpbiB0aGUgb3B0aW9uLCB1c2UgdGhlIHJlc3RvciBjb21tYW5kXG4gICAgICAgIC8vIGluc3RlYWQgKGV2ZXJ5dGhpbmcgZWxzZSBpcyB0aGUgc2FtZSlcbiAgICAgICAgdmFyIGNtZFByZWZpeCA9IChvcHRpb25zLmlzUmVzdG9yZSA9PT0gdHJ1ZSkgP1xuICAgICAgICAgICAgdGhpcy5jb21tYW5kcy5yZXN0b3JlV2FsbGV0UHJlZml4IDogdGhpcy5jb21tYW5kcy5uZXdXYWxsZXRQcmVmaXg7XG4gICAgICAgIC8vIG5vdyBtYWtlIGEgZnVsbCBjb21tYW5kIHVzaW5nIHRoZSBwcm90byBidWZmZXJcbiAgICAgICAgdmFyIGNtZCA9IHRoaXMubWFrZUNvbW1hbmQoY21kUHJlZml4LCBuZXdXYWxsZXRNZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvQ29tbWFuZChjbWQpO1xuICAgIH07XG5cbiAgICAvLyB0eCBpcyBmcm9tIGJpdGNvaW4vdHJhbnNhY3Rpb24uZmFjdG9yeS5qc1xuICAgIEhpZEFQSS5wcm90b3R5cGUuc2lnblRyYW5zYWN0aW9uID0gZnVuY3Rpb24odHgpIHtcbiAgICAgICAgdmFyIGhpZGFwaSA9IHRoaXM7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IHRoaXMuJHEuZGVmZXIoKTtcbiAgICAgICAgdmFyIERldmljZSA9IHRoaXMucHJvdG9CdWlsZGVyKCk7XG4gICAgICAgIHZhciBhZGRySGFuZGxlcnMgPSBbXTtcbiAgICAgICAgdmFyIGlucHV0RGF0YSA9IFtdO1xuICAgICAgICBhc3luYy5lYWNoU2VyaWVzKHR4LmlucHV0cywgZnVuY3Rpb24oaW5wdXQsIG5leHQpIHtcbiAgICAgICAgICAgIC8vIG1ha2UgYSBoYW5kbGVyXG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IGhpZGFwaS5tYWtlQWRkcmVzc0hhbmRsZXIoaW5wdXQuY2hhaW4sIGlucHV0LmNoYWluSW5kZXgpO1xuICAgICAgICAgICAgLy8gYWRkIHRvIHRoZSBoYW5kbGVyIGFycmF5XG4gICAgICAgICAgICBhZGRySGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICAgICAgICAgIC8vIGdldCB0aGUgaGV4IG9mIHRoZSBmdWxsIGlucHV0IHRyYW5zYWN0aW9uXG4gICAgICAgICAgICBoaWRhcGkuZ2V0VHhIZXgoaW5wdXQudHhfaGFzaF9iaWdfZW5kaWFuKS50aGVuKGZ1bmN0aW9uKGhleCkge1xuICAgICAgICAgICAgICAgIHZhciB0aGlzSW5wdXREYXRhID0gJzAxJztcbiAgICAgICAgICAgICAgICB0aGlzSW5wdXREYXRhICs9IGhpZGFwaS5oZXhVdGlsLmludFRvQmlnRW5kaWFuU3RyaW5nKGlucHV0LnR4X291dHB1dF9uLCA0KTtcbiAgICAgICAgICAgICAgICB0aGlzSW5wdXREYXRhICs9IGhleDtcbiAgICAgICAgICAgICAgICBpbnB1dERhdGEucHVzaCh0aGlzSW5wdXREYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICAgICAgfSwgbmV4dCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkYXRhU3RyaW5nID0gJzAwJztcbiAgICAgICAgICAgIGRhdGFTdHJpbmcgKz0gdHgudW5zaWduZWRIZXg7XG4gICAgICAgICAgICAvLyBoYXNoIHR5cGVcbiAgICAgICAgICAgIGRhdGFTdHJpbmcgKz0gJzAxMDAwMDAwJztcbiAgICAgICAgICAgIGRhdGFTdHJpbmcgPSBpbnB1dERhdGEuam9pbignJykgKyBkYXRhU3RyaW5nO1xuXG4gICAgICAgICAgICB2YXIgZGF0YUJ1ZiA9IGhpZGFwaS5oZXhVdGlsLmhleFRvQnl0ZUJ1ZmZlcihkYXRhU3RyaW5nKTtcbiAgICAgICAgICAgIGRhdGFCdWYuZmxpcCgpO1xuICAgICAgICAgICAgdmFyIHR4TWVzc2FnZSA9IG5ldyBEZXZpY2UuU2lnblRyYW5zYWN0aW9uRXh0ZW5kZWQoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3NfaGFuZGxlX2V4dGVuZGVkOiBhZGRySGFuZGxlcnMsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25fZGF0YTogZGF0YUJ1ZlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgY21kID0gaGlkYXBpLm1ha2VDb21tYW5kKGhpZGFwaS5jb21tYW5kcy5zaWduVHhQcmVmaXgsIHR4TWVzc2FnZSk7XG4gICAgICAgICAgICBoaWRhcGkuX2RvQ29tbWFuZChjbWQsIGhpZGFwaS5UWVBFX1NJR05BVFVSRV9SRVRVUk4pLnRoZW4oZGVmZXJyZWQucmVzb2x2ZSwgZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG5cbiAgICB2YXIgc2lnSGVhZGVycyA9IFtcbiAgICAgICAgXCItLS0tLUJFR0lOIEJJVENPSU4gU0lHTkVEIE1FU1NBR0UtLS0tLVwiLFxuICAgICAgICBcIi0tLS0tQkVHSU4gU0lHTkFUVVJFLS0tLS1cIixcbiAgICAgICAgXCItLS0tLUVORCBCSVRDT0lOIFNJR05FRCBNRVNTQUdFLS0tLS1cIlxuICAgIF07XG5cbiAgICBIaWRBUEkucHJvdG90eXBlLnNpZ25NZXNzYWdlID0gZnVuY3Rpb24oYWRkcmVzcywgY2hhaW4sIGNoYWluSW5kZXgsIG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIGhpZGFwaSA9IHRoaXM7XG4gICAgICAgIHZhciBEZXZpY2UgPSBoaWRhcGkucHJvdG9CdWlsZGVyKCk7XG4gICAgICAgIHZhciBtZXNzYWdlQnl0ZXMgPSBoaWRhcGkubWVzc2FnZVV0aWwubWFrZU1lc3NhZ2VCeXRlcyhtZXNzYWdlKTtcbiAgICAgICAgdmFyIG1lc3NhZ2VIZXggPSBoaWRhcGkuaGV4VXRpbC5ieXRlc1RvSGV4KG1lc3NhZ2VCeXRlcyk7XG4gICAgICAgIHZhciBtc2dCdWYgPSBoaWRhcGkuaGV4VXRpbC5oZXhUb0J5dGVCdWZmZXIobWVzc2FnZUhleCk7XG4gICAgICAgIG1zZ0J1Zi5mbGlwKCk7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoXCJzaWduTWVzc2FnZTogXCIsIG1lc3NhZ2UsIFwiLT5cIiwgbWVzc2FnZUJ5dGVzLCBcIi0+XCIsIG1lc3NhZ2VIZXgpO1xuICAgICAgICB2YXIgcHJvdG9Nc2cgPSBuZXcgRGV2aWNlLlNpZ25NZXNzYWdlKHtcbiAgICAgICAgICAgIGFkZHJlc3NfaGFuZGxlX2V4dGVuZGVkOiBoaWRhcGkubWFrZUFkZHJlc3NIYW5kbGVyKGNoYWluLCBjaGFpbkluZGV4KSxcbiAgICAgICAgICAgIG1lc3NhZ2VfZGF0YTogbXNnQnVmXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY21kID0gaGlkYXBpLm1ha2VDb21tYW5kKGhpZGFwaS5jb21tYW5kcy5zaWduTWVzc2FnZVByZWZpeCwgcHJvdG9Nc2cpO1xuICAgICAgICByZXR1cm4gaGlkYXBpLl9kb0NvbW1hbmQoY21kLCBoaWRhcGkuVFlQRV9NRVNTQUdFX1NJR05BVFVSRSkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgc2lnID0gaGlkYXBpLm1lc3NhZ2VVdGlsLnByb2Nlc3NTaWduYXR1cmUobWVzc2FnZSwgYWRkcmVzcywgZGF0YS5wYXlsb2FkKTtcbiAgICAgICAgICAgIGlmICghc2lnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhpZGFwaS4kcS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBzaWduYXR1cmUgcmV0dXJuZWRcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChbXG4gICAgICAgICAgICAgICAgc2lnSGVhZGVyc1swXSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIHNpZ0hlYWRlcnNbMV0sXG4gICAgICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzaWcsXG4gICAgICAgICAgICAgICAgc2lnSGVhZGVyc1syXVxuICAgICAgICAgICAgXSkuam9pbignXFxuJyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBIaWRBUEkucHJvdG90eXBlLm1ha2VBZGRyZXNzSGFuZGxlciA9IGZ1bmN0aW9uKGNoYWluLCBjaGFpbkluZGV4KSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0ge1xuICAgICAgICAgICAgYWRkcmVzc19oYW5kbGVfcm9vdDogMCxcbiAgICAgICAgICAgIGFkZHJlc3NfaGFuZGxlX2NoYWluOiBjaGFpbixcbiAgICAgICAgICAgIGFkZHJlc3NfaGFuZGxlX2luZGV4OiBjaGFpbkluZGV4XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGNoYWluID09PSAncmVjZWl2ZScpIHtcbiAgICAgICAgICAgIGhhbmRsZXIuYWRkcmVzc19oYW5kbGVfY2hhaW4gPSB0aGlzLlJFQ0VJVkVfQ0hBSU47XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhaW4gPT09ICdjaGFuZ2UnKSB7XG4gICAgICAgICAgICBoYW5kbGVyLmFkZHJlc3NfaGFuZGxlX2NoYWluID0gdGhpcy5DSEFOR0VfQ0hBSU47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNoYWluIG9uIGlucHV0OiBcIiArIGNoYWluKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgIH07XG5cbiAgICBIaWRBUEkucHJvdG90eXBlLnJlbmFtZVdhbGxldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIERldmljZSA9IHRoaXMucHJvdG9CdWlsZGVyKCk7XG4gICAgICAgIHZhciBuYW1lSGV4ID0gdGhpcy5oZXhVdGlsLnRvUGFkZGVkSGV4KG5hbWUsIDM5KSArICcwMCc7XG4gICAgICAgIGNvbnNvbGUuZGVidWcobmFtZSwgXCItPlwiLCBuYW1lSGV4KTtcbiAgICAgICAgdmFyIG5hbWVCdWYgPSB0aGlzLmhleFV0aWwuaGV4VG9CeXRlQnVmZmVyKG5hbWVIZXgpO1xuICAgICAgICBuYW1lQnVmLmZsaXAoKTtcbiAgICAgICAgLy8gbWFrZSBhIHByb3RvIGJ1ZmZlciBmb3IgdGhlIGRhdGEsIGdlbmVyYXRlIGEgY29tbWFuZCBhbmRcbiAgICAgICAgLy8gc2VuZCBpdCBvZmZcbiAgICAgICAgdmFyIG5ld1dhbGxldE1lc3NhZ2UgPSBuZXcgRGV2aWNlLkNoYW5nZVdhbGxldE5hbWUoe1xuICAgICAgICAgICAgd2FsbGV0X25hbWU6IG5hbWVCdWZcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjbWQgPSB0aGlzLm1ha2VDb21tYW5kKHRoaXMuY29tbWFuZHMucmVuYW1lV2FsbGV0UHJlZml4LCBuZXdXYWxsZXRNZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvQ29tbWFuZChjbWQpO1xuICAgIH07XG5cbiAgICBIaWRBUEkucHJvdG90eXBlLnNlbmRPVFAgPSBmdW5jdGlvbihvdHApIHtcbiAgICAgICAgdmFyIERldmljZSA9IHRoaXMucHJvdG9CdWlsZGVyKCk7XG4gICAgICAgIHZhciBvdHBNZXNzYWdlID0gbmV3IERldmljZS5PdHBBY2soe1xuICAgICAgICAgICAgb3RwOiBvdHAsXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY21kID0gdGhpcy5tYWtlQ29tbWFuZCh0aGlzLmNvbW1hbmRzLm90cFByZWZpeCwgb3RwTWVzc2FnZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kb0NvbW1hbmQoY21kKTtcbiAgICB9O1xuXG4gICAgSGlkQVBJLnByb3RvdHlwZS5zaG93UXIgPSBmdW5jdGlvbihjaGFpbkluZGV4KSB7XG4gICAgICAgIHZhciBEZXZpY2UgPSB0aGlzLnByb3RvQnVpbGRlcigpO1xuICAgICAgICB2YXIgb3RwTWVzc2FnZSA9IG5ldyBEZXZpY2UuRGlzcGxheUFkZHJlc3NBc1FSKHtcbiAgICAgICAgICAgIGFkZHJlc3NfaGFuZGxlX2luZGV4OiBjaGFpbkluZGV4LFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNtZCA9IHRoaXMubWFrZUNvbW1hbmQodGhpcy5jb21tYW5kcy5xclByZWZpeCwgb3RwTWVzc2FnZSk7XG4gICAgICAgIHZhciBoaWRhcGkgPSB0aGlzO1xuICAgICAgICByZXR1cm4gaGlkYXBpLndyaXRlKGNtZCkudGhlbihmdW5jdGlvbih3cml0dGVuKSB7XG4gICAgICAgICAgICBpZiAod3JpdHRlbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoaWRhcGkuJHEucmVqZWN0KG5ldyBFcnJvcihcIk5vIGRhdGEgd3JpdHRlblwiKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHdyaXR0ZW4gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhpZGFwaS4kcS5yZWplY3QobmV3IEVycm9yKFwiV3JpdGUgZXJyb3JcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgSGlkQVBJLnByb3RvdHlwZS5zZXRDaGFuZ2VBZGRyZXNzID0gZnVuY3Rpb24oY2hhaW5JbmRleCkgeyAgIFxuLy8gICAgIFx0Y29uc29sZS5kZWJ1ZyhcImluIHNldENoYW5nZUFkZHJlc3NcIik7XG4gICAgICAgIHZhciBEZXZpY2UgPSB0aGlzLnByb3RvQnVpbGRlcigpO1xuICAgICAgICB2YXIgb3RwTWVzc2FnZSA9IG5ldyBEZXZpY2UuU2V0Q2hhbmdlQWRkcmVzc0luZGV4KHtcbiAgICAgICAgICAgIGFkZHJlc3NfaGFuZGxlX2luZGV4OiBjaGFpbkluZGV4LFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNtZCA9IHRoaXMubWFrZUNvbW1hbmQodGhpcy5jb21tYW5kcy5zZXRDaGFuZ2VQcmVmaXgsIG90cE1lc3NhZ2UpO1xuICAgICAgICB2YXIgaGlkYXBpID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGhpZGFwaS53cml0ZShjbWQpLnRoZW4oZnVuY3Rpb24od3JpdHRlbikge1xuICAgICAgICAgICAgaWYgKHdyaXR0ZW4gPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGlkYXBpLiRxLnJlamVjdChuZXcgRXJyb3IoXCJObyBkYXRhIHdyaXR0ZW5cIikpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh3cml0dGVuID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoaWRhcGkuJHEucmVqZWN0KG5ldyBFcnJvcihcIldyaXRlIGVycm9yXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuXG5cbiAgICBIaWRBUEkucHJvdG90eXBlLmZsYXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoaWRhcGkgPSB0aGlzO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBoaWRhcGkuJHEuZGVmZXIoKTtcbiAgICAgICAgaGlkYXBpLiR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaGlkYXBpLmRldmljZSgpLmhpZF9zZW5kX2ZlYXR1cmVfcmVwb3J0KCcwMScpO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcblxufSkod2luZG93LCB3aW5kb3cuYW5ndWxhciwgd2luZG93LmFzeW5jLCB3aW5kb3cuZGNvZGVJTy5Qcm90b0J1Ziwgd2luZG93LmRjb2RlSU8uQnl0ZUJ1ZmZlcik7XG4iLCIoZnVuY3Rpb24od2luZG93LCBhbmd1bGFyKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgYW5ndWxhci5tb2R1bGUoJ2hpZCcpXG4gICAgICAgIC5kaXJlY3RpdmUoJ2hpZFBsdWdpbicsIHBsdWdpbik7XG5cbiAgICBwbHVnaW4uJGluamVjdCA9IFsnJGNvbXBpbGUnXTtcblxuICAgIGZ1bmN0aW9uIHBsdWdpbigkY29tcGlsZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbG0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcGx1Z2ludG1wbCA9ICc8b2JqZWN0IGhlaWdodD1cIjFcIiBpZD1cImhpZGFwaVBsdWdpblwiICcgK1xuICAgICAgICAgICAgICAgICAgICAndHlwZT1cImFwcGxpY2F0aW9uL3gtaGlkYXBpYnJvd3NlcnBsdWdpblwiIHdpZHRoPVwiMVwiPicgK1xuICAgICAgICAgICAgICAgICAgICAnPHBhcmFtIG5hbWU9XCJvbmxvYWRcIiB2YWx1ZT1cInBsdWdpbkxvYWRlZFwiPicgK1xuICAgICAgICAgICAgICAgICAgICAnPC9vYmplY3Q+JztcbiAgICAgICAgICAgICAgICB2YXIgYiA9ICRjb21waWxlKHBsdWdpbnRtcGwpKHNjb3BlKTtcbiAgICAgICAgICAgICAgICBlbG0ucmVwbGFjZVdpdGgoYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICB9XG5cbn0pKHdpbmRvdywgd2luZG93LmFuZ3VsYXIpO1xuIiwiKGZ1bmN0aW9uKHdpbmRvdywgYW5ndWxhcikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGFuZ3VsYXIubW9kdWxlKCdhcHAudXRpbCcpXG4gICAgICAgIC5mYWN0b3J5KCdDb29raWUnLCBDb29raWVGYWN0b3J5KTtcblxuICAgIENvb2tpZUZhY3RvcnkuJGluamVjdCA9IFsnaXBDb29raWUnXTtcblxuICAgIHZhciBERUZBVUxUX0NPT0tJRV9PUFRJT05TID0ge3BhdGg6ICcvJ307XG5cbiAgICBmdW5jdGlvbiBDb29raWVGYWN0b3J5KGlwQ29va2llKSB7XG4gICAgICAgIHZhciBDb29raWUgPSB7fTtcblxuICAgICAgICBDb29raWUuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG1ha2VPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIGlwQ29va2llKGtleSwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIENvb2tpZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBpcENvb2tpZShrZXkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIENvb2tpZS5yZW1vdmUgPSBmdW5jdGlvbihrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBtYWtlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBpcENvb2tpZS5yZW1vdmUoa2V5LCBvcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBtYWtlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMgfHwgJ29iamVjdCcgIT09IHR5cGVvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFuZ3VsYXIuZXh0ZW5kKERFRkFVTFRfQ09PS0lFX09QVElPTlMsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIENvb2tpZTtcbiAgICB9XG5cbn0pKHdpbmRvdywgd2luZG93LmFuZ3VsYXIpO1xuIiwiKGZ1bmN0aW9uKHdpbmRvdywgYW5ndWxhciwgQ3J5cHRvLCBCeXRlQnVmZmVyLCBCaWdJbnRlZ2VyKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgYW5ndWxhci5tb2R1bGUoJ2FwcC51dGlsJylcbiAgICAgICAgLmZhY3RvcnkoJ2hleFV0aWwnLCBIZXhGYWN0b3J5KTtcblxuICAgIEhleEZhY3RvcnkuJGluamVjdCA9IFtdO1xuXG4gICAgZnVuY3Rpb24gSGV4RmFjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIHN0cmluZyB0byBoZXggbWV0aG9kc1xuICAgICAgICAgICAgdXRmOFRvSGV4OiB1dGY4VG9IZXgsXG4gICAgICAgICAgICAvLyBhbGlhcyB0aGlzXG4gICAgICAgICAgICB0b0hleDogdXRmOFRvSGV4LFxuICAgICAgICAgICAgdG9QYWRkZWRIZXg6IHN0clRvUGFkZGVkSGV4LFxuICAgICAgICAgICAgLy8gaGV4IG1hbmlwdWxhdGlvbi9jb252ZXJzaW9uIG1ldGhvZHNcbiAgICAgICAgICAgIHBhZEJ5dGVzOiBwYWRCeXRlcyxcbiAgICAgICAgICAgIGhleFRvQnl0ZUJ1ZmZlcjogaGV4VG9CeXRlQnVmZmVyLFxuICAgICAgICAgICAgLy8gaGV4IHZhbHVlc1xuICAgICAgICAgICAgaW50VG9CaWdFbmRpYW5WYWx1ZTogaW50VG9CaWdFbmRpYW5WYWx1ZSxcbiAgICAgICAgICAgIGludFRvQmlnRW5kaWFuU3RyaW5nOiBpbnRUb0JpZ0VuZGlhblN0cmluZyxcbiAgICAgICAgICAgIC8vIGJ5dGUgdG8gaGV4IG1ldGhvZHNcbiAgICAgICAgICAgIGJ5dGVzVG9IZXg6IGJ5dGVzVG9IZXgsXG4gICAgICAgICAgICBoZXhUb0J5dGVzOiBoZXhUb0J5dGVzLFxuICAgICAgICAgICAgLy8gbWFrZSBhIGJpZyBlbmRpYW4gc3RyaW5nIHNtYWxsIGVuZGlhblxuICAgICAgICAgICAgbWFrZVN0cmluZ1NtYWxsRW5kaWFuOiBtYWtlU3RyaW5nU21hbGxFbmRpYW5cbiAgICAgICAgfTtcblxuICAgICAgICBmdW5jdGlvbiBzdHJUb1BhZGRlZEhleChzdHIsIHRhcmdldEJ5dGVzLCBwYWRCeXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFkQnl0ZXModXRmOFRvSGV4KHN0ciksIHRhcmdldEJ5dGVzLCBwYWRCeXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHV0ZjhUb0hleChzdHIpIHtcblx0XHQgICAgcmV0dXJuIGJ5dGVzVG9IZXgoQ3J5cHRvLmNoYXJlbmMuVVRGOC5zdHJpbmdUb0J5dGVzKHN0cikpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuXHRcdCAgICByZXR1cm4gQ3J5cHRvLnV0aWwuYnl0ZXNUb0hleChieXRlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgICAgICAgICAgcmV0dXJuIENyeXB0by51dGlsLmhleFRvQnl0ZXMoaGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHBhZEJ5dGVzKGhleCwgdGFyZ2V0Qnl0ZXMsIHBhZEJ5dGUpIHtcbiAgICAgICAgICAgIGlmIChwYWRCeXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYWRCeXRlID0gJzIwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWRCeXRlLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGFkZGluZyBieXRlIFwiICsgcGFkQnl0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNOYU4odGFyZ2V0Qnl0ZXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0YXJnZXQgYnl0ZXMgXCIgKyBwYWRCeXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChoZXgubGVuZ3RoIDwgKHRhcmdldEJ5dGVzICogMikpIHtcbiAgICAgICAgICAgICAgICBoZXggKz0gcGFkQnl0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoZXg7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBoZXhUb0J5dGVCdWZmZXIoaGV4KSB7XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKFwiY29udmVydGluZ1wiLCBoZXgsIFwidG8gYnl0ZSBidWZmZXJcIik7XG4gICAgICAgICAgICB2YXIgYnVmID0gbmV3IEJ5dGVCdWZmZXIoKTtcbiAgICAgICAgICAgIHZhciBoZXhMZW4gPSBoZXgubGVuZ3RoO1xuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGhleExlbjsgaSs9Mikge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGhleC5zdWJzdHJpbmcoaSwgaSArIDIpO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBwYXJzZUludCh2YWx1ZSwgMTYpO1xuICAgICAgICAgICAgICAgIGJ1Zi53cml0ZVVpbnQ4KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaW50VG9CaWdFbmRpYW5WYWx1ZShuLCBtaW5CeXRlcykge1xuICAgICAgICAgICAgbiA9IEJpZ0ludGVnZXIudmFsdWVPZihuKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG4udG9CeXRlQXJyYXlVbnNpZ25lZCgpLnJldmVyc2UoKTtcbiAgICAgICAgICAgIHdoaWxlICh2YWx1ZS5sZW5ndGggPCBtaW5CeXRlcykge1xuICAgICAgICAgICAgICAgIHZhbHVlLnB1c2goMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpbnRUb0JpZ0VuZGlhblN0cmluZyhuLCBtaW5CeXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzVG9IZXgoaW50VG9CaWdFbmRpYW5WYWx1ZShuLCBtaW5CeXRlcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbWFrZVN0cmluZ1NtYWxsRW5kaWFuKHN0cikge1xuICAgICAgICAgICAgdmFyIHNtYWxsRW5kaWFuID0gJyc7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gKHN0ci5sZW5ndGggLSAyKTsgaSA+PSAwOyBpIC09IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYnl0ZUNoYXJzID0gc3RyLnNsaWNlKGksIGkgKyAyKTtcbiAgICAgICAgICAgICAgICBzbWFsbEVuZGlhbiArPSBieXRlQ2hhcnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc21hbGxFbmRpYW47XG4gICAgICAgIH1cbiAgICB9XG5cbn0pKHdpbmRvdywgd2luZG93LmFuZ3VsYXIsIHdpbmRvdy5DcnlwdG8sIHdpbmRvdy5kY29kZUlPLkJ5dGVCdWZmZXIsIHdpbmRvdy5CaWdJbnRlZ2VyKTtcbiIsIihmdW5jdGlvbih3aW5kb3csIGFuZ3VsYXIpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBhbmd1bGFyLm1vZHVsZSgnYXBwLnV0aWwnKVxuICAgICAgICAuY29uZmlnKFRvYXN0Q29uZmlnKVxuICAgICAgICAuZmFjdG9yeSgnVG9hc3QnLCBUb2FzdEZhY3RvcnkpO1xuXG4gICAgVG9hc3RDb25maWcuJGluamVjdCA9IFsnbmdUb2FzdFByb3ZpZGVyJ107XG5cbiAgICBmdW5jdGlvbiBUb2FzdENvbmZpZyhuZ1RvYXN0KSB7XG4gICAgICAgIG5nVG9hc3QuY29uZmlndXJlKHtcbiAgICAgICAgICAgIHZlcnRpY2FsUG9zaXRpb246ICdib3R0b20nLFxuICAgICAgICAgICAgaG9yaXpvbnRhbFBvc2l0aW9uOiAnY2VudGVyJyxcbiAgICAgICAgICAgIGFuaW1hdGlvbjogJ2ZhZGUnXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIFRvYXN0RmFjdG9yeS4kaW5qZWN0ID0gWyduZ1RvYXN0J107XG5cbiAgICBmdW5jdGlvbiBUb2FzdEZhY3RvcnkobmdUb2FzdCkge1xuXG4gICAgICAgIHZhciBUb2FzdCA9IGZ1bmN0aW9uKCl7fTtcblxuICAgICAgICB2YXIgc2hvdyA9IFRvYXN0LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgICAgICBuZ1RvYXN0LmNyZWF0ZShwYXJhbXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIFRvYXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKHRvYXN0KSB7XG4gICAgICAgICAgICBuZ1RvYXN0LmRpc21pc3ModG9hc3QpO1xuICAgICAgICB9O1xuXG4gICAgICAgIFRvYXN0LnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgdGhpcy5zaG93KHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2luZm8nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBUb2FzdC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLnNob3coe1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnZGFuZ2VyJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgVG9hc3QucHJvdG90eXBlLmVycm9ySGFuZGxlciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiBpcyB1bmJvdW5kLCBkbyBub3QgdXNlICd0aGlzJ1xuICAgICAgICAgICAgc2hvdyh7XG4gICAgICAgICAgICAgICAgY29udGVudDogZXJyLm1lc3NhZ2UgfHwgZXJyLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2RhbmdlcidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIFRvYXN0LnByb3RvdHlwZS5zdWNjZXNzID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgdGhpcy5zaG93KHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3N1Y2Nlc3MnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBUb2FzdC5wcm90b3R5cGUud2FybmluZyA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdyh7XG4gICAgICAgICAgICAgICAgY29udGVudDogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICd3YXJuaW5nJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUb2FzdCgpO1xuICAgIH1cblxufSkod2luZG93LCB3aW5kb3cuYW5ndWxhcik7XG4iLCIoZnVuY3Rpb24od2luZG93LCBhbmd1bGFyKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgYW5ndWxhci5tb2R1bGUoJ2FwcC53YWxsZXQnKVxuICAgICAgICAuZGlyZWN0aXZlKCd3YWxsZXRDcmVhdGUnLCB3YWxsZXRDcmVhdGUpO1xuXG4gICAgd2FsbGV0Q3JlYXRlLiRpbmplY3QgPSBbJ1dhbGxldCcsICdUb2FzdCcsICdCSVAzOVdvcmRMaXN0J107XG5cbiAgICBmdW5jdGlvbiB3YWxsZXRDcmVhdGUoV2FsbGV0LCBUb2FzdCwgd29yZGxpc3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNjb3BlOiB7XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlTnVtYmVyczogJz0nLFxuICAgICAgICAgICAgICAgIG9uRmluaXNoOiAnJicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICd3YWxsZXQvY3JlYXRlLmh0bWwnLFxuICAgICAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUpIHtcblxuICAgICAgICAgICAgICAgIHJlc2V0KCk7XG5cbiAgICAgICAgICAgICAgICBzY29wZS5jcmVhdGVXYWxsZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuY3JlYXRpbmdXYWxsZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBXYWxsZXQuY3JlYXRlKHNjb3BlLm5ld1dhbGxldC5udW1iZXIsIHNjb3BlLm5ld1dhbGxldCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUub25GaW5pc2goKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgVG9hc3QuZXJyb3JIYW5kbGVyKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuY3JlYXRpbmdXYWxsZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIHdhbGxldHMgaXMgb24gdGhlIHBhcmVudCBzY29wZSwgd2hpY2ggdGhpcyBpbmhlcml0c1xuICAgICAgICAgICAgICAgIHNjb3BlLiR3YXRjaENvbGxlY3Rpb24oJ2F2YWlsYWJsZU51bWJlcnMnLCBmdW5jdGlvbihhdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF2YWlsYWJsZSAmJiBhdmFpbGFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIHNldCBzb21lIGRlZmF1bHQgdmFsdWVzIGZvciB0aGF0IGZvcm1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLm5ld1dhbGxldC5uYW1lID0gXCJXYWxsZXQgXCIgKyBhdmFpbGFibGVbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5uZXdXYWxsZXQubnVtYmVyID0gYXZhaWxhYmxlWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBzY29wZS51cGRhdGVXb3JkTnVtYmVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNjb3BlLnVzZXJXb3Jkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciB3b3JkcyA9IHNjb3BlLnVzZXJXb3Jkcy5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtYmVycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd29yZCA9IHdvcmRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdvcmRJbmRleCA9IHdvcmRsaXN0LmluZGV4T2Yod29yZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod29yZEluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlcnNbaV0gPSBcIklOVkFMSUQgV09SRFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJzW2ldID0gd29yZEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLndvcmRJbmRleGVzID0gbnVtYmVycztcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLm5ld1dhbGxldCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiV2FsbGV0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1iZXI6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NlY3VyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzSGlkZGVuOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUmVzdG9yZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbn0pKHdpbmRvdywgd2luZG93LmFuZ3VsYXIpO1xuIiwiKGZ1bmN0aW9uKHdpbmRvdywgYW5ndWxhcikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGFuZ3VsYXIubW9kdWxlKCdhcHAud2FsbGV0JylcbiAgICAgICAgLmRpcmVjdGl2ZSgnd2FsbGV0SW5mbycsIHdhbGxldEluZm8pO1xuXG4gICAgd2FsbGV0SW5mby4kaW5qZWN0ID0gWydUb2FzdCddO1xuXG4gICAgZnVuY3Rpb24gd2FsbGV0SW5mbyhUb2FzdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICAgICAgICB3YWxsZXQ6ICc9JyxcbiAgICAgICAgICAgICAgICBvbkRlbGV0ZTogJyYnLFxuICAgICAgICAgICAgICAgIGV4cGVydE1vZGU6ICc9JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ3dhbGxldC9pbmZvLmh0bWwnLFxuICAgICAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUpIHtcbiAgICAgICAgICAgICAgICBzY29wZS5yZWZyZXNoQmFsYW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5yZWZyZXNoaW5nQmFsYW5jZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLndhbGxldC51cGRhdGVCYWxhbmNlKCkuY2F0Y2goVG9hc3QuZXJyb3JIYW5kbGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUucmVmcmVzaGluZ0JhbGFuY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBzY29wZS5yZWZyZXNoVHJhbnNhY3Rpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnJlZnJlc2hpbmdUcmFuc2FjdGlvbnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzY29wZS53YWxsZXQubG9hZFRyYW5zYWN0aW9ucygpLmNhdGNoKFRvYXN0LmVycm9ySGFuZGxlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnJlZnJlc2hpbmdUcmFuc2FjdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBzY29wZS4kd2F0Y2hDb2xsZWN0aW9uKCd3YWxsZXQnLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ICYmIHYuYmFsYW5jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS53YWxsZXQuYmFsYW5jZSA9IHYuYmFsYW5jZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxufSkod2luZG93LCB3aW5kb3cuYW5ndWxhcik7XG4iLCIoZnVuY3Rpb24od2luZG93LCBhbmd1bGFyKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgYW5ndWxhci5tb2R1bGUoJ2FwcC53YWxsZXQnKVxuICAgICAgICAuZmFjdG9yeSgnV2FsbGV0U3RhdHVzJywgV2FsbGV0U3RhdHVzRmFjdG9yeSk7XG5cbiAgICBXYWxsZXRTdGF0dXNGYWN0b3J5LiRpbmplY3QgPSBbJyRyb290U2NvcGUnXTtcblxuICAgIGZ1bmN0aW9uIFdhbGxldFN0YXR1c0ZhY3RvcnkoJHJvb3RTY29wZSkge1xuXG4gICAgICAgIHZhciAkc2NvcGUgPSAkcm9vdFNjb3BlLiRuZXcoKTtcblxuICAgICAgICAkc2NvcGUuU1RBVFVTX0xPQURJTkdfVU5TUEVOVCA9IFwibG9hZGluZyB1bnNwZW50XCI7XG4gICAgICAgICRzY29wZS5TVEFUVVNfTE9BRElOR19UUkFOU0FDVElPTlMgPSBcImxvYWRpbmcgdHJhbnNhY3Rpb25zXCI7XG4gICAgICAgICRzY29wZS5TVEFUVVNfTE9BRElORyA9IFwibG9hZGluZ1wiO1xuICAgICAgICAkc2NvcGUuU1RBVFVTX1NFTkRJTkcgPSBcInNlbmRpbmdcIjtcbiAgICAgICAgJHNjb3BlLlNUQVRVU19TSUdOSU5HID0gXCJzaWduaW5nXCI7XG5cbiAgICAgICAgcmV0dXJuICRzY29wZTtcblxuICAgIH1cblxufSkod2luZG93LCB3aW5kb3cuYW5ndWxhcik7XG4iLCIoZnVuY3Rpb24od2luZG93LCBhbmd1bGFyKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgYW5ndWxhci5tb2R1bGUoJ2FwcC53YWxsZXQnKVxuICAgICAgICAuZGlyZWN0aXZlKCd0eEluZm9MaW5rJywgdHhJbmZvTGluayk7XG5cbiAgICB0eEluZm9MaW5rLiRpbmplY3QgPSBbXTtcblxuXHR2YXIgYmFzZVVybHJvb3QgPSAnaHR0cHM6Ly9iaXRsb3guaW8nO1xuXG4gICAgZnVuY3Rpb24gdHhJbmZvTGluaygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRScsXG4vLyAgICAgICAgICAgICB0ZW1wbGF0ZTogJzxhIG5nLWhyZWY9XCJodHRwczovL2Jsb2NrY2hhaW4uaW5mby9zZWFyY2gve3t0eGlkfX1cIiB0YXJnZXQ9XCJfYmxhbmtcIj57e2Rpc3BsYXl9fTwvYT4nLFxuICAgICAgICAgICAgdGVtcGxhdGU6ICc8YSBuZy1ocmVmPVwiJysgYmFzZVVybHJvb3QgKycvdHgve3t0eGlkfX1cIiB0YXJnZXQ9XCJfYmxhbmtcIj57e2Rpc3BsYXl9fTwvYT4nLFxuICAgICAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW0sIGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR4aWQgPSBzY29wZS50eGlkID0gYXR0cnMudHhpZDtcbiAgICAgICAgICAgICAgICBzY29wZS5kaXNwbGF5ID0gdHhpZC5zbGljZSgwLCA4KSArICcuLi4nICsgdHhpZC5zbGljZSh0eGlkLmxlbmd0aCAtIDksIHR4aWQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG59KSh3aW5kb3csIHdpbmRvdy5hbmd1bGFyKTtcbiIsIihmdW5jdGlvbih3aW5kb3csIGFuZ3VsYXIpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBhbmd1bGFyLm1vZHVsZSgnYXBwLndhbGxldCcpXG4gICAgICAgIC5jb25zdGFudCgnTUFYX1dBTExFVFMnLCA1MCk7XG5cbn0pKHdpbmRvdywgd2luZG93LmFuZ3VsYXIpO1xuIiwiKGZ1bmN0aW9uKHdpbmRvdywgYW5ndWxhcikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGFuZ3VsYXIubW9kdWxlKCdhcHAud2FsbGV0JylcbiAgICAgICAgLmNvbnRyb2xsZXIoJ1dhbGxldEN0cmwnLCBXYWxsZXRDdHJsKTtcblxuICAgIFdhbGxldEN0cmwuJGluamVjdCA9IFsnJHRpbWVvdXQnLCAnTUFYX1dBTExFVFMnLCAnV2FsbGV0JywgJ1RvYXN0JywgJ2hpZGFwaSddO1xuXG4gICAgZnVuY3Rpb24gV2FsbGV0Q3RybCgkdGltZW91dCwgTUFYX1dBTExFVFMsIFdhbGxldCwgVG9hc3QsIGhpZGFwaSkge1xuICAgICAgICB2YXIgdm0gPSB0aGlzO1xuXG4gICAgICAgIHZtLnJlYWRXYWxsZXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2bS5yZWFkaW5nV2FsbGV0cyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gV2FsbGV0Lmxpc3QoKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHdhbGxldHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdm0ud2FsbGV0cyA9IHdhbGxldHM7XG4gICAgICAgICAgICAgICAgICAgIHZtLm9wZW5XYWxsZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZWZyZXNoQXZhaWxhYmxlTnVtYmVycyh3YWxsZXRzKTtcbiAgICAgICAgICAgICAgICB9LCBUb2FzdC5lcnJvckhhbmRsZXIpXG4gICAgICAgICAgICAgICAgLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZtLnJlYWRpbmdXYWxsZXRzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdm0ubG9hZFdhbGxldCA9IGZ1bmN0aW9uKHdhbGxldCkge1xuICAgICAgICAgICAgdm0ub3BlbldhbGxldCA9IG51bGw7XG4gICAgICAgICAgICB2bS5sb2FkaW5nWHB1YiA9IHRydWU7XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKFwibG9hZGluZyB3YWxsZXRcIiwgd2FsbGV0Lm51bWJlcik7XG4gICAgICAgICAgICB2bS5vcGVuaW5nV2FsbGV0ID0gd2FsbGV0Lm51bWJlcjtcbiAgICAgICAgICAgIHdhbGxldC5vcGVuKClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdm0ub3BlbldhbGxldCA9IHdhbGxldDtcbiAgICAgICAgICAgICAgICB9LCBUb2FzdC5lcnJvckhhbmRsZXIsIGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKFwib3BlbiBub3RpZnlcIiwgc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gV2FsbGV0Lk5PVElGWV9YUFVCX0xPQURFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdm0ubG9hZGluZ1hwdWIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoXCJkb25lIGxvYWRpbmcgd2FsbGV0XCIsIHdhbGxldC5udW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICB2bS5vcGVuaW5nV2FsbGV0ID0gLTk5O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZtLnJlZnJlc2hCYWxhbmNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2bS5yZWZyZXNoaW5nQmFsYW5jZSA9IHRydWU7XG4gICAgICAgICAgICB2bS5vcGVuV2FsbGV0LnVwZGF0ZUJhbGFuY2UoKS5jYXRjaChUb2FzdC5lcnJvckhhbmRsZXIpXG4gICAgICAgICAgICAgICAgLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZtLnJlZnJlc2hpbmdCYWxhbmNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdm0uZGlyZWN0T3Blbk51bWJlciA9IDA7XG4gICAgICAgIHZtLmRpcmVjdExvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB3YWxsZXQ7XG4gICAgICAgICAgICB2bS53YWxsZXRzLmZvckVhY2goZnVuY3Rpb24odykge1xuICAgICAgICAgICAgICAgIGlmICh3Lm51bWJlciA9PT0gdm0uZGlyZWN0T3Blbk51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICB3YWxsZXQgPSB3O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCF3YWxsZXQpIHtcbiAgICAgICAgICAgICAgICB3YWxsZXQgPSBuZXcgV2FsbGV0KHtcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0X251bWJlcjogdm0uZGlyZWN0T3Blbk51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogNCxcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0X25hbWU6IFwiSElEREVOXCIsXG4gICAgICAgICAgICAgICAgICAgIHdhbGxldF91dWlkOiBcIkhJRERFTlwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdm0ubG9hZFdhbGxldCh3YWxsZXQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZtLnByZXBGb3JGbGFzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdm0uZmxhc2hpbmcgPSB0cnVlO1xuICAgICAgICAgICAgaGlkYXBpLmZsYXNoKCkuY2F0Y2goVG9hc3QuZXJyb3JIYW5kbGVyKVxuICAgICAgICAgICAgICAgIC5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2bS5mbGFzaGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG5cblxuICAgICAgICByZXNldCgpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlZnJlc2hBdmFpbGFibGVOdW1iZXJzKHdhbGxldHMpIHtcbiAgICAgICAgICAgIGlmICghd2FsbGV0cykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFzc2VtYmxlIGFycmF5IG9mIHdhbGxldCBudW1iZXJzXG4gICAgICAgICAgICB2YXIgYXZhaWxhYmxlID0gW107XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgKE1BWF9XQUxMRVRTICsgMSk7IGkrKykge1xuICAgICAgICAgICAgICAgIGF2YWlsYWJsZS5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm93IGxvb3AgdGhyb3VnaCB0aGUgd2FsbGV0cyBhbmQgcmVtb3ZlIGV4aXN0aW5nXG4gICAgICAgICAgICAvLyBudW1iZXJzXG4gICAgICAgICAgICB3YWxsZXRzLmZvckVhY2goZnVuY3Rpb24od2FsbGV0KSB7XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlLnNwbGljZShhdmFpbGFibGUuaW5kZXhPZih3YWxsZXQubnVtYmVyKSwgMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHNldCB0byB0aGUgdm0gZm9yIHRoZSBuZXcgd2FsbGV0IGZvcm1cbiAgICAgICAgICAgIHZtLmF2YWlsYWJsZVdhbGxldE51bWJlcnMgPSBhdmFpbGFibGU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgIC8vIHN0YXR1cyB2YXJpYWJsZXNcbiAgICAgICAgICAgIHZtLnJlYWRpbmdXYWxsZXRzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZtLm9wZW5pbmdXYWxsZXQgPSAtOTk7XG4gICAgICAgICAgICB2bS5zY2FubmluZ1dhbGxldCA9IGZhbHNlO1xuICAgICAgICAgICAgdm0uY3JlYXRpbmdXYWxsZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZtLnJlZnJlc2hpbmdCYWxhbmNlID0gZmFsc2U7XG4gICAgICAgICAgICB2bS5vcGVuV2FsbGV0ID0gbnVsbDtcbiAgICAgICAgICAgIC8vIHJlYWQgYWZ0ZXIgYSB0aW1lb3V0LCBzbyBhbmd1bGFyIGRvZXMgbm90IGhhbmcgYW5kIHNob3dcbiAgICAgICAgICAgIC8vIGdhcmJhZ2Ugd2hpbGUgdGhlIGJyb3dzZXIgaXMgbG9ja2VkIGZvcm0gcmVhZGluIHRoZSBkZXZpY2VcbiAgICAgICAgICAgICR0aW1lb3V0KHZtLnJlYWRXYWxsZXRzLmJpbmQodm0pLCAxMDApO1xuICAgICAgICB9XG5cbiAgICB9XG5cbn0pKHdpbmRvdywgd2luZG93LmFuZ3VsYXIpO1xuIiwiKGZ1bmN0aW9uKHdpbmRvdywgYW5ndWxhciwgYXN5bmMpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBhbmd1bGFyLm1vZHVsZSgnYXBwLndhbGxldCcpXG4gICAgICAgIC5mYWN0b3J5KCdXYWxsZXQnLCBXYWxsZXRGYWN0b3J5KTtcblxuICAgIFdhbGxldEZhY3RvcnkuJGluamVjdCA9IFtcbiAgICAgICAgJyRxJywgJyR0aW1lb3V0JyxcbiAgICAgICAgJ1dhbGxldFN0YXR1cycsXG4gICAgICAgICdoaWRhcGknLCAnQklQMzInLCAnVHJhbnNhY3Rpb24nLCAnYWRkcmVzc0luZm8nLCAnTUlOX09VVFBVVCcsICdiY01hdGgnXTtcblxuICAgIGZ1bmN0aW9uIFdhbGxldEZhY3RvcnkoXG4gICAgICAgICRxLCAkdGltZW91dCxcbiAgICAgICAgV2FsbGV0U3RhdHVzLFxuICAgICAgICBoaWRhcGksIEJJUDMyLCBUcmFuc2FjdGlvbiwgYWRkcmVzc0luZm8sIE1JTl9PVVRQVVQsIGJjTWF0aCkge1xuXG4gICAgICAgIHZhciBXYWxsZXQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLm51bWJlciA9IGRhdGEud2FsbGV0X251bWJlcjtcbiAgICAgICAgICAgIHRoaXMudmVyc2lvbiA9IGRhdGEudmVyc2lvbjtcbiAgICAgICAgICAgIHRoaXMuX25hbWUgPSBkYXRhLndhbGxldF9uYW1lO1xuICAgICAgICAgICAgdGhpcy5fdXVpZCA9IGRhdGEud2FsbGV0X3V1aWQ7XG4gICAgICAgICAgICB0aGlzLmFkZHJlc3NlcyA9IHtcbiAgICAgICAgICAgICAgICByZWNlaXZlOiB7fSxcbiAgICAgICAgICAgICAgICBjaGFuZ2U6IHt9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5iYWxhbmNlID0gMDtcbiAgICAgICAgICAgIHRoaXMudW5zcGVudCA9IFtdO1xuICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbnMgPSBbXTtcbiAgICAgICAgfTtcblxuICAgICAgICBXYWxsZXQuTk9USUZZX1hQVUJfTE9BREVEID0gJ3hwdWIgbG9hZGVkJztcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2FsbGV0LnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fbmFtZSB8fCAhdGhpcy5fbmFtZS50b1N0cmluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25hbWUudG9TdHJpbmcoXCJ1dGY4XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2FsbGV0LnByb3RvdHlwZSwgJ3V1aWQnLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fdXVpZCB8fCAhdGhpcy5fdXVpZC50b1N0cmluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3V1aWQudG9TdHJpbmcoXCJ1dGY4XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2FsbGV0LnByb3RvdHlwZSwgJ2lzU2VjdXJlJywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJzaW9uID09PSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2FsbGV0LnByb3RvdHlwZSwgJ2lzSGlkZGVuJywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJzaW9uID09PSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBXYWxsZXQubGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGhpZGFwaS5saXN0V2FsbGV0cygpLnRoZW4oZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdhbGxldHMgPSBbXTtcbiAgICAgICAgICAgICAgICByZXMucGF5bG9hZC53YWxsZXRzLmZvckVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB3YWxsZXRzLnB1c2gobmV3IFdhbGxldChkYXRhKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdhbGxldHM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBXYWxsZXQuY3JlYXRlID0gZnVuY3Rpb24od2FsbGV0TnVtYmVyLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gaGlkYXBpLm5ld1dhbGxldCh3YWxsZXROdW1iZXIsIG9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHNjYW4gdGhlIGN1cnJlbnRseSBvcGVuIHdhbGxldCBhbmQgZ2V0IHRoZSBiaXAzMiBzb3VyY2Uga2V5XG4gICAgICAgIC8vIGZyb20gdGhlIGRhdGFcbiAgICAgICAgV2FsbGV0LmdldEJpcDMyID0gZnVuY3Rpb24od2FsbGV0KSB7XG4gICAgICAgICAgICByZXR1cm4gaGlkYXBpLnNjYW5XYWxsZXQoKS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmlwMzI7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYmlwMzIgPSBuZXcgQklQMzIoZGF0YS5wYXlsb2FkLnhwdWIpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2goZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihleCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkcS5yZWplY3QoZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3YWxsZXQueHB1YiA9IGRhdGEucGF5bG9hZC54cHViO1xuICAgICAgICAgICAgICAgIHdhbGxldC5iaXAzMiA9IGJpcDMyO1xuICAgICAgICAgICAgICAgIC8vIG5vdyB0aGF0IHdlIGhhdmUgYWRkcmVzc2VzLCB1cGRhdGUgdGhlIGJhbGFuY2UgZm9yXG4gICAgICAgICAgICAgICAgLy8gdGhlIHdhbGxldFxuICAgICAgICAgICAgICAgIHJldHVybiB3YWxsZXQudXBkYXRlQmFsYW5jZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgV2FsbGV0LnByb3RvdHlwZS5jbGVhclNwZW50ID0gZnVuY3Rpb24oaW5wdXRzKSB7XG4gICAgICAgICAgICB2YXIgd2FsbGV0ID0gdGhpcztcbiAgICAgICAgICAgIHdhbGxldC5iYWxhbmNlID0gMDtcbiAgICAgICAgICAgIHdhbGxldC51bnNwZW50ID0gW107XG4gICAgICAgICAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgICAgICAgIHZhciBhZGRyVHlwZSA9IGlucHV0LmNoYWluO1xuICAgICAgICAgICAgICAgIHZhciB0eGlkID0gaW5wdXQudHhfaGFzaF9iaWdfZW5kaWFuO1xuICAgICAgICAgICAgICAgIHZhciBhZGRyZXNzZXMgPSB3YWxsZXQuYWRkcmVzc2VzW2FkZHJUeXBlXTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhhZGRyZXNzZXMpLmZvckVhY2goZnVuY3Rpb24oYWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWRkckRhdGEgPSBhZGRyZXNzZXNbYWRkcmVzc107XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdVbnNwZW50ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGFkZHJEYXRhLnVuc3BlbnQuZm9yRWFjaChmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eGlkICE9PSBvdXRwdXQudHhfaGFzaF9iaWdfZW5kaWFuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VW5zcGVudC5wdXNoKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhZGRyRGF0YS51bnNwZW50ID0gbmV3VW5zcGVudDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB3YWxsZXQucmVjYWxjdWxhdGVCYWxhbmNlKGFkZHJUeXBlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gdGhlbiBhbHNvIGRvIGEgYmFsYW5jZSB1cGRhdGUgYWZ0ZXIgYSB0aW1lb3V0LFxuICAgICAgICAgICAgLy8gc28gd2UgZ2V0IHRoZSBkYXRhIHdlIGFjdHVhbGx5IG5lZWQgZm9yIHRoZVxuICAgICAgICAgICAgLy8gdW5zcGVudCBvdXRwdXRzIHdlIGhhdmVcbiAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHdhbGxldC51cGRhdGluZ0JhbGFuY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHdhbGxldC51cGRhdGVCYWxhbmNlKCk7XG4gICAgICAgICAgICAgICAgd2FsbGV0LmxvYWRUcmFuc2FjdGlvbnMoKTtcbiAgICAgICAgICAgIH0sIDUwMDApO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGFkZCB1cCB0aGUgdW5zcGVudCBvdXRwdXRzIG9uIGVhY2ggaW5wdXRcbiAgICAgICAgV2FsbGV0LnByb3RvdHlwZS5yZWNhbGN1bGF0ZUJhbGFuY2UgPSBmdW5jdGlvbihhZGRyVHlwZSkge1xuICAgICAgICAgICAgdmFyIHdhbGxldCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgYWRkcmVzc2VzID0gd2FsbGV0LmFkZHJlc3Nlc1thZGRyVHlwZV07XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhZGRyZXNzZXMpLmZvckVhY2goZnVuY3Rpb24oYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHZhciBhZGRyRGF0YSA9IGFkZHJlc3Nlc1thZGRyZXNzXTtcbiAgICAgICAgICAgICAgICB3YWxsZXQudW5jb25maXJtZWRCYWxhbmNlICs9IGFkZHJEYXRhLnVuY29uZmlybWVkQmFsYW5jZTtcbiAgICAgICAgICAgICAgICB3YWxsZXQuYmFsYW5jZSArPSBhZGRyRGF0YS5iYWxhbmNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgV2FsbGV0LnByb3RvdHlwZS5nZXRBbGxBZGRyZXNzZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB3YWxsZXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcbiAgICAgICAgICAgIFdhbGxldFN0YXR1cy5zdGF0dXMgPSBXYWxsZXRTdGF0dXMuU1RBVFVTX0xPQURJTkdfVU5TUEVOVDtcbiAgICAgICAgICAgIGFzeW5jLmVhY2goW1xuICAgICAgICAgICAgICAgIFwicmVjZWl2ZVwiLFxuICAgICAgICAgICAgICAgIFwiY2hhbmdlXCJcbiAgICAgICAgICAgIF0sIGZ1bmN0aW9uKGFkZHJUeXBlLCBkb25lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhc0FsbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcImdldHRpbmdcIiwgYWRkclR5cGUsIFwiYWRkcmVzc2VzXCIpO1xuICAgICAgICAgICAgICAgIGFzeW5jLnVudGlsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzQWxsO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uKG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2VuZXJhdGUgdGhlIGFkZHJlc3MgZm9yIHRoaXMgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFkZHJlc3MgPSB3YWxsZXQuYmlwMzIuZ2VuZXJhdGVBZGRyZXNzKGFkZHJUeXBlLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MuY2hhaW4gPSBhZGRyVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy5jaGFpbkluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MuYmFsYW5jZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MudW5jb25maXJtZWRCYWxhbmNlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSByZWNlaXZlZCBhbW91bnQgZm9yIHRoaXMgYWRkcmVzc1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzSW5mby5nZXRSZWNlaXZlZChhZGRyZXNzLnB1YikudGhlbihmdW5jdGlvbihyZWNlaXZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy5yZWNlaXZlZCA9IHJlY2VpdmVkO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy5iYWxhbmNlID0gcmVjZWl2ZWQuYmFsYW5jZSAtIChyZWNlaXZlZC51bmNvbmZpcm1lZF9zZW50IHx8IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy5iYWxhbmNlID0gcmVjZWl2ZWQuYmFsYW5jZVNhdCAtIChyZWNlaXZlZC51bmNvbmZpcm1lZEJhbGFuY2VTYXQgfHwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzcy5iYWxhbmNlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MuYmFsYW5jZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLnVuY29uZmlybWVkQmFsYW5jZSA9IHJlY2VpdmVkLnVuY29uZmlybWVkQmFsYW5jZVNhdCB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MudW5jb25maXJtZWRCYWxhbmNlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MudW5jb25maXJtZWRCYWxhbmNlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZC5yZWNlaXZlZCA+IDAgfHwgcmVjZWl2ZWQudW5jb25maXJtZWRfcmVjZWl2ZWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWl2ZWQudG90YWxSZWNlaXZlZFNhdCA+IDAgfHwgcmVjZWl2ZWQudW5jb25maXJtZWRCYWxhbmNlU2F0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluY3JlbWVudCB0aGUgaW5kZXggZm9yIHRoZSBuZXh0IHJ1blxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGluY3JlbWVudCB0aGUgYmlwIGtleSdzIGFkZHJlc3MgY291bnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWxsZXQuYmlwMzIua2V5Q291bnRbYWRkclR5cGVdICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBhZGRyZXNzIHRvIHRoZSB3YWxsZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWxsZXQuYWRkcmVzc2VzW2FkZHJUeXBlXVthZGRyZXNzLnB1Yl0gPSBhZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gY29udGludWUsIGdlbmVyYXRpbmcgYSBuZXcgYWRkcmVzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSByZWNlaXZlZCBhbnl0aGluZywgbG9vayBmb3IgdW5zcGVudCBvdXRwdXRzXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBqdXN0IHNldCB1bnNwZW50IHRvIGFuIGVtcHR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJyYXkgYW5kIG1vdmUgb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcy51bnNwZW50ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHRvIHRydWUsIHRvIGluZGljYXRlIHRoYXQgd2UgZG8gbm90XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBnZW5lcmF0ZSBhbnkgbW9yZSBhZGRyZXNzZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNBbGwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgYWRkcmVzcyB0byB0aGUgd2FsbGV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FsbGV0LmFkZHJlc3Nlc1thZGRyVHlwZV1bYWRkcmVzcy5wdWJdID0gYWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJUeXBlID09PSAncmVjZWl2ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FsbGV0Lm5leHRBZGRyZXNzID0gYWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkYXBpLnNob3dRcihpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGRyVHlwZSA9PT0gJ2NoYW5nZScpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FsbGV0Lm5leHRBZGRyZXNzID0gYWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkYXBpLnNldENoYW5nZUFkZHJlc3MoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBuZXh0KTsgLy8gcGFzcyBpbiBjYWxsYmFjayBhcyBwcm9taXNlIGZhaWx1cmUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICB9LCBkb25lKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucmVzb2x2ZSh3YWxsZXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgfTtcblxuICAgICAgICBXYWxsZXQucHJvdG90eXBlLmdldFVuc3BlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB3YWxsZXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcbiAgICAgICAgICAgIHdhbGxldC51bnNwZW50ID0gW107XG4gICAgICAgICAgICBhc3luYy5lYWNoKFtcbiAgICAgICAgICAgICAgICBcInJlY2VpdmVcIixcbiAgICAgICAgICAgICAgICBcImNoYW5nZVwiXG4gICAgICAgICAgICBdLCBmdW5jdGlvbihhZGRyVHlwZSwgZG9uZSkge1xuICAgICAgICAgICAgICAgIGFzeW5jLmZvckVhY2hPZih3YWxsZXQuYWRkcmVzc2VzW2FkZHJUeXBlXSwgZnVuY3Rpb24oYWRkcmVzcywgXywgbmV4dCkge1xuLy8gICAgICAgICAgICAgICAgICAgICBpZiAoIWFkZHJlc3MucmVjZWl2ZWQucmVjZWl2ZWQgJiYgIWFkZHJlc3MucmVjZWl2ZWQudW5jb25maXJtZWRfcmVjZWl2ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhZGRyZXNzLnJlY2VpdmVkLnRvdGFsUmVjZWl2ZWRTYXQgJiYgIWFkZHJlc3MucmVjZWl2ZWQudW5jb25maXJtZWRCYWxhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWxsZXQuYWRkcmVzc2VzW2FkZHJUeXBlXVthZGRyZXNzLnB1Yl0udW5zcGVudCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICB2YXIgdGhpc1VuY29uZmlybWVkU3BlbnQgPSAoYWRkcmVzcy5yZWNlaXZlZC51bmNvbmZpcm1lZF9iYWxhbmNlICsgYWRkcmVzcy5yZWNlaXZlZC5zZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoaXNVbmNvbmZpcm1lZFNwZW50ID0gKGFkZHJlc3MucmVjZWl2ZWQudW5jb25maXJtZWRCYWxhbmNlICsgYWRkcmVzcy5yZWNlaXZlZC50b3RhbFNlbnRTYXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc1VuY29uZmlybWVkU3BlbnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWxsZXQuYWRkcmVzc2VzW2FkZHJUeXBlXVthZGRyZXNzLnB1Yl0udW5zcGVudCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzSW5mby5nZXRVbnNwZW50KGFkZHJlc3MucHViKS50aGVuKGZ1bmN0aW9uKHVuc3BlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzc2lnbiB0aGUgY2hhaW4gYW5kIGNoYWluIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgZWFjaCBvdXRwdXQgZm9yIHdoZW4gd2UgZ28gdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuc3BlbnQuZm9yRWFjaChmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuY2hhaW4gPSBhZGRyVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuY2hhaW5JbmRleCA9IGFkZHJlc3MuY2hhaW5JbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWxsZXQudW5zcGVudC5wdXNoKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhbGxldC5hZGRyZXNzZXNbYWRkclR5cGVdW2FkZHJlc3MucHViXS51bnNwZW50ID0gdW5zcGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIG5leHQpOyAvLyBwYXNzIGluIGNhbGxiYWNrIGFzIHByb21pc2UgZmFpbHVyZSBmdW5jdGlvblxuICAgICAgICAgICAgICAgIH0sIGRvbmUpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5yZXNvbHZlKHdhbGxldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIFdhbGxldC5wcm90b3R5cGUudXBkYXRlQmFsYW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHdhbGxldCA9IHRoaXM7XG4gICAgICAgICAgICB3YWxsZXQudXBkYXRpbmdCYWxhbmNlID0gdHJ1ZTtcbiAgICAgICAgICAgIHdhbGxldC5iYWxhbmNlID0gMDtcbiAgICAgICAgICAgIHdhbGxldC51bmNvbmZpcm1lZEJhbGFuY2UgPSAwO1xuICAgICAgICAgICAgd2FsbGV0LnVuc3BlbnQgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiB3YWxsZXQuZ2V0QWxsQWRkcmVzc2VzKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBbXCJyZWNlaXZlXCIsIFwiY2hhbmdlXCJdLmZvckVhY2god2FsbGV0LnJlY2FsY3VsYXRlQmFsYW5jZSwgd2FsbGV0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2FsbGV0O1xuICAgICAgICAgICAgfSkuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB3YWxsZXQudXBkYXRpbmdCYWxhbmNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgV2FsbGV0U3RhdHVzLnN0YXR1cyA9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBXYWxsZXQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB3YWxsZXQgPSB0aGlzO1xuICAgICAgICAgICAgV2FsbGV0U3RhdHVzLnN0YXR1cyA9IFdhbGxldFN0YXR1cy5TVEFUVVNfTE9BRElORztcbiAgICAgICAgICAgIHZhciBkZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG4gICAgICAgICAgICBoaWRhcGkubG9hZFdhbGxldCh0aGlzLm51bWJlcikudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEudHlwZSAhPT0gaGlkYXBpLlRZUEVfU1VDQ0VTUykge1xuICAgICAgICAgICAgICAgICAgICB3YWxsZXQudW5sb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnJlamVjdChcIkVycm9yIG9wZW5pbmcgd2FsbGV0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5ub3RpZnkoV2FsbGV0Lk5PVElGWV9YUFVCX0xPQURFRCk7XG4gICAgICAgICAgICAgICAgd2FsbGV0LnVubG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBub3cgdGhhdCBpcyBpcyBvcGVuLCBnZXQgdGhlIGJpcDMyIGtleSBmb3IgdGhlXG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCB3YWxsZXRcbiAgICAgICAgICAgICAgICByZXR1cm4gV2FsbGV0LmdldEJpcDMyKHdhbGxldCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0LmxvYWRUcmFuc2FjdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnJlc29sdmUod2FsbGV0KTtcbiAgICAgICAgICAgICAgICB9LCBkZWZlcnJlZC5yZWplY3QpO1xuICAgICAgICAgICAgfSwgZGVmZXJyZWQucmVqZWN0KTtcbiAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgV2FsbGV0LnByb3RvdHlwZS5nZXRDaGFuZ2VBZGRyZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2hBZGRyO1xuICAgICAgICAgICAgdmFyIGFkZHJlc3NlcyA9IHRoaXMuYWRkcmVzc2VzLmNoYW5nZTtcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoXCJDaG9vc2luZyBjaGFuZ2UgYWRkcmVzc1wiKTtcbiAgICAgICAgICAgIGZvciAodmFyIGFkZHJlc3MgaW4gYWRkcmVzc2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFkZHJlc3Nlcy5oYXNPd25Qcm9wZXJ0eShhZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjZWl2ZWQgPSBhZGRyZXNzZXNbYWRkcmVzc10ucmVjZWl2ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZC50b3RhbFJlY2VpdmVkU2F0ID09PSAwICYmIHJlY2VpdmVkLnVuY29uZmlybWVkQmFsYW5jZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hBZGRyID0gYWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaEFkZHI7XG4gICAgICAgIH07XG5cbiAgICAgICAgV2FsbGV0LnByb3RvdHlwZS5zaG93UXIgPSBmdW5jdGlvbihjaGFpbkluZGV4KSB7XG4gICAgICAgIFx0cmV0dXJuIGhpZGFwaS5zaG93UXIoY2hhaW5JbmRleCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgV2FsbGV0LnByb3RvdHlwZS5zZXRDaGFuZ2VBZGRyZXNzID0gZnVuY3Rpb24oY2hhaW5JbmRleCkge1xuICAgICAgICBcdHJldHVybiBoaWRhcGkuc2V0Q2hhbmdlQWRkcmVzcyhjaGFpbkluZGV4KTtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIFdhbGxldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG91dHB1dHMsIGZlZSwgZm9yY2VTbWFsbENoYW5nZSkge1xuICAgICAgICAgICAgV2FsbGV0U3RhdHVzLnN0YXR1cyA9IFdhbGxldFN0YXR1cy5TVEFUVVNfU0VORElORztcbiAgICAgICAgICAgIHZhciB3YWxsZXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcIm1ha2luZyB0cmFuc2FjdGlvblwiKTtcbiAgICAgICAgICAgICAgICB2YXIgdHggPSBuZXcgVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzOiBvdXRwdXRzLFxuICAgICAgICAgICAgICAgICAgICBmZWU6IGZlZSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzOiB3YWxsZXQudW5zcGVudCxcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlQWRkcmVzczogd2FsbGV0LmdldENoYW5nZUFkZHJlc3MoKSxcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VTbWFsbENoYW5nZTogZm9yY2VTbWFsbENoYW5nZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBkbyB0aGUgc2VuZFxuICAgICAgICAgICAgICAgIGRvU2VuZCh0eCkudGhlbihkZWZlcnJlZC5yZXNvbHZlLCBkZWZlcnJlZC5yZWplY3QpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIFdhbGxldFN0YXR1cy5zdGF0dXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIFx0Y29uc29sZS5kZWJ1ZyhcImNhdWdodCBleGNlcHRpb24gaW4gbWFraW5nIHRyYW5zYWN0aW9uXCIpO1xuICAgICAgICAgICAgICAgIGlmIChleCA9PT0gVHJhbnNhY3Rpb24uRVJSX0FNT1VOVF9UT09fTE9XKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KFwiWW91IGNhbm5vdCBzZW5kIGxlc3MgdGhhbiBcIiArIGJjTWF0aC50b0JUQyhNSU5fT1VUUFVUKSArIFwiIEJUQ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChleC5jaGFuZ2UgIT09IHVuZGVmaW5lZCAmJiAnbnVtYmVyJyA9PT0gdHlwZW9mIGV4LmNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChleCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIGRvU2VuZCh0eCkge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcInNlbmQ6IHNpZ25pbmcgd2l0aCBkZXZpY2VcIik7XG4gICAgICAgICAgICAvLyBzaWduIHRoZSB0cmFuc2FjdGlvbiBvbiB0aGUgZGV2aWNlXG4gICAgICAgICAgICByZXR1cm4gaGlkYXBpLnNpZ25UcmFuc2FjdGlvbih0eClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWZ0ZXIgc2lnbmluZywgcmU0cGxhY2UgdGhlIGlucHV0IHNjcmlwdHNcbiAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCB0aGUgc2lnbmVkIHZlcnNpb25zXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoXCJzZW5kOiBzaWduZWQsIHJlcGxhY2luZyBzY3JpcHRzXCIpO1xuICAgICAgICAgICAgICAgICAgICB0eC5yZXBsYWNlU2NyaXB0cyhyZXMucGF5bG9hZC5zaWduZWRTY3JpcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiBzdWJtaXQgaXQgdG8gdGhlIG5ldHdvcmtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgV2FsbGV0LnByb3RvdHlwZS5zaWduTWVzc2FnZSA9IGZ1bmN0aW9uKGFkZHJlc3MsIGNoYWluLCBjaGFpbkluZGV4LCBtZXNzYWdlKSB7XG4gICAgICAgICAgICBXYWxsZXRTdGF0dXMuc3RhdHVzID0gV2FsbGV0U3RhdHVzLlNUQVRVU19TSUdOSU5HO1xuICAgICAgICAgICAgcmV0dXJuIGhpZGFwaS5zaWduTWVzc2FnZShhZGRyZXNzLCBjaGFpbiwgY2hhaW5JbmRleCwgbWVzc2FnZSlcbiAgICAgICAgICAgICAgICAuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgV2FsbGV0U3RhdHVzLnN0YXR1cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcmVuYW1lcyB0aGUgY3VycmVudGx5IGxvYWRlZCB3YWxsZXRcbiAgICAgICAgV2FsbGV0LnByb3RvdHlwZS5yZW5hbWUgPSBmdW5jdGlvbihuZXdOYW1lKSB7XG4gICAgICAgICAgICB2YXIgd2FsbGV0ID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBoaWRhcGkucmVuYW1lV2FsbGV0KG5ld05hbWUpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1Zyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHdhbGxldC5fbmFtZSA9IG5ld05hbWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBXYWxsZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGhpZGFwaS5kZWxldGVXYWxsZXQodGhpcy5udW1iZXIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIFdhbGxldC5wcm90b3R5cGUucmVtb3ZlQ29uZmlybSA9IGZ1bmN0aW9uKG90cCkge1xuICAgICAgICAgICAgcmV0dXJuIGhpZGFwaS5zZW5kT1RQKG90cCk7XG4gICAgICAgIH07XG5cbi8vICAgICAgICAgV2FsbGV0LnByb3RvdHlwZS5sb2FkVHJhbnNhY3Rpb25zID0gZnVuY3Rpb24oKSB7XG4vLyAgICAgICAgICAgICBXYWxsZXRTdGF0dXMuc3RhdHVzID0gV2FsbGV0U3RhdHVzLlNUQVRVU19MT0FESU5HX1RSQU5TQUNUSU9OUztcbi8vICAgICAgICAgICAgIHZhciB0cmFuc2FjdGlvbnMgPSBbXTtcbi8vICAgICAgICAgICAgIHZhciBmb3VuZEhhc2hlcyA9IFtdO1xuLy8gICAgICAgICAgICAgdmFyIHdhbGxldCA9IHRoaXM7XG4vLyAgICAgICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuLy8gICAgICAgICAgICAgd2FsbGV0LmxvYWRpbmdUcmFuc2FjdGlvbnMgPSB0cnVlO1xuLy8gICAgICAgICAgICAgYXN5bmMuZWFjaChbXG4vLyAgICAgICAgICAgICAgICAgXCJyZWNlaXZlXCIsXG4vLyAgICAgICAgICAgICAgICAgXCJjaGFuZ2VcIlxuLy8gICAgICAgICAgICAgXSwgZnVuY3Rpb24oYWRkclR5cGUsIGRvbmUpIHtcbi8vICAgICAgICAgICAgICAgICBhc3luYy5mb3JFYWNoT2Yod2FsbGV0LmFkZHJlc3Nlc1thZGRyVHlwZV0sIGZ1bmN0aW9uKGFkZHJlc3MsIF8sIG5leHQpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgaWYgKCFhZGRyZXNzLnJlY2VpdmVkLnRvdGFsUmVjZWl2ZWRTYXQgJiYgIWFkZHJlc3MucmVjZWl2ZWQudW5jb25maXJtZWRCYWxhbmNlKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuLy8gICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3NJbmZvLmdldFRyYW5zYWN0aW9ucyhhZGRyZXNzLnB1YikudGhlbihmdW5jdGlvbih0eHMpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHR4cy5mb3JFYWNoKGZ1bmN0aW9uKHR4KSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kSGFzaGVzLmluZGV4T2YodHguaGFzaCkgPT09IC0xKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kSGFzaGVzLnB1c2godHguaGFzaCk7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9ucy5wdXNoKHR4KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4vLyAgICAgICAgICAgICAgICAgICAgIH0sIG5leHQpO1xuLy8gICAgICAgICAgICAgICAgIH0sIGRvbmUpO1xuLy8gICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4vLyAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuLy8gICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucmVqZWN0KGVycik7XG4vLyAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucy5zb3J0KHR4U29ydCkubWFwKHdhbGxldC50eE1hcC5iaW5kKHdhbGxldCkpO1xuLy8gICAgICAgICAgICAgICAgIHdhbGxldC50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnM7XG4vLyAgICAgICAgICAgICAgICAgV2FsbGV0U3RhdHVzLnN0YXR1cyA9IG51bGw7XG4vLyAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnJlc29sdmUodHJhbnNhY3Rpb25zKTtcbi8vICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2UuZmluYWxseShmdW5jdGlvbigpIHtcbi8vICAgICAgICAgICAgICAgICB3YWxsZXQubG9hZGluZ1RyYW5zYWN0aW9ucyA9IGZhbHNlO1xuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgIH07XG5cbiAgICAgICAgV2FsbGV0LnByb3RvdHlwZS5sb2FkVHJhbnNhY3Rpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBXYWxsZXRTdGF0dXMuc3RhdHVzID0gV2FsbGV0U3RhdHVzLlNUQVRVU19MT0FESU5HX1RSQU5TQUNUSU9OUztcbiAgICAgICAgICAgIHZhciB0cmFuc2FjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIHZhciBmb3VuZEhhc2hlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHdhbGxldCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuICAgICAgICAgICAgd2FsbGV0LmxvYWRpbmdUcmFuc2FjdGlvbnMgPSB0cnVlO1xuICAgICAgICAgICAgYXN5bmMuZWFjaChbXG4gICAgICAgICAgICAgICAgXCJyZWNlaXZlXCIsXG4gICAgICAgICAgICAgICAgXCJjaGFuZ2VcIlxuICAgICAgICAgICAgXSwgZnVuY3Rpb24oYWRkclR5cGUsIGRvbmUpIHtcbiAgICAgICAgICAgICAgICBhc3luYy5mb3JFYWNoT2Yod2FsbGV0LmFkZHJlc3Nlc1thZGRyVHlwZV0sIGZ1bmN0aW9uKGFkZHJlc3MsIF8sIG5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhZGRyZXNzLnJlY2VpdmVkLnRvdGFsUmVjZWl2ZWRTYXQgJiYgIWFkZHJlc3MucmVjZWl2ZWQudW5jb25maXJtZWRCYWxhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3NJbmZvLmdldFRyYW5zYWN0aW9ucyhhZGRyZXNzLnB1YikudGhlbihmdW5jdGlvbih0eHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4cy5mb3JFYWNoKGZ1bmN0aW9uKHR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kSGFzaGVzLmluZGV4T2YodHgudHhpZCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kSGFzaGVzLnB1c2godHgudHhpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoXCJmb3VuZEhhc2hlcy5wdXNoKHR4LnR4aWQpIFwiICsgdHgudHhpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9ucy5wdXNoKHR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIG5leHQpO1xuICAgICAgICAgICAgICAgIH0sIGRvbmUpO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucy5zb3J0KHR4U29ydCkubWFwKHdhbGxldC50eE1hcC5iaW5kKHdhbGxldCkpO1xuICAgICAgICAgICAgICAgIHdhbGxldC50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnM7XG4gICAgICAgICAgICAgICAgV2FsbGV0U3RhdHVzLnN0YXR1cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnJlc29sdmUodHJhbnNhY3Rpb25zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2UuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB3YWxsZXQubG9hZGluZ1RyYW5zYWN0aW9ucyA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cblxuICAgICAgICBmdW5jdGlvbiB0eFNvcnQoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEuY29uZmlybWF0aW9ucyA8IGIuY29uZmlybWF0aW9ucyA/IC0xIDogMTtcbiAgICAgICAgfVxuXG5cdC8vIEFzc3VtZXMgdGhlIGFtb3VudCBpcyBkaXNwbGF5ZWQgYXMgYW4gZWlnaHQtZGlnaXQgYWZ0ZXIgdGhlIGNvbW1hIGZsb2F0IChzdHJpbmcpXHRcblx0XHRmdW5jdGlvbiBzdHJpbmdUb1NhdG9zaGlzKGFtb3VudEFzU3RyaW5nKSB7XG5cdFx0XHRhbW91bnRBc1N0cmluZyA9IGFtb3VudEFzU3RyaW5nLnJlcGxhY2UoL1xcLi9nLCcnKTtcblx0XHRcdHZhciBhbW91bnRBc0ludGVnZXIgPSAwO1xuXHRcdFx0dmFyIGk7XG5cdFx0XHR2YXIgYW1vdW50QXJyYXkgPSBhbW91bnRBc1N0cmluZy5zcGxpdChcIlwiKTtcblx0XHRcdGFtb3VudEFycmF5LnJldmVyc2UoKTtcblx0XHRcdGZvcihpID0gMDsgaSA8IGFtb3VudEFycmF5Lmxlbmd0aDsgaSsrKVxuXHRcdFx0e1xuXHRcdFx0XHRhbW91bnRBc0ludGVnZXIgPSBhbW91bnRBc0ludGVnZXIgKyAoKHBhcnNlSW50KGFtb3VudEFycmF5W2ldKSkqKE1hdGgucG93KDEwLGkpKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYW1vdW50QXNJbnRlZ2VyO1xuXHRcdH1cblxuXG5cbi8vICAgICAgICAgV2FsbGV0LnByb3RvdHlwZS50eE1hcCA9IGZ1bmN0aW9uKHR4KSB7XG4vLyAgICAgICAgICAgICB0eC50eXBlID0gJ3NlbmQnO1xuLy8gICAgICAgICAgICAgdmFyIHdhbGxldCA9IHRoaXM7XG4vLyAgICAgICAgICAgICB0eC50b3RhbEFtb3VudCA9IHR4LmFtb3VudDtcbi8vICAgICAgICAgICAgIHZhciBvd25BZGRyZXNzZXMgPSAwO1xuLy8gICAgICAgICAgICAgdmFyIGFkZHJDb3VudCA9IDA7XG4vLyAgICAgICAgICAgICB0eC5vdXRwdXRzLmZvckVhY2goZnVuY3Rpb24ob3V0KSB7XG4vLyAgICAgICAgICAgICAgICAgb3V0LmFkZHJlc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uKGFkZHIpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgYWRkckNvdW50ICs9IDE7XG4vLyAgICAgICAgICAgICAgICAgICAgIGlmICh3YWxsZXQuYWRkcmVzc2VzLnJlY2VpdmUuaGFzT3duUHJvcGVydHkoYWRkcikpIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHR4LnR5cGUgPSAncmVjZWl2ZSc7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBvd25BZGRyZXNzZXMgKz0gMTtcbi8vICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh3YWxsZXQuYWRkcmVzc2VzLmNoYW5nZS5oYXNPd25Qcm9wZXJ0eShhZGRyKSkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgb3duQWRkcmVzc2VzICs9IDE7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB0eC5hbW91bnQgLT0gb3V0LmFtb3VudDtcbi8vICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICAgfSk7XG4vLyAgICAgICAgICAgICBpZiAob3duQWRkcmVzc2VzID09PSBhZGRyQ291bnQpIHtcbi8vICAgICAgICAgICAgICAgICB0eC50eXBlID0gJ3RyYW5zZmVyJztcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgIGlmICh0eC50eXBlID09PSAncmVjZWl2ZScpIHtcbi8vICAgICAgICAgICAgICAgICB0eC5vdXRwdXRzLmZvckVhY2goZnVuY3Rpb24ob3V0KSB7XG4vLyAgICAgICAgICAgICAgICAgICAgIG91dC5hZGRyZXNzZXMuZm9yRWFjaChmdW5jdGlvbihhZGRyKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdhbGxldC5hZGRyZXNzZXMucmVjZWl2ZS5oYXNPd25Qcm9wZXJ0eShhZGRyKSAmJlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICF3YWxsZXQuYWRkcmVzc2VzLmNoYW5nZS5oYXNPd25Qcm9wZXJ0eShhZGRyKSkge1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LmFtb3VudCAtPSBvdXQuYW1vdW50O1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgfVxuLy8gICAgICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgICAgICB9KTtcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgIHJldHVybiB0eDtcbi8vICAgICAgICAgfTtcblxuICAgICAgICBXYWxsZXQucHJvdG90eXBlLnR4TWFwID0gZnVuY3Rpb24odHgpIHtcbiAgICAgICAgICAgIHR4LnR5cGUgPSAnc2VuZCc7XG4gICAgICAgICAgICB2YXIgd2FsbGV0ID0gdGhpcztcbiAgICAgICAgICAgIHR4LnRvdGFsQW1vdW50ID0gdHgudmFsdWVPdXQgKiAxMDAwMDAwMDA7XG4gICAgICAgICAgICB2YXIgb3duQWRkcmVzc2VzID0gMDtcbiAgICAgICAgICAgIHZhciBhZGRyQ291bnQgPSAwO1xuICAgICAgICAgICAgdHgudm91dC5mb3JFYWNoKGZ1bmN0aW9uKG91dCkge1xuICAgICAgICAgICAgICAgIG91dC5zY3JpcHRQdWJLZXkuYWRkcmVzc2VzLmZvckVhY2goZnVuY3Rpb24oYWRkcikge1xuICAgICAgICAgICAgICAgICAgICBhZGRyQ291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdhbGxldC5hZGRyZXNzZXMucmVjZWl2ZS5oYXNPd25Qcm9wZXJ0eShhZGRyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHgudHlwZSA9ICdyZWNlaXZlJztcbiAgICAgICAgICAgICAgICAgICAgICAgIG93bkFkZHJlc3NlcyArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHdhbGxldC5hZGRyZXNzZXMuY2hhbmdlLmhhc093blByb3BlcnR5KGFkZHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvd25BZGRyZXNzZXMgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoXCJTIG91dC52YWx1ZSBcIiArIG91dC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKFwiUyBzdHJpbmdUb1NhdG9zaGlzKG91dC52YWx1ZSkgXCIgKyBzdHJpbmdUb1NhdG9zaGlzKG91dC52YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0c1MgPSBzdHJpbmdUb1NhdG9zaGlzKG91dC52YWx1ZSk7XG5cdFx0XHRcdFx0XHR2YXIgZXBvY2hEYXRlID0gMDtcblx0XHRcdFx0XHRcdGlmICh0eC5jb25maXJtYXRpb25zID4gMCkge1xuXHRcdFx0XHRcdFx0XHRlcG9jaERhdGUgPSB0eC5ibG9ja3RpbWUqMTAwMDtcblx0XHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0XHRlcG9jaERhdGUgPSB0eC50aW1lKjEwMDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0eC5ibG9ja3RpbWUgPSBtb21lbnQoZXBvY2hEYXRlKS5mb3JtYXQoXCJZWVlZLU1NLUREIEhIOm1tXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHguYW1vdW50ID0gc3RzUztcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4LmZlZXMgPSB0eC5mZWVzICogMTAwMDAwMDAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcIlMgdHguZmVlcyBcIiArIHR4LmZlZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChvd25BZGRyZXNzZXMgPT09IGFkZHJDb3VudCkge1xuICAgICAgICAgICAgICAgIHR4LnR5cGUgPSAndHJhbnNmZXInO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoXCJUIHR4LmZlZXMgXCIgKyB0eC5mZWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eC50eXBlID09PSAncmVjZWl2ZScpIHtcbiAgICAgICAgICAgICAgICB0eC52b3V0LmZvckVhY2goZnVuY3Rpb24ob3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5zY3JpcHRQdWJLZXkuYWRkcmVzc2VzLmZvckVhY2goZnVuY3Rpb24oYWRkcikge1xuICAgICAgICAgICAgICAgICAgICBcdGNvbnNvbGUuZGVidWcoXCJSIGFkZHIgXCIgKyBhZGRyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3YWxsZXQuYWRkcmVzc2VzLnJlY2VpdmUuaGFzT3duUHJvcGVydHkoYWRkcikpIHtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZyhcIlIgb3V0LnZhbHVlIFwiICsgb3V0LnZhbHVlKTtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5kZWJ1ZyhcIlIgc3RyaW5nVG9TYXRvc2hpcyhvdXQudmFsdWUpIFwiICsgc3RyaW5nVG9TYXRvc2hpcyhvdXQudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFx0dmFyIHN0c1IgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgXHRzdHNSID0gc3RyaW5nVG9TYXRvc2hpcyhvdXQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXHR2YXIgZXBvY2hEYXRlMiA9IDA7XG5cdFx0XHRcdFx0XHRcdGlmICh0eC5jb25maXJtYXRpb25zID4gMCkge1xuXHRcdFx0XHRcdFx0XHRcdGVwb2NoRGF0ZTIgPSB0eC5ibG9ja3RpbWUqMTAwMDtcblx0XHRcdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRcdFx0ZXBvY2hEYXRlMiA9IHR4LnRpbWUqMTAwMDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0eC5ibG9ja3RpbWUgPSBtb21lbnQoZXBvY2hEYXRlMikuZm9ybWF0KFwiWVlZWS1NTS1ERCBISDptbVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5hbW91bnQgPSBzdHNSO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoXCJSIHR4LmFtb3VudCBcIiArIHR4LmFtb3VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHR4O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBXYWxsZXQ7XG5cbiAgICB9XG5cbn0pKHdpbmRvdywgd2luZG93LmFuZ3VsYXIsIHdpbmRvdy5hc3luYyk7XG4iLCIoZnVuY3Rpb24od2luZG93LCBhbmd1bGFyKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgYW5ndWxhci5tb2R1bGUoJ2FwcC53YWxsZXQnKVxuICAgICAgICAuY29uZmlnKGNvbmZpZyk7XG5cbiAgICBjb25maWcuJGluamVjdCA9IFsnJHJvdXRlUHJvdmlkZXInXTtcblxuICAgIGZ1bmN0aW9uIGNvbmZpZygkcm91dGVQcm92aWRlcikge1xuICAgICAgICAkcm91dGVQcm92aWRlci53aGVuKCcvJywge1xuICAgICAgICAgICAgY29udHJvbGxlcjogJ1dhbGxldEN0cmwnLFxuICAgICAgICAgICAgY29udHJvbGxlckFzOiAndm0nLFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICd3YWxsZXQvd2FsbGV0cy5odG1sJ1xuICAgICAgICB9KTtcbiAgICB9XG5cbn0pKHdpbmRvdywgd2luZG93LmFuZ3VsYXIpO1xuIiwiKGZ1bmN0aW9uKHdpbmRvdywgYW5ndWxhcikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGFuZ3VsYXIubW9kdWxlKCdhcHAud2FsbGV0JylcbiAgICAgICAgLmRpcmVjdGl2ZSgnd2FsbGV0QWRkcmVzc2VzJywgd2FsbGV0QWRkcmVzc2VzKTtcblxuICAgIHdhbGxldEFkZHJlc3Nlcy4kaW5qZWN0ID0gWydUb2FzdCddO1xuXG4gICAgZnVuY3Rpb24gd2FsbGV0QWRkcmVzc2VzKFRvYXN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZW1wbGF0ZVVybDogJ3dhbGxldC9pbmZvL2FkZHJlc3Nlcy5odG1sJyxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgICAgICAgICAgICAgLy8gc2l6ZSBvZiBhZGRyZXNzIFFSIGNvZGVzXG4gICAgICAgICAgICAgICAgc2NvcGUucXJzaXplID0gMTIwO1xuICAgICAgICAgICAgICAgIC8vIHdpbGwgaG9sZCB0cnV0aHkgdmFsdWVzIHRvIHNob3cgaW5kaXZpZHVhbCBRUiBjb2Rlc1xuICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgYWRkcmVzc2VzXG4gICAgICAgICAgICAgICAgc2NvcGUuc2hvd3FyID0ge307XG5cbiAgICAgICAgICAgICAgICBzY29wZS5zaG93UXIgPSBmdW5jdGlvbihhZGRyZXNzLCBjaGFpbkluZGV4LCBhZGRyVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5zaG93cXJbYWRkcmVzc10gPSAhc2NvcGUuc2hvd3FyW2FkZHJlc3NdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkclR5cGUgPT09ICdyZWNlaXZlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUud2FsbGV0LnNob3dRcihjaGFpbkluZGV4KS5jYXRjaChUb2FzdC5lcnJvckhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbn0pKHdpbmRvdywgd2luZG93LmFuZ3VsYXIpO1xuIiwiKGZ1bmN0aW9uKHdpbmRvdywgYW5ndWxhcikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGFuZ3VsYXIubW9kdWxlKCdhcHAud2FsbGV0JylcbiAgICAgICAgLmRpcmVjdGl2ZSgnd2FsbGV0RGVsZXRlJywgd2FsbGV0RGVsZXRlKTtcblxuICAgIHdhbGxldERlbGV0ZS4kaW5qZWN0ID0gWydXYWxsZXQnLCAnVG9hc3QnLCAnaGlkYXBpJ107XG5cbiAgICBmdW5jdGlvbiB3YWxsZXREZWxldGUoV2FsbGV0LCBUb2FzdCwgaGlkYXBpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY29wZToge1xuICAgICAgICAgICAgICAgIHdhbGxldDogJz0nLFxuICAgICAgICAgICAgICAgIG9uRGVsZXRlOiAnJicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICd3YWxsZXQvaW5mby9kZWxldGUuaHRtbCcsXG4gICAgICAgICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSkge1xuICAgICAgICAgICAgICAgIHNjb3BlLmRlbGV0ZVdhbGxldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5kZWxldGluZ1dhbGxldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLndhbGxldC5yZW1vdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUub3RwUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSwgVG9hc3QuZXJyb3JIYW5kbGVyKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuZGVsZXRlaW5nV2FsbGV0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBzY29wZS5mb3JtYXREZXZpY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuZm9ybWF0dGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGhpZGFwaS5mb3JtYXQoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUub3RwUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSwgVG9hc3QuZXJyb3JIYW5kbGVyKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuZm9ybWF0dGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgc2NvcGUuc2VuZE90cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5zZW5kaW5nT3RwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUud2FsbGV0LnJlbW92ZUNvbmZpcm0oc2NvcGUub3RwKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUub25EZWxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgVG9hc3QuZXJyb3JIYW5kbGVyKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUub3RwUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5zZW5kaW5nT3RwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG59KSh3aW5kb3csIHdpbmRvdy5hbmd1bGFyKTtcbiIsIihmdW5jdGlvbih3aW5kb3csIGFuZ3VsYXIpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBhbmd1bGFyLm1vZHVsZSgnYXBwLndhbGxldCcpXG4gICAgICAgIC5kaXJlY3RpdmUoJ3dhbGxldFJlbmFtZScsIHdhbGxldFJlbmFtZSk7XG5cbiAgICB3YWxsZXRSZW5hbWUuJGluamVjdCA9IFsnV2FsbGV0JywgJ1RvYXN0J107XG5cbiAgICBmdW5jdGlvbiB3YWxsZXRSZW5hbWUoV2FsbGV0LCBUb2FzdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICd3YWxsZXQvaW5mby9yZW5hbWUuaHRtbCcsXG4gICAgICAgICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSkge1xuICAgICAgICAgICAgICAgIHJlc2V0KCk7XG5cbiAgICAgICAgICAgICAgICBzY29wZS5yZW5hbWVXYWxsZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUucmVuYW1pbmdXYWxsZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzY29wZS53YWxsZXQucmVuYW1lKHNjb3BlLm5ld05hbWUpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICB9LCBUb2FzdC5lcnJvckhhbmRsZXIpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5yZW5hbWluZ1dhbGxldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLm5ld05hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbn0pKHdpbmRvdywgd2luZG93LmFuZ3VsYXIpO1xuIiwiKGZ1bmN0aW9uKHdpbmRvdywgYW5ndWxhcikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGFuZ3VsYXIubW9kdWxlKCdhcHAud2FsbGV0JylcbiAgICAgICAgLmRpcmVjdGl2ZSgnd2FsbGV0U2VuZCcsIHdhbGxldFNlbmQpO1xuXG4gICAgd2FsbGV0U2VuZC4kaW5qZWN0ID0gWydERUZBVUxUX0ZFRScsICdNSU5fT1VUUFVUJywgJ1RvYXN0JywgJ3R4VXRpbCddO1xuXG4gICAgZnVuY3Rpb24gd2FsbGV0U2VuZChERUZBVUxUX0ZFRSwgTUlOX09VVFBVVCwgVG9hc3QsIHR4VXRpbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICd3YWxsZXQvaW5mby9zZW5kLmh0bWwnLFxuICAgICAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUpIHtcblxuICAgICAgICAgICAgICAgIHNjb3BlLkRFRkFVTFRfRkVFID0gREVGQVVMVF9GRUU7XG4gICAgICAgICAgICAgICAgc2NvcGUuTUlOX09VVFBVVCA9IE1JTl9PVVRQVVQ7XG5cbiAgICAgICAgICAgICAgICBzY29wZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5vdXRwdXRzID0gW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbW91bnQ6IDBcbiAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLmZlZSA9IERFRkFVTFRfRkVFO1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5zaWduZWRIZXggPSBudWxsO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBzY29wZS5hZGRPdXRwdXQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBzY29wZS5vdXRwdXRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2NvcGUub3V0cHV0cy5zcGxpY2UoaW5kZXggKyAxLCAwLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW1vdW50OiAwXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBzY29wZS5yZW1vdmVPdXRwdXQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5vdXRwdXRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHNjb3BlLnNlbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuZHVzdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnVwZGF0aW5nQmFsYW5jZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLndhbGxldC5nZXRVbnNwZW50KCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLmRvU2VuZCgpO1xuICAgICAgICAgICAgICAgICAgICB9LCBUb2FzdC5lcnJvckhhbmRsZXIpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS51cGRhdGluZ0JhbGFuY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHNjb3BlLmFtb3VudENoYW5nZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUub3V0cHV0cy5mb3JFYWNoKGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWwgKz0gb3V0cHV0LmFtb3VudDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgodG90YWwgKyBzY29wZS5mZWUpID4gKHNjb3BlLndhbGxldC5iYWxhbmNlICsgc2NvcGUud2FsbGV0LnVuY29uZmlybWVkQmFsYW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnRvdGFsVG9vSGlnaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS50b3RhbFRvb0hpZ2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGUudG90YWxUb29IaWdoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS50b3RhbEV4Y2VlZHNDb25maXJtZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgodG90YWwgKyBzY29wZS5mZWUpID4gc2NvcGUud2FsbGV0LmJhbGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnRvdGFsRXhjZWVkc0NvbmZpcm1lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS50b3RhbEV4Y2VlZHNDb25maXJtZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBzY29wZS5kb1NlbmQgPSBmdW5jdGlvbihmb3JjZVNtYWxsQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnNlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUud2FsbGV0LnNlbmQoc2NvcGUub3V0cHV0cywgc2NvcGUuZmVlLCBmb3JjZVNtYWxsQ2hhbmdlKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbih0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnR4ID0gdHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuc2lnbmVkSGV4ID0gdHguc2lnbmVkSGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY29wZS5leHBlcnRNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRvYXN0LnN1Y2Nlc3MoXCJUcmFuc2FjdGlvbiBzaWduZWQuIFJldmlldyBhbmQgY29uZmlybS5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuc3VibWl0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCdudW1iZXInID09PSB0eXBlb2YgZXJyLmNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5kdXN0ID0gZXJyLmNoYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUb2FzdC5lcnJvckhhbmRsZXIoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5zZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgc2NvcGUuc21hbGxDaGFuZ2VUb0ZlZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHVzdCA9IHNjb3BlLmR1c3Q7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLmZlZSArPSBkdXN0O1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5kb1NlbmQoKS5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuZHVzdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBzY29wZS5zbWFsbENoYW5nZUxvd2VyRmVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkdXN0ID0gc2NvcGUuZHVzdDtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuZmVlIC09IChNSU5fT1VUUFVUIC0gZHVzdCk7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLmRvU2VuZCgpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5kdXN0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHNjb3BlLnNtYWxsQ2hhbmdlRm9yY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuZG9TZW5kKCdmb3JjZSBpdCcpLmZpbmFsbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5kdXN0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHNjb3BlLnN1Ym1pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5zdWJtaXR0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcInNjb3BlLnNpZ25lZEhleCB0byBzdWJtaXQ6IFwiICsgc2NvcGUuc2lnbmVkSGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdHhVdGlsLnN1Ym1pdChzY29wZS5zaWduZWRIZXgpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLndhbGxldC5jbGVhclNwZW50KHNjb3BlLnR4LmlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuc2lnbmVkSGV4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZS50eCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGUuZXhwZXJ0TW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUb2FzdC5zdWNjZXNzKFwiVHJhbnNhY3Rpb24gc3VibWl0dGVkIHRvIG5ldHdvcmtcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVG9hc3Quc3VjY2VzcyhcIlRyYW5zYWN0aW9uIHN1Y2Nlc3NcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgVG9hc3QuZXJyb3JIYW5kbGVyKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmluYWxseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5zdWJtaXR0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgc2NvcGUucmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbn0pKHdpbmRvdywgd2luZG93LmFuZ3VsYXIpO1xuIiwiKGZ1bmN0aW9uKHdpbmRvdywgYW5ndWxhcikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGFuZ3VsYXIubW9kdWxlKCdhcHAud2FsbGV0JylcbiAgICAgICAgLmRpcmVjdGl2ZSgnd2FsbGV0U2lnbicsIHdhbGxldFNpZ24pO1xuXG4gICAgd2FsbGV0U2lnbi4kaW5qZWN0ID0gWydUb2FzdCddO1xuXG4gICAgZnVuY3Rpb24gd2FsbGV0U2lnbihUb2FzdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICd3YWxsZXQvaW5mby9zaWduLmh0bWwnLFxuICAgICAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUpIHtcblxuICAgICAgICAgICAgICAgIHNjb3BlLm1lc3NhZ2UgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHNjb3BlLmFkZHJlc3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIHNjb3BlLnNpZ25lZCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICBzY29wZS5zaWduID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnNpZ25lZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLnNpZ25pbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzY29wZS53YWxsZXQuc2lnbk1lc3NhZ2Uoc2NvcGUuYWRkcmVzcy5wdWIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5hZGRyZXNzLmNoYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuYWRkcmVzcy5jaGFpbkluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUubWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKHNpZ25lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnNpZ25lZCA9IHNpZ25lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFRvYXN0LmVycm9ySGFuZGxlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLnNpZ25pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBzY29wZS4kd2F0Y2hDb2xsZWN0aW9uKCd3YWxsZXQnLCBmdW5jdGlvbih3YWxsZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF3YWxsZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgYWRkcmVzc0xpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFkZHJlc3NlcyA9IHdhbGxldC5hZGRyZXNzZXMucmVjZWl2ZTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoYWRkcmVzc2VzKS5mb3JFYWNoKGZ1bmN0aW9uKGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzZXNbYWRkcmVzc107XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIGEgbmV3IG9iamVjdCwgYmVjYXVzZSB0aGUgQklQMzJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9iamVjdCBjYXVzZXMgZXJyb3JzLi4gc29tZXRoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzb21ldGhpbmcgY2lyY3VsYXIgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzTGlzdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbjogYWRkcmVzcy5jaGFpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbkluZGV4OiBhZGRyZXNzLmNoYWluSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHViOiBhZGRyZXNzLnB1YlxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5hZGRyZXNzZXMgPSBhZGRyZXNzTGlzdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzY29wZS5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5hZGRyZXNzID0gYWRkcmVzc0xpc3RbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG59KSh3aW5kb3csIHdpbmRvdy5hbmd1bGFyKTtcbiIsIihmdW5jdGlvbih3aW5kb3csIGFuZ3VsYXIpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBhbmd1bGFyLm1vZHVsZSgnYXBwLndhbGxldCcpXG4gICAgICAgIC5kaXJlY3RpdmUoJ3dhbGxldFRyYW5zYWN0aW9ucycsIHdhbGxldFRyYW5zYWN0aW9ucyk7XG5cbiAgICB3YWxsZXRUcmFuc2FjdGlvbnMuJGluamVjdCA9IFtdO1xuXG4gICAgZnVuY3Rpb24gd2FsbGV0VHJhbnNhY3Rpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdFJyxcbiAgICAgICAgICAgIHRlbXBsYXRlVXJsOiAnd2FsbGV0L2luZm8vdHJhbnNhY3Rpb25zLmh0bWwnLFxuICAgICAgICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFnZVNpemUgPSBzY29wZS5wYWdlU2l6ZSA9IDEwO1xuXG4gICAgICAgICAgICAgICAgc2NvcGUuJHdhdGNoQ29sbGVjdGlvbignd2FsbGV0LnRyYW5zYWN0aW9ucycsIGZ1bmN0aW9uKHR4cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHhzICYmIEFycmF5LmlzQXJyYXkodHhzKSAmJiB0eHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFnZSA9IHNjb3BlLnBhZ2UgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUudHJhbnNhY3Rpb25zID0gbWFrZVR4U2xpY2UocGFnZSwgdHhzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgc2NvcGUucGFnZUNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzY29wZS50cmFuc2FjdGlvbnMgPSBtYWtlVHhTbGljZShzY29wZS5wYWdlLCBzY29wZS53YWxsZXQudHJhbnNhY3Rpb25zKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbWFrZVR4U2xpY2UocGFnZSwgdHhzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gcGFnZVNpemUgKiAocGFnZSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgcGFnZVNpemU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eHMuc2xpY2Uoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxufSkod2luZG93LCB3aW5kb3cuYW5ndWxhcik7XG4iXX0=
